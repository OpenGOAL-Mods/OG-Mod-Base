[
    {
        "label": "create_output_dir",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "download_release",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "finalize_bundle",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "get_args",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "override_binaries_and_assets",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "patch_mod_timestamp_and_version_info",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "create_output_dir",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "download_release",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "finalize_bundle",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "get_args",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "override_binaries_and_assets",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "patch_mod_timestamp_and_version_info",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "create_output_dir",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "download_release",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "finalize_bundle",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "get_args",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "override_binaries_and_assets",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "patch_mod_timestamp_and_version_info",
        "importPath": "common",
        "description": "common",
        "isExtraImport": true,
        "detail": "common",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "JSONEncoder",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "JSONEncoder",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "rmtree",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Vector",
        "importPath": "mathutils",
        "description": "mathutils",
        "isExtraImport": true,
        "detail": "mathutils",
        "documentation": {}
    },
    {
        "label": "gltf2_blender_gather_skins",
        "importPath": "io_scene_gltf2.blender.exp",
        "description": "io_scene_gltf2.blender.exp",
        "isExtraImport": true,
        "detail": "io_scene_gltf2.blender.exp",
        "documentation": {}
    },
    {
        "label": "bpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bpy",
        "description": "bpy",
        "detail": "bpy",
        "documentation": {}
    },
    {
        "label": "colorsys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "colorsys",
        "description": "colorsys",
        "detail": "colorsys",
        "documentation": {}
    },
    {
        "label": "bmesh",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bmesh",
        "description": "bmesh",
        "detail": "bmesh",
        "documentation": {}
    },
    {
        "label": "StringProperty",
        "importPath": "bpy.props",
        "description": "bpy.props",
        "isExtraImport": true,
        "detail": "bpy.props",
        "documentation": {}
    },
    {
        "label": "BoolProperty",
        "importPath": "bpy.props",
        "description": "bpy.props",
        "isExtraImport": true,
        "detail": "bpy.props",
        "documentation": {}
    },
    {
        "label": "IntProperty",
        "importPath": "bpy.props",
        "description": "bpy.props",
        "isExtraImport": true,
        "detail": "bpy.props",
        "documentation": {}
    },
    {
        "label": "FloatProperty",
        "importPath": "bpy.props",
        "description": "bpy.props",
        "isExtraImport": true,
        "detail": "bpy.props",
        "documentation": {}
    },
    {
        "label": "FloatVectorProperty",
        "importPath": "bpy.props",
        "description": "bpy.props",
        "isExtraImport": true,
        "detail": "bpy.props",
        "documentation": {}
    },
    {
        "label": "EnumProperty",
        "importPath": "bpy.props",
        "description": "bpy.props",
        "isExtraImport": true,
        "detail": "bpy.props",
        "documentation": {}
    },
    {
        "label": "PointerProperty",
        "importPath": "bpy.props",
        "description": "bpy.props",
        "isExtraImport": true,
        "detail": "bpy.props",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "bpy.types",
        "description": "bpy.types",
        "isExtraImport": true,
        "detail": "bpy.types",
        "documentation": {}
    },
    {
        "label": "Menu",
        "importPath": "bpy.types",
        "description": "bpy.types",
        "isExtraImport": true,
        "detail": "bpy.types",
        "documentation": {}
    },
    {
        "label": "Operator",
        "importPath": "bpy.types",
        "description": "bpy.types",
        "isExtraImport": true,
        "detail": "bpy.types",
        "documentation": {}
    },
    {
        "label": "PropertyGroup",
        "importPath": "bpy.types",
        "description": "bpy.types",
        "isExtraImport": true,
        "detail": "bpy.types",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QLabel",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMainWindow",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QTreeView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QPlainTextEdit",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QLineEdit",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QListView",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QDialog",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QSplitter",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QSizePolicy",
        "importPath": "PyQt5.QtWidgets",
        "description": "PyQt5.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt5.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QStandardItemModel",
        "importPath": "PyQt5.Qt",
        "description": "PyQt5.Qt",
        "isExtraImport": true,
        "detail": "PyQt5.Qt",
        "documentation": {}
    },
    {
        "label": "QStandardItem",
        "importPath": "PyQt5.Qt",
        "description": "PyQt5.Qt",
        "isExtraImport": true,
        "detail": "PyQt5.Qt",
        "documentation": {}
    },
    {
        "label": "QFont",
        "importPath": "PyQt5.Qt",
        "description": "PyQt5.Qt",
        "isExtraImport": true,
        "detail": "PyQt5.Qt",
        "documentation": {}
    },
    {
        "label": "QModelIndex",
        "importPath": "PyQt5.Qt",
        "description": "PyQt5.Qt",
        "isExtraImport": true,
        "detail": "PyQt5.Qt",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "unidiff",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unidiff",
        "description": "unidiff",
        "detail": "unidiff",
        "documentation": {}
    },
    {
        "label": "Fore",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "just_fix_windows_console",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Fore",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Back",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Style",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "just_fix_windows_console",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Fore",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Back",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Style",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "just_fix_windows_console",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Fore",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Back",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Style",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "pack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "pack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "unpack",
        "importPath": "struct",
        "description": "struct",
        "isExtraImport": true,
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "get_alltypes_path_from_game",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_gsrc_path_from_filename",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "decompile_file",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "is_file_in_game",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_gsrc_path_from_filename",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_ref_path_from_filename",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_file_list",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_gsrc_path_from_filename",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_gsrc_path_from_filename",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "decompile_file",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "networkx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "networkx",
        "description": "networkx",
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "CalledProcessError",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "STDOUT",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "STDOUT",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "Polynomial",
        "importPath": "numpy.polynomial.polynomial",
        "description": "numpy.polynomial.polynomial",
        "isExtraImport": true,
        "detail": "numpy.polynomial.polynomial",
        "documentation": {}
    },
    {
        "label": "update_alltypes_named_blocks",
        "importPath": "code_retention.all_types_retention",
        "description": "code_retention.all_types_retention",
        "isExtraImport": true,
        "detail": "code_retention.all_types_retention",
        "documentation": {}
    },
    {
        "label": "is_line_start_of_form",
        "importPath": "code_retention.code_retention",
        "description": "code_retention.code_retention",
        "isExtraImport": true,
        "detail": "code_retention.code_retention",
        "documentation": {}
    },
    {
        "label": "has_form_ended",
        "importPath": "code_retention.code_retention",
        "description": "code_retention.code_retention",
        "isExtraImport": true,
        "detail": "code_retention.code_retention",
        "documentation": {}
    },
    {
        "label": "Repo",
        "importPath": "git",
        "description": "git",
        "isExtraImport": true,
        "detail": "git",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "get_ref_path_from_filename",
        "importPath": "gsrc.utils",
        "description": "gsrc.utils",
        "isExtraImport": true,
        "detail": "gsrc.utils",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "x509",
        "importPath": "cryptography",
        "description": "cryptography",
        "isExtraImport": true,
        "detail": "cryptography",
        "documentation": {}
    },
    {
        "label": "default_backend",
        "importPath": "cryptography.hazmat.backends",
        "description": "cryptography.hazmat.backends",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.backends",
        "documentation": {}
    },
    {
        "label": "hashes",
        "importPath": "cryptography.hazmat.primitives",
        "description": "cryptography.hazmat.primitives",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives",
        "documentation": {}
    },
    {
        "label": "ec",
        "importPath": "cryptography.hazmat.primitives.asymmetric",
        "description": "cryptography.hazmat.primitives.asymmetric",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.asymmetric",
        "documentation": {}
    },
    {
        "label": "rsa",
        "importPath": "cryptography.hazmat.primitives.asymmetric",
        "description": "cryptography.hazmat.primitives.asymmetric",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.asymmetric",
        "documentation": {}
    },
    {
        "label": "EllipticCurvePrivateKey",
        "importPath": "cryptography.hazmat.primitives.asymmetric.ec",
        "description": "cryptography.hazmat.primitives.asymmetric.ec",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.asymmetric.ec",
        "documentation": {}
    },
    {
        "label": "RSAPrivateKey",
        "importPath": "cryptography.hazmat.primitives.asymmetric.rsa",
        "description": "cryptography.hazmat.primitives.asymmetric.rsa",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.asymmetric.rsa",
        "documentation": {}
    },
    {
        "label": "Encoding",
        "importPath": "cryptography.hazmat.primitives.serialization",
        "description": "cryptography.hazmat.primitives.serialization",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.serialization",
        "documentation": {}
    },
    {
        "label": "PrivateFormat",
        "importPath": "cryptography.hazmat.primitives.serialization",
        "description": "cryptography.hazmat.primitives.serialization",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.serialization",
        "documentation": {}
    },
    {
        "label": "NoEncryption",
        "importPath": "cryptography.hazmat.primitives.serialization",
        "description": "cryptography.hazmat.primitives.serialization",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.serialization",
        "documentation": {}
    },
    {
        "label": "load_pem_private_key",
        "importPath": "cryptography.hazmat.primitives.serialization",
        "description": "cryptography.hazmat.primitives.serialization",
        "isExtraImport": true,
        "detail": "cryptography.hazmat.primitives.serialization",
        "documentation": {}
    },
    {
        "label": "ExtendedKeyUsageOID",
        "importPath": "cryptography.x509",
        "description": "cryptography.x509",
        "isExtraImport": true,
        "detail": "cryptography.x509",
        "documentation": {}
    },
    {
        "label": "NameOID",
        "importPath": "cryptography.x509",
        "description": "cryptography.x509",
        "isExtraImport": true,
        "detail": "cryptography.x509",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "ConfigParser",
        "importPath": "configparser",
        "description": "configparser",
        "isExtraImport": true,
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "ExtendedInterpolation",
        "importPath": "configparser",
        "description": "configparser",
        "isExtraImport": true,
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "IncompleteReadError",
        "importPath": "asyncio",
        "description": "asyncio",
        "isExtraImport": true,
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "server",
        "importPath": "websockets",
        "description": "websockets",
        "isExtraImport": true,
        "detail": "websockets",
        "documentation": {}
    },
    {
        "label": "ConnectionClosedError",
        "importPath": "websockets.exceptions",
        "description": "websockets.exceptions",
        "isExtraImport": true,
        "detail": "websockets.exceptions",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Nghttpx",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Httpd",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "NghttpxQuic",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "NghttpxFwd",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Httpd",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Nghttpx",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Caddy",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "ExecResult",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "NghttpxFwd",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "LocalClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "ExecResult",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "ExecResult",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "ExecResult",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Caddy",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "LocalClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "ExecResult",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "ExecResult",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "LocalClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "LocalClient",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "testenv",
        "description": "testenv",
        "isExtraImport": true,
        "detail": "testenv",
        "documentation": {}
    },
    {
        "label": "mean",
        "importPath": "statistics",
        "description": "statistics",
        "isExtraImport": true,
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "difflib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "difflib",
        "description": "difflib",
        "detail": "difflib",
        "documentation": {}
    },
    {
        "label": "filecmp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "filecmp",
        "description": "filecmp",
        "detail": "filecmp",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "unicode_literals",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "ClosingFileHandler",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "ClosingFileHandler",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "ClosingFileHandler",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "TestData",
        "importPath": "util",
        "description": "util",
        "isExtraImport": true,
        "detail": "util",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "smb",
        "importPath": "impacket",
        "description": "impacket",
        "isExtraImport": true,
        "detail": "impacket",
        "documentation": {}
    },
    {
        "label": "smbserver",
        "importPath": "impacket",
        "description": "impacket",
        "isExtraImport": true,
        "detail": "impacket",
        "documentation": {}
    },
    {
        "label": "STATUS_ACCESS_DENIED",
        "importPath": "impacket.nt_errors",
        "description": "impacket.nt_errors",
        "isExtraImport": true,
        "detail": "impacket.nt_errors",
        "documentation": {}
    },
    {
        "label": "STATUS_NO_SUCH_FILE",
        "importPath": "impacket.nt_errors",
        "description": "impacket.nt_errors",
        "isExtraImport": true,
        "detail": "impacket.nt_errors",
        "documentation": {}
    },
    {
        "label": "STATUS_SUCCESS",
        "importPath": "impacket.nt_errors",
        "description": "impacket.nt_errors",
        "isExtraImport": true,
        "detail": "impacket.nt_errors",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "click",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "click",
        "description": "click",
        "detail": "click",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "shlex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shlex",
        "description": "shlex",
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "errno,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno.",
        "description": "errno.",
        "detail": "errno.",
        "documentation": {}
    },
    {
        "label": "build",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "build",
        "description": "build",
        "detail": "build",
        "documentation": {}
    },
    {
        "label": "datetime,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime.",
        "description": "datetime.",
        "detail": "datetime.",
        "documentation": {}
    },
    {
        "label": "re,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re.",
        "description": "re.",
        "detail": "re.",
        "documentation": {}
    },
    {
        "label": "LooseVersion",
        "importPath": "distutils.version",
        "description": "distutils.version",
        "isExtraImport": true,
        "detail": "distutils.version",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "gmock_test_utils",
        "importPath": "googlemock.test",
        "description": "googlemock.test",
        "isExtraImport": true,
        "detail": "googlemock.test",
        "documentation": {}
    },
    {
        "label": "gmock_test_utils",
        "importPath": "googlemock.test",
        "description": "googlemock.test",
        "isExtraImport": true,
        "detail": "googlemock.test",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "open",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_json_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_json_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_xml_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_xml_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "gtest_test_utils",
        "importPath": "googletest.test",
        "description": "googletest.test",
        "isExtraImport": true,
        "detail": "googletest.test",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "atexit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit",
        "description": "atexit",
        "detail": "atexit",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "minidom",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "minidom",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "minidom",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "xml.dom",
        "description": "xml.dom",
        "isExtraImport": true,
        "detail": "xml.dom",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "total_ordering",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "gzip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gzip",
        "description": "gzip",
        "detail": "gzip",
        "documentation": {}
    },
    {
        "label": "optparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "optparse",
        "description": "optparse",
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "HIGHEST_PROTOCOL",
        "importPath": "pickle",
        "description": "pickle",
        "isExtraImport": true,
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isdir",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "gtest_parallel",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gtest_parallel",
        "description": "gtest_parallel",
        "detail": "gtest_parallel",
        "documentation": {}
    },
    {
        "label": "LoggerMock",
        "importPath": "gtest_parallel_mocks",
        "description": "gtest_parallel_mocks",
        "isExtraImport": true,
        "detail": "gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "SubprocessMock",
        "importPath": "gtest_parallel_mocks",
        "description": "gtest_parallel_mocks",
        "isExtraImport": true,
        "detail": "gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TestTimesMock",
        "importPath": "gtest_parallel_mocks",
        "description": "gtest_parallel_mocks",
        "isExtraImport": true,
        "detail": "gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TestResultsMock",
        "importPath": "gtest_parallel_mocks",
        "description": "gtest_parallel_mocks",
        "isExtraImport": true,
        "detail": "gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TaskManagerMock",
        "importPath": "gtest_parallel_mocks",
        "description": "gtest_parallel_mocks",
        "isExtraImport": true,
        "detail": "gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TaskMockFactory",
        "importPath": "gtest_parallel_mocks",
        "description": "gtest_parallel_mocks",
        "isExtraImport": true,
        "detail": "gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TaskMock",
        "importPath": "gtest_parallel_mocks",
        "description": "gtest_parallel_mocks",
        "isExtraImport": true,
        "detail": "gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "pexpect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pexpect",
        "description": "pexpect",
        "detail": "pexpect",
        "documentation": {}
    },
    {
        "label": "codecs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "codecs",
        "description": "codecs",
        "detail": "codecs",
        "documentation": {}
    },
    {
        "label": "fnmatch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fnmatch",
        "description": "fnmatch",
        "detail": "fnmatch",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "system",
        "importPath": "platform",
        "description": "platform",
        "isExtraImport": true,
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "build",
        "importPath": "setuptools.command.build",
        "description": "setuptools.command.build",
        "isExtraImport": true,
        "detail": "setuptools.command.build",
        "documentation": {}
    },
    {
        "label": "bdist_wheel",
        "importPath": "wheel.bdist_wheel",
        "description": "wheel.bdist_wheel",
        "isExtraImport": true,
        "detail": "wheel.bdist_wheel",
        "documentation": {}
    },
    {
        "label": "xdelta3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xdelta3",
        "description": "xdelta3",
        "detail": "xdelta3",
        "documentation": {}
    },
    {
        "label": "BinaryReader",
        "importPath": "binary_reader",
        "description": "binary_reader",
        "isExtraImport": true,
        "detail": "binary_reader",
        "documentation": {}
    },
    {
        "label": "BinaryWriter",
        "importPath": "binary_writer",
        "description": "binary_writer",
        "isExtraImport": true,
        "detail": "binary_writer",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "zydis_encoder_types",
        "description": "zydis_encoder_types",
        "isExtraImport": true,
        "detail": "zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "crash_tool",
        "description": "crash_tool",
        "isExtraImport": true,
        "detail": "crash_tool",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntFlag",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": ".github.scripts.create-mod-release.bundle-linux",
        "description": ".github.scripts.create-mod-release.bundle-linux",
        "peekOfCode": "args = get_args(\"linux\")\nprint(args)\n# Create our output directory\ncreate_output_dir(args, \"linux\")\n# Download the Release\ndownload_release(args, \"linux\", is_zip=False)\n# Override any files\noverride_binaries_and_assets(args, \"linux\")\n# Replace placeholder text with mod version and timestamp\npatch_mod_timestamp_and_version_info(args, \"linux\")",
        "detail": ".github.scripts.create-mod-release.bundle-linux",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": ".github.scripts.create-mod-release.bundle-macos",
        "description": ".github.scripts.create-mod-release.bundle-macos",
        "peekOfCode": "args = get_args(\"macos-intel\")\nprint(args)\n# Create our output directory\ncreate_output_dir(args, \"macos-intel\")\n# Download the Release\ndownload_release(args, \"macos-intel\", is_zip=False)\n# Override any files\noverride_binaries_and_assets(args, \"macos-intel\")\n# Replace placeholder text with mod version and timestamp\npatch_mod_timestamp_and_version_info(args, \"macos-intel\")",
        "detail": ".github.scripts.create-mod-release.bundle-macos",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": ".github.scripts.create-mod-release.bundle-windows",
        "description": ".github.scripts.create-mod-release.bundle-windows",
        "peekOfCode": "args = get_args(\"windows\")\nprint(args)\n# Create our output directory\ncreate_output_dir(args, \"windows\")\n# Download or Build the Release\ndownload_release(args, \"windows\", is_zip=True)\n# Override any files\noverride_binaries_and_assets(args, \"windows\")\n# Replace placeholder text with mod version and timestamp\npatch_mod_timestamp_and_version_info(args, \"windows\")",
        "detail": ".github.scripts.create-mod-release.bundle-windows",
        "documentation": {}
    },
    {
        "label": "default_asset_prefix",
        "kind": 2,
        "importPath": ".github.scripts.create-mod-release.common",
        "description": ".github.scripts.create-mod-release.common",
        "peekOfCode": "def default_asset_prefix(platform):\n    if platform == \"windows\":\n        return \"opengoal-windows\"\n    elif platform == \"linux\":\n        return \"opengoal-linux\"\n    elif platform == \"macos-intel\":\n        return \"opengoal-macos-intel\"\n    elif platform == \"macos-arm\":\n        return \"opengoal-macos-arm\"\n    else:",
        "detail": ".github.scripts.create-mod-release.common",
        "documentation": {}
    },
    {
        "label": "get_args",
        "kind": 2,
        "importPath": ".github.scripts.create-mod-release.common",
        "description": ".github.scripts.create-mod-release.common",
        "peekOfCode": "def get_args(platform):\n    return {\n        \"outputDir\": os.getenv(\"outputDir\"),\n        \"versionName\": os.getenv(\"versionName\"),\n        \"toolingRepo\": os.getenv(\"toolingRepo\"),\n        \"toolingReleaseAssetPrefix\": os.getenv(\n            \"toolingReleaseAssetPrefix\", default_asset_prefix(platform)\n        ),\n        \"toolingVersion\": os.getenv(\"toolingVersion\")\n    }",
        "detail": ".github.scripts.create-mod-release.common",
        "documentation": {}
    },
    {
        "label": "create_output_dir",
        "kind": 2,
        "importPath": ".github.scripts.create-mod-release.common",
        "description": ".github.scripts.create-mod-release.common",
        "peekOfCode": "def create_output_dir(args, dir_name):\n    if os.path.exists(os.path.join(args[\"outputDir\"], dir_name)):\n        print(\n            \"Expected output directory already exists, clearing it - {}\".format(\n                os.path.join(args[\"outputDir\"], dir_name)\n            )\n        )\n        os.rmdir(os.path.join(args[\"outputDir\"], dir_name))\n    os.makedirs(os.path.join(args[\"outputDir\"], dir_name), exist_ok=True)\ndef download_release(args, out_folder, is_zip=True):",
        "detail": ".github.scripts.create-mod-release.common",
        "documentation": {}
    },
    {
        "label": "download_release",
        "kind": 2,
        "importPath": ".github.scripts.create-mod-release.common",
        "description": ".github.scripts.create-mod-release.common",
        "peekOfCode": "def download_release(args, out_folder, is_zip=True):\n    toolingRepo = args[\"toolingRepo\"]\n    tooling_version = args[\"toolingVersion\"]\n    if tooling_version == \"latest\":\n        # Get the latest release\n        with urllib.request.urlopen(\n            f\"https://api.github.com/repos/{toolingRepo}/releases/latest\"\n        ) as response:\n            data = json.loads(response.read().decode())\n            tooling_version = data[\"tag_name\"]",
        "detail": ".github.scripts.create-mod-release.common",
        "documentation": {}
    },
    {
        "label": "override_binaries_and_assets",
        "kind": 2,
        "importPath": ".github.scripts.create-mod-release.common",
        "description": ".github.scripts.create-mod-release.common",
        "peekOfCode": "def override_binaries_and_assets(args, out_folder):\n    # Copy-in Mod Assets\n    customAssetsDir = \"./custom_assets\"\n    if os.path.exists(customAssetsDir):\n        shutil.copytree(\n            customAssetsDir,\n            os.path.join(args[\"outputDir\"], out_folder, \"data\", \"custom_assets\"),\n            dirs_exist_ok=True,\n        )\n    goalSourceDir = \"./goal_src\"",
        "detail": ".github.scripts.create-mod-release.common",
        "documentation": {}
    },
    {
        "label": "patch_mod_timestamp_and_version_info",
        "kind": 2,
        "importPath": ".github.scripts.create-mod-release.common",
        "description": ".github.scripts.create-mod-release.common",
        "peekOfCode": "def patch_mod_timestamp_and_version_info(args, out_folder):\n    try:\n        mod_settings_files = glob.glob(f\"{args['outputDir']}/{out_folder}/data/goal_src/**/mod-settings.gc\", recursive=True)\n        for settings_file_path in mod_settings_files:\n            file = open(settings_file_path, \"r\")\n            file_data = file.read()\n            file.close()\n            # Check if the placeholder string is present in the file\n            if \"%MODVERSIONPLACEHOLDER%\" in file_data:\n                # Replace the placeholder string with the version and date string",
        "detail": ".github.scripts.create-mod-release.common",
        "documentation": {}
    },
    {
        "label": "finalize_bundle",
        "kind": 2,
        "importPath": ".github.scripts.create-mod-release.common",
        "description": ".github.scripts.create-mod-release.common",
        "peekOfCode": "def finalize_bundle(args, out_folder, is_zip=True):\n    if is_zip:\n        shutil.make_archive(\n            f\"{out_folder}-{args['versionName']}\",\n            \"zip\",\n            os.path.join(args[\"outputDir\"], out_folder),\n        )\n        os.makedirs(os.path.join(args[\"outputDir\"], \"dist\"), exist_ok=True)\n        shutil.move(\n            f\"{out_folder}-{args['versionName']}.zip\",",
        "detail": ".github.scripts.create-mod-release.common",
        "documentation": {}
    },
    {
        "label": "split_comma_sep_val",
        "kind": 2,
        "importPath": ".github.scripts.create-mod-release.emit-metadata",
        "description": ".github.scripts.create-mod-release.emit-metadata",
        "peekOfCode": "def split_comma_sep_val(str):\n    if \",\" not in str:\n        return [str]\n    return str.split(\",\")\n# Validate supported games list\ngames = split_comma_sep_val(os.getenv(\"SUPPORTED_GAMES\"))\nif len(games) == 0:\n    print(\"SUPPORTED_GAMES list is empty\")\n    exit(1)\nfor game in games:",
        "detail": ".github.scripts.create-mod-release.emit-metadata",
        "documentation": {}
    },
    {
        "label": "games",
        "kind": 5,
        "importPath": ".github.scripts.create-mod-release.emit-metadata",
        "description": ".github.scripts.create-mod-release.emit-metadata",
        "peekOfCode": "games = split_comma_sep_val(os.getenv(\"SUPPORTED_GAMES\"))\nif len(games) == 0:\n    print(\"SUPPORTED_GAMES list is empty\")\n    exit(1)\nfor game in games:\n    if game != \"jak1\" and game != \"jak2\" and game != \"jak3\" and game != \"jakx\":\n        print(\"SUPPORTED_GAMES contains invalid game: \", game)\n        exit(1)\n# Input has been validated, create metadata.json\nmetadata = {",
        "detail": ".github.scripts.create-mod-release.emit-metadata",
        "documentation": {}
    },
    {
        "label": "metadata",
        "kind": 5,
        "importPath": ".github.scripts.create-mod-release.emit-metadata",
        "description": ".github.scripts.create-mod-release.emit-metadata",
        "peekOfCode": "metadata = {\n    \"schemaVersion\": os.getenv(\"SCHEMA_VERSION\"),\n    \"version\": os.getenv(\"VERSION\").removeprefix(\"v\"),\n    \"supportedGames\": games,\n    \"publishedDate\": datetime.now().isoformat(),\n}\nwith open(\"{}/metadata.json\".format(os.getenv(\"OUT_DIR\")), \"w\", encoding=\"utf-8\") as f:\n    print(\n        \"Writing the following metadata: {}\".format(\n            json.dumps(metadata, indent=2, ensure_ascii=False)",
        "detail": ".github.scripts.create-mod-release.emit-metadata",
        "documentation": {}
    },
    {
        "label": "patch_mod_timestamp",
        "kind": 2,
        "importPath": ".github.scripts.releases.replace-mod-version-timestamp",
        "description": ".github.scripts.releases.replace-mod-version-timestamp",
        "peekOfCode": "def patch_mod_timestamp(goal_src_path):\n    try:\n        mod_settings_files = glob.glob(f\"{goal_src_path}/**/mod-settings.gc\", recursive=True)\n        for settings_file_path in mod_settings_files:\n            file = open(settings_file_path, \"r\")\n            file_data = file.read()\n            file.close()\n            # Check if the placeholder string is present in the file\n            if \"%MODVERSIONPLACEHOLDER%\" in file_data:\n                # Replace the placeholder string with the version and date string",
        "detail": ".github.scripts.releases.replace-mod-version-timestamp",
        "documentation": {}
    },
    {
        "label": "extract_primitives",
        "kind": 2,
        "importPath": "custom_assets.blender_plugins.gltf2_blender_extract",
        "description": "custom_assets.blender_plugins.gltf2_blender_extract",
        "peekOfCode": "def extract_primitives(blender_mesh, uuid_for_skined_data, blender_vertex_groups, modifiers, export_settings):\n    \"\"\"Extract primitives from a mesh.\"\"\"\n    print_console('INFO', 'Extracting primitive: ' + blender_mesh.name)\n    blender_object = None\n    if uuid_for_skined_data:\n        blender_object = export_settings['vtree'].nodes[uuid_for_skined_data].blender_object\n    use_normals = export_settings[gltf2_blender_export_keys.NORMALS]\n    if use_normals:\n        blender_mesh.calc_normals_split()\n    use_tangents = False",
        "detail": "custom_assets.blender_plugins.gltf2_blender_extract",
        "documentation": {}
    },
    {
        "label": "draw_func",
        "kind": 2,
        "importPath": "custom_assets.blender_plugins.opengoal",
        "description": "custom_assets.blender_plugins.opengoal",
        "peekOfCode": "def draw_func(self, context):\n    layout = self.layout\n    ob = context.object\n    layout.prop(ob.active_material, \"set_invisible\")\n    layout.prop(ob.active_material, \"set_collision\")\n    if (ob.active_material.set_collision):\n        layout.prop(ob.active_material, \"ignore\")\n        layout.prop(ob.active_material, \"collide_mode\")\n        layout.prop(ob.active_material, \"collide_material\")\n        layout.prop(ob.active_material, \"collide_event\")",
        "detail": "custom_assets.blender_plugins.opengoal",
        "documentation": {}
    },
    {
        "label": "draw_func_ob",
        "kind": 2,
        "importPath": "custom_assets.blender_plugins.opengoal",
        "description": "custom_assets.blender_plugins.opengoal",
        "peekOfCode": "def draw_func_ob(self, context):\n    layout = self.layout\n    ob = context.object\n    layout.prop(ob, \"set_invisible\")\n    layout.prop(ob, \"enable_custom_weights\")\n    layout.prop(ob, \"copy_eye_draws\")\n    layout.prop(ob, \"copy_mod_draws\")\n    layout.prop(ob, \"set_collision\")\n    if (ob.set_collision):\n        layout.prop(ob, \"ignore\")",
        "detail": "custom_assets.blender_plugins.opengoal",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "custom_assets.blender_plugins.opengoal",
        "description": "custom_assets.blender_plugins.opengoal",
        "peekOfCode": "def register():\n    bpy.types.Material.set_invisible = bpy.props.BoolProperty(name=\"Invisible\")\n    bpy.types.Material.set_collision = bpy.props.BoolProperty(name=\"Apply Collision Properties\")\n    bpy.types.Material.ignore = bpy.props.BoolProperty(name=\"ignore\")\n    bpy.types.Material.noedge = bpy.props.BoolProperty(name=\"No-Edge\")\n    bpy.types.Material.noentity = bpy.props.BoolProperty(name=\"No-Entity\")\n    bpy.types.Material.nolineofsight = bpy.props.BoolProperty(name=\"No-LOS\")\n    bpy.types.Material.nocamera = bpy.props.BoolProperty(name=\"No-Camera\")\n    bpy.types.Material.collide_material = bpy.props.EnumProperty(items = pat_surfaces, name = \"Material\")\n    bpy.types.Material.collide_event = bpy.props.EnumProperty(items = pat_events, name = \"Event\")",
        "detail": "custom_assets.blender_plugins.opengoal",
        "documentation": {}
    },
    {
        "label": "unregister",
        "kind": 2,
        "importPath": "custom_assets.blender_plugins.opengoal",
        "description": "custom_assets.blender_plugins.opengoal",
        "peekOfCode": "def unregister():\n    bpy.types.MATERIAL_PT_custom_props.remove(draw_func)\nif __name__ == \"__main__\":\n    register()",
        "detail": "custom_assets.blender_plugins.opengoal",
        "documentation": {}
    },
    {
        "label": "bl_info",
        "kind": 5,
        "importPath": "custom_assets.blender_plugins.opengoal",
        "description": "custom_assets.blender_plugins.opengoal",
        "peekOfCode": "bl_info = {\n    \"name\": \"OpenGOAL Mesh\",\n    \"author\": \"water111\",\n    \"version\": (0, 0, 3),\n    \"blender\": (2, 83, 0),\n    \"location\": \"3D View\",\n    \"description\": \"OpenGOAL Mesh tools\",\n    \"category\": \"Development\"\n}\nimport bpy",
        "detail": "custom_assets.blender_plugins.opengoal",
        "documentation": {}
    },
    {
        "label": "pat_surfaces",
        "kind": 5,
        "importPath": "custom_assets.blender_plugins.opengoal",
        "description": "custom_assets.blender_plugins.opengoal",
        "peekOfCode": "pat_surfaces = [\n  (\"stone\", \"stone\", \"\", 0),\n  (\"ice\", \"ice\", \"\", 1),\n  (\"quicksand\", \"quicksand\", \"\", 2),\n  (\"waterbottom\", \"waterbottom\", \"\", 3),\n  (\"tar\", \"tar\", \"\", 4),\n  (\"sand\", \"sand\", \"\", 5),\n  (\"wood\", \"wood\", \"\", 6),\n  (\"grass\", \"grass\", \"\", 7),\n  (\"pcmetal\", \"pcmetal\", \"\", 8),",
        "detail": "custom_assets.blender_plugins.opengoal",
        "documentation": {}
    },
    {
        "label": "pat_events",
        "kind": 5,
        "importPath": "custom_assets.blender_plugins.opengoal",
        "description": "custom_assets.blender_plugins.opengoal",
        "peekOfCode": "pat_events = [\n  (\"none\", \"none\", \"\", 0),\n  (\"deadly\", \"deadly\", \"\", 1),\n  (\"endlessfall\", \"endlessfall\", \"\", 2),\n  (\"burn\", \"burn\", \"\", 3),\n  (\"deadlyup\", \"deadlyup\", \"\", 4),\n  (\"burnup\", \"burnup\", \"\", 5),\n  (\"melt\", \"melt\", \"\", 6),\n]\npat_modes = [",
        "detail": "custom_assets.blender_plugins.opengoal",
        "documentation": {}
    },
    {
        "label": "pat_modes",
        "kind": 5,
        "importPath": "custom_assets.blender_plugins.opengoal",
        "description": "custom_assets.blender_plugins.opengoal",
        "peekOfCode": "pat_modes = [\n  (\"ground\", \"ground\", \"\", 0),\n  (\"wall\", \"wall\", \"\", 1),\n  (\"obstacle\", \"obstacle\", \"\", 2),\n]\ndef draw_func(self, context):\n    layout = self.layout\n    ob = context.object\n    layout.prop(ob.active_material, \"set_invisible\")\n    layout.prop(ob.active_material, \"set_collision\")",
        "detail": "custom_assets.blender_plugins.opengoal",
        "documentation": {}
    },
    {
        "label": "replace_object_model",
        "kind": 2,
        "importPath": "custom_assets.blender positions to json",
        "description": "custom_assets.blender positions to json",
        "peekOfCode": "def replace_object_model(obj, glb_filename, new_collection):\n    # Store object properties\n    obj_name = obj.name\n    obj_location = obj.location.copy()\n    # Remove the old object\n    bpy.data.objects.remove(obj, do_unlink=True)\n    # Create a new object with the glb model\n    bpy.ops.import_scene.gltf(filepath=os.path.join(glb_model_path, glb_filename))\n    new_obj = bpy.context.selected_objects[0]\n    # Set properties of the new object based on the old object",
        "detail": "custom_assets.blender positions to json",
        "documentation": {}
    },
    {
        "label": "collection",
        "kind": 5,
        "importPath": "custom_assets.blender positions to json",
        "description": "custom_assets.blender positions to json",
        "peekOfCode": "collection = bpy.data.collections.get(\"Cell Collection\")\nprint(r\"// Start automatic actors from blender\")\nprint()\n# Check if the collection exists\nif collection is None:\n    print(r\"//Cell Collection not found\")\n    print()\nelse:\n    # Create a list to store the positions of all objects in the collection\n    positions = []",
        "detail": "custom_assets.blender positions to json",
        "documentation": {}
    },
    {
        "label": "collection",
        "kind": 5,
        "importPath": "custom_assets.blender positions to json",
        "description": "custom_assets.blender positions to json",
        "peekOfCode": "collection = bpy.data.collections.get(\"Orb Collection\")\n# Check if the collection exists\nif collection is None:\n    print(r\"//Orb Collection not found\")\n    print()\nelse:\n    # Create a list to store the positions of all objects in the collection\n    positions = []\n    # Get the name of the blend file without the extension\n    blend_file_name = bpy.path.display_name_from_filepath(bpy.data.filepath).replace(\" \", \"-\")",
        "detail": "custom_assets.blender positions to json",
        "documentation": {}
    },
    {
        "label": "collection",
        "kind": 5,
        "importPath": "custom_assets.blender positions to json",
        "description": "custom_assets.blender positions to json",
        "peekOfCode": "collection = bpy.data.collections.get(\"Crate Collection\")\n# Check if the collection exists\nif collection is None:\n    print(r\"//Crate Collection not found\")\n    print()\nelse:\n    # Create a list to store the positions of all objects in the collection\n    positions = []\n    # Get the name of the blend file without the extension\n    blend_file_name = bpy.path.display_name_from_filepath(bpy.data.filepath).replace(\" \", \"-\")",
        "detail": "custom_assets.blender positions to json",
        "documentation": {}
    },
    {
        "label": "glb_model_path",
        "kind": 5,
        "importPath": "custom_assets.blender positions to json",
        "description": "custom_assets.blender positions to json",
        "peekOfCode": "glb_model_path = r\"C:\\Users\\NinjaPC\\AppData\\Roaming\\Blender Foundation\\Blender\\3.2\\scripts\\addons\\OpenMaya\\actorsa\"\n# Define the mapping of etype to glb model filenames\nmodel_mapping = {\n    \"fuel-cell\": \"fuel.glb\",\n    \"money\": \"money.glb\",\n    \"crate\": \"crate-wood.glb\",\n}\n# Function to replace the model of an object while preserving its properties\ndef replace_object_model(obj, glb_filename, new_collection):\n    # Store object properties",
        "detail": "custom_assets.blender positions to json",
        "documentation": {}
    },
    {
        "label": "model_mapping",
        "kind": 5,
        "importPath": "custom_assets.blender positions to json",
        "description": "custom_assets.blender positions to json",
        "peekOfCode": "model_mapping = {\n    \"fuel-cell\": \"fuel.glb\",\n    \"money\": \"money.glb\",\n    \"crate\": \"crate-wood.glb\",\n}\n# Function to replace the model of an object while preserving its properties\ndef replace_object_model(obj, glb_filename, new_collection):\n    # Store object properties\n    obj_name = obj.name\n    obj_location = obj.location.copy()",
        "detail": "custom_assets.blender positions to json",
        "documentation": {}
    },
    {
        "label": "cell_collection",
        "kind": 5,
        "importPath": "custom_assets.blender positions to json",
        "description": "custom_assets.blender positions to json",
        "peekOfCode": "cell_collection = bpy.data.collections.get(\"Cell Collection\")\nif cell_collection:\n    objects_to_replace = list(cell_collection.objects)\n    for obj in objects_to_replace:\n        glb_filename = model_mapping[\"fuel-cell\"]\n        replace_object_model(obj, glb_filename, cell_collection)\n# Orbs\norb_collection = bpy.data.collections.get(\"Orb Collection\")\nif orb_collection:\n    for obj in list(orb_collection.objects):  # Iterate through a copy of the objects",
        "detail": "custom_assets.blender positions to json",
        "documentation": {}
    },
    {
        "label": "orb_collection",
        "kind": 5,
        "importPath": "custom_assets.blender positions to json",
        "description": "custom_assets.blender positions to json",
        "peekOfCode": "orb_collection = bpy.data.collections.get(\"Orb Collection\")\nif orb_collection:\n    for obj in list(orb_collection.objects):  # Iterate through a copy of the objects\n        glb_filename = model_mapping[\"money\"]\n        replace_object_model(obj, glb_filename, orb_collection)\n# Crates\ncrate_collection = bpy.data.collections.get(\"Crate Collection\")\nif crate_collection:\n    for obj in crate_collection.objects:\n        etype = obj.get(\"etype\")",
        "detail": "custom_assets.blender positions to json",
        "documentation": {}
    },
    {
        "label": "crate_collection",
        "kind": 5,
        "importPath": "custom_assets.blender positions to json",
        "description": "custom_assets.blender positions to json",
        "peekOfCode": "crate_collection = bpy.data.collections.get(\"Crate Collection\")\nif crate_collection:\n    for obj in crate_collection.objects:\n        etype = obj.get(\"etype\")\n        if etype in model_mapping:\n            glb_filename = model_mapping[etype]\n            replace_object_model(obj, glb_filename, crate_collection)",
        "detail": "custom_assets.blender positions to json",
        "documentation": {}
    },
    {
        "label": "ObjFile",
        "kind": 6,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "class ObjFile():\n\tdef __init__(self, obj):\n\t\t\"\"\"\n\t\tConvert the json data in obj.txt.\n\t\tIf the format changes or we add new fields, they should be added here.\n\t\t\"\"\"\n\t\tself.unique_name = obj[0] # The unique name that's used by the decompiler.\n\t\tself.name_in_dgo = obj[1] # Name in the game.\n\t\tself.version = obj[2]     # GOAL object file format version\n\tdef get_description(self):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "DgoFile",
        "kind": 6,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "class DgoFile():\n\tdef __init__(self):\n\t\tself.obj_files = dict() \n\tdef add_obj(self, obj):\n\t\tself.obj_files[obj[0]] = ObjFile(obj)\n# Hold all DGOs/Object files.\nclass FileMap():\n\tdef __init__(self):\n\t\tself.dgo_files = dict()\n\t\tself.all_objs = dict()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "FileMap",
        "kind": 6,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "class FileMap():\n\tdef __init__(self):\n\t\tself.dgo_files = dict()\n\t\tself.all_objs = dict()\n\tdef add_obj_to_dgo(self, dgo, obj):\n\t\tif not(dgo in self.dgo_files):\n\t\t\tself.dgo_files[dgo] = DgoFile()\n\t\tself.dgo_files[dgo].add_obj(obj)\n\t\tself.all_objs[obj[0]] = ObjFile(obj)\n\tdef get_objs_matching_regex(self, regex):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "ObjectFileView",
        "kind": 6,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "class ObjectFileView(QDialog):\n\tdef __init__(self, name):\n\t\tsuper().__init__()\n\t\tself.setWindowTitle(name)\n\t\twith open(os.path.join(get_jak_path(), \"decompiler_out\", \"{}_asm.json\".format(name))) as f:\n\t\t\tself.asm_data = json.loads(f.read())\n\t\tmain_layout = QVBoxLayout()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tself.header_label = QLabel()\n\t\tmain_layout.addWidget(self.header_label)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "ObjectFileBrowser",
        "kind": 6,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "class ObjectFileBrowser(QMainWindow):\n\tdef __init__(self, obj_map):\n\t\tself.obj_map = obj_map\n\t\tsuper().__init__()\n\t\tself.setWindowTitle(\"Object File Browser\")\n\t\tself.childen_windows = []\n\t\tlayout = QVBoxLayout()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tlayout.addWidget(QLabel(\"Browse object files by dgo...\"))\n\t\t# Set up the tree view",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "get_monospaced_font",
        "kind": 2,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "def get_monospaced_font():\n\t\"\"\"\n\tGet a monospaced font. Should work on both windows and linux.\n\t\"\"\"\n\tfont = QFont(\"monospace\")\n\tfont.setStyleHint(QFont.TypeWriter)\n\treturn font\ndef get_jak_path():\n\t\"\"\"\n\tGet a path to jak-project/",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "get_jak_path",
        "kind": 2,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "def get_jak_path():\n\t\"\"\"\n\tGet a path to jak-project/\n\t\"\"\"\n\treturn os.path.join(os.path.dirname(os.path.realpath(__file__)), \"..\", \"..\")\ndef segment_id_to_name(sid):\n\t\"\"\"\n\tGOAL segment ID to name string\n\t\"\"\"\n\tif sid == 0:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "segment_id_to_name",
        "kind": 2,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "def segment_id_to_name(sid):\n\t\"\"\"\n\tGOAL segment ID to name string\n\t\"\"\"\n\tif sid == 0:\n\t\treturn \"main\"\n\telif sid == 1:\n\t\treturn \"debug\"\n\telif sid == 2:\n\t\treturn \"top-level\"",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "load_obj_map_file",
        "kind": 2,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "def load_obj_map_file(file_path):\n\t\"\"\"\n\tLoad the obj.txt file generated by the decompiler.\n\tReturn a FileMap.\n\t\"\"\"\n\tfile_map = FileMap()\n\twith open(file_path) as f:\n\t\tjson_data = json.loads(f.read())\n\tfor obj_file in json_data:\n\t\tfor dgo in obj_file[3]:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\tfont",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\tfont = QFont(\"monospace\")\n\tfont.setStyleHint(QFont.TypeWriter)\n\treturn font\ndef get_jak_path():\n\t\"\"\"\n\tGet a path to jak-project/\n\t\"\"\"\n\treturn os.path.join(os.path.dirname(os.path.realpath(__file__)), \"..\", \"..\")\ndef segment_id_to_name(sid):\n\t\"\"\"",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.unique_name",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.unique_name = obj[0] # The unique name that's used by the decompiler.\n\t\tself.name_in_dgo = obj[1] # Name in the game.\n\t\tself.version = obj[2]     # GOAL object file format version\n\tdef get_description(self):\n\t\treturn \"Name: {}\\n  Version: {}\\n  Name in game: {}\".format(self.unique_name, self.version, self.name_in_dgo)\n# Hold all of the object files in a dgo.\nclass DgoFile():\n\tdef __init__(self):\n\t\tself.obj_files = dict() \n\tdef add_obj(self, obj):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.name_in_dgo",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.name_in_dgo = obj[1] # Name in the game.\n\t\tself.version = obj[2]     # GOAL object file format version\n\tdef get_description(self):\n\t\treturn \"Name: {}\\n  Version: {}\\n  Name in game: {}\".format(self.unique_name, self.version, self.name_in_dgo)\n# Hold all of the object files in a dgo.\nclass DgoFile():\n\tdef __init__(self):\n\t\tself.obj_files = dict() \n\tdef add_obj(self, obj):\n\t\tself.obj_files[obj[0]] = ObjFile(obj)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.version",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.version = obj[2]     # GOAL object file format version\n\tdef get_description(self):\n\t\treturn \"Name: {}\\n  Version: {}\\n  Name in game: {}\".format(self.unique_name, self.version, self.name_in_dgo)\n# Hold all of the object files in a dgo.\nclass DgoFile():\n\tdef __init__(self):\n\t\tself.obj_files = dict() \n\tdef add_obj(self, obj):\n\t\tself.obj_files[obj[0]] = ObjFile(obj)\n# Hold all DGOs/Object files.",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.obj_files",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.obj_files = dict() \n\tdef add_obj(self, obj):\n\t\tself.obj_files[obj[0]] = ObjFile(obj)\n# Hold all DGOs/Object files.\nclass FileMap():\n\tdef __init__(self):\n\t\tself.dgo_files = dict()\n\t\tself.all_objs = dict()\n\tdef add_obj_to_dgo(self, dgo, obj):\n\t\tif not(dgo in self.dgo_files):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.obj_files[obj[0]]",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.obj_files[obj[0]] = ObjFile(obj)\n# Hold all DGOs/Object files.\nclass FileMap():\n\tdef __init__(self):\n\t\tself.dgo_files = dict()\n\t\tself.all_objs = dict()\n\tdef add_obj_to_dgo(self, dgo, obj):\n\t\tif not(dgo in self.dgo_files):\n\t\t\tself.dgo_files[dgo] = DgoFile()\n\t\tself.dgo_files[dgo].add_obj(obj)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.dgo_files",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.dgo_files = dict()\n\t\tself.all_objs = dict()\n\tdef add_obj_to_dgo(self, dgo, obj):\n\t\tif not(dgo in self.dgo_files):\n\t\t\tself.dgo_files[dgo] = DgoFile()\n\t\tself.dgo_files[dgo].add_obj(obj)\n\t\tself.all_objs[obj[0]] = ObjFile(obj)\n\tdef get_objs_matching_regex(self, regex):\n\t\t\"\"\"\n\t\tGet a list of object files with a name that matches the given regex.",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.all_objs",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.all_objs = dict()\n\tdef add_obj_to_dgo(self, dgo, obj):\n\t\tif not(dgo in self.dgo_files):\n\t\t\tself.dgo_files[dgo] = DgoFile()\n\t\tself.dgo_files[dgo].add_obj(obj)\n\t\tself.all_objs[obj[0]] = ObjFile(obj)\n\tdef get_objs_matching_regex(self, regex):\n\t\t\"\"\"\n\t\tGet a list of object files with a name that matches the given regex.\n\t\t\"\"\"",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.dgo_files[dgo]",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\tself.dgo_files[dgo] = DgoFile()\n\t\tself.dgo_files[dgo].add_obj(obj)\n\t\tself.all_objs[obj[0]] = ObjFile(obj)\n\tdef get_objs_matching_regex(self, regex):\n\t\t\"\"\"\n\t\tGet a list of object files with a name that matches the given regex.\n\t\t\"\"\"\n\t\ttry:\n\t\t\tr = re.compile(regex)\n\t\texcept:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.all_objs[obj[0]]",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.all_objs[obj[0]] = ObjFile(obj)\n\tdef get_objs_matching_regex(self, regex):\n\t\t\"\"\"\n\t\tGet a list of object files with a name that matches the given regex.\n\t\t\"\"\"\n\t\ttry:\n\t\t\tr = re.compile(regex)\n\t\texcept:\n\t\t\treturn []\n\t\treturn list(filter(r.match, self.all_objs.keys()))",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\tr",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\tr = re.compile(regex)\n\t\texcept:\n\t\t\treturn []\n\t\treturn list(filter(r.match, self.all_objs.keys()))\ndef load_obj_map_file(file_path):\n\t\"\"\"\n\tLoad the obj.txt file generated by the decompiler.\n\tReturn a FileMap.\n\t\"\"\"\n\tfile_map = FileMap()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\tfile_map",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\tfile_map = FileMap()\n\twith open(file_path) as f:\n\t\tjson_data = json.loads(f.read())\n\tfor obj_file in json_data:\n\t\tfor dgo in obj_file[3]:\n\t\t\tfile_map.add_obj_to_dgo(dgo, obj_file)\n\treturn file_map\nclass ObjectFileView(QDialog):\n\tdef __init__(self, name):\n\t\tsuper().__init__()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tjson_data",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tjson_data = json.loads(f.read())\n\tfor obj_file in json_data:\n\t\tfor dgo in obj_file[3]:\n\t\t\tfile_map.add_obj_to_dgo(dgo, obj_file)\n\treturn file_map\nclass ObjectFileView(QDialog):\n\tdef __init__(self, name):\n\t\tsuper().__init__()\n\t\tself.setWindowTitle(name)\n\t\twith open(os.path.join(get_jak_path(), \"decompiler_out\", \"{}_asm.json\".format(name))) as f:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.asm_data",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\tself.asm_data = json.loads(f.read())\n\t\tmain_layout = QVBoxLayout()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tself.header_label = QLabel()\n\t\tmain_layout.addWidget(self.header_label)\n\t\tfunction_splitter = QSplitter()\n\t\tfunction_splitter.setSizePolicy(QSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding))\n\t\tself.function_list = QTreeView()\n\t\tself.function_list_model = QStandardItemModel()\n\t\tself.functions_by_name = dict()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tmain_layout",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tmain_layout = QVBoxLayout()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tself.header_label = QLabel()\n\t\tmain_layout.addWidget(self.header_label)\n\t\tfunction_splitter = QSplitter()\n\t\tfunction_splitter.setSizePolicy(QSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding))\n\t\tself.function_list = QTreeView()\n\t\tself.function_list_model = QStandardItemModel()\n\t\tself.functions_by_name = dict()\n\t\troot = self.function_list_model.invisibleRootItem()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tmonospaced_font",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tmonospaced_font = get_monospaced_font()\n\t\tself.header_label = QLabel()\n\t\tmain_layout.addWidget(self.header_label)\n\t\tfunction_splitter = QSplitter()\n\t\tfunction_splitter.setSizePolicy(QSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding))\n\t\tself.function_list = QTreeView()\n\t\tself.function_list_model = QStandardItemModel()\n\t\tself.functions_by_name = dict()\n\t\troot = self.function_list_model.invisibleRootItem()\n\t\tseg_roots = []",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.header_label",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.header_label = QLabel()\n\t\tmain_layout.addWidget(self.header_label)\n\t\tfunction_splitter = QSplitter()\n\t\tfunction_splitter.setSizePolicy(QSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding))\n\t\tself.function_list = QTreeView()\n\t\tself.function_list_model = QStandardItemModel()\n\t\tself.functions_by_name = dict()\n\t\troot = self.function_list_model.invisibleRootItem()\n\t\tseg_roots = []\n\t\tfor i in range(3):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tfunction_splitter",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tfunction_splitter = QSplitter()\n\t\tfunction_splitter.setSizePolicy(QSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding))\n\t\tself.function_list = QTreeView()\n\t\tself.function_list_model = QStandardItemModel()\n\t\tself.functions_by_name = dict()\n\t\troot = self.function_list_model.invisibleRootItem()\n\t\tseg_roots = []\n\t\tfor i in range(3):\n\t\t\tseg_entry = QStandardItem(segment_id_to_name(i))\n\t\t\tseg_entry.setFont(monospaced_font)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.function_list",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.function_list = QTreeView()\n\t\tself.function_list_model = QStandardItemModel()\n\t\tself.functions_by_name = dict()\n\t\troot = self.function_list_model.invisibleRootItem()\n\t\tseg_roots = []\n\t\tfor i in range(3):\n\t\t\tseg_entry = QStandardItem(segment_id_to_name(i))\n\t\t\tseg_entry.setFont(monospaced_font)\n\t\t\tseg_entry.setEditable(False)\n\t\t\troot.appendRow(seg_entry)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.function_list_model",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.function_list_model = QStandardItemModel()\n\t\tself.functions_by_name = dict()\n\t\troot = self.function_list_model.invisibleRootItem()\n\t\tseg_roots = []\n\t\tfor i in range(3):\n\t\t\tseg_entry = QStandardItem(segment_id_to_name(i))\n\t\t\tseg_entry.setFont(monospaced_font)\n\t\t\tseg_entry.setEditable(False)\n\t\t\troot.appendRow(seg_entry)\n\t\t\tseg_roots.append(seg_entry)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.functions_by_name",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.functions_by_name = dict()\n\t\troot = self.function_list_model.invisibleRootItem()\n\t\tseg_roots = []\n\t\tfor i in range(3):\n\t\t\tseg_entry = QStandardItem(segment_id_to_name(i))\n\t\t\tseg_entry.setFont(monospaced_font)\n\t\t\tseg_entry.setEditable(False)\n\t\t\troot.appendRow(seg_entry)\n\t\t\tseg_roots.append(seg_entry)\n\t\tfor f in self.asm_data[\"functions\"]:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\troot",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\troot = self.function_list_model.invisibleRootItem()\n\t\tseg_roots = []\n\t\tfor i in range(3):\n\t\t\tseg_entry = QStandardItem(segment_id_to_name(i))\n\t\t\tseg_entry.setFont(monospaced_font)\n\t\t\tseg_entry.setEditable(False)\n\t\t\troot.appendRow(seg_entry)\n\t\t\tseg_roots.append(seg_entry)\n\t\tfor f in self.asm_data[\"functions\"]:\n\t\t\tfunction_entry = QStandardItem(f[\"name\"])",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tseg_roots",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tseg_roots = []\n\t\tfor i in range(3):\n\t\t\tseg_entry = QStandardItem(segment_id_to_name(i))\n\t\t\tseg_entry.setFont(monospaced_font)\n\t\t\tseg_entry.setEditable(False)\n\t\t\troot.appendRow(seg_entry)\n\t\t\tseg_roots.append(seg_entry)\n\t\tfor f in self.asm_data[\"functions\"]:\n\t\t\tfunction_entry = QStandardItem(f[\"name\"])\n\t\t\tfunction_entry.setFont(monospaced_font)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\tseg_entry",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\tseg_entry = QStandardItem(segment_id_to_name(i))\n\t\t\tseg_entry.setFont(monospaced_font)\n\t\t\tseg_entry.setEditable(False)\n\t\t\troot.appendRow(seg_entry)\n\t\t\tseg_roots.append(seg_entry)\n\t\tfor f in self.asm_data[\"functions\"]:\n\t\t\tfunction_entry = QStandardItem(f[\"name\"])\n\t\t\tfunction_entry.setFont(monospaced_font)\n\t\t\tfunction_entry.setEditable(False)\n\t\t\tseg_roots[f[\"segment\"]].appendRow(function_entry)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\tfunction_entry",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\tfunction_entry = QStandardItem(f[\"name\"])\n\t\t\tfunction_entry.setFont(monospaced_font)\n\t\t\tfunction_entry.setEditable(False)\n\t\t\tseg_roots[f[\"segment\"]].appendRow(function_entry)\n\t\t\tself.functions_by_name[f[\"name\"]] = f\n\t\tself.header_label.setText(\"Object File {} Functions ({} total):\".format(name, len(self.asm_data[\"functions\"])))\n\t\tself.function_list.setModel(self.function_list_model)\n\t\tself.function_list.clicked.connect(self.display_function)\n\t\tfunction_splitter.addWidget(self.function_list)\n\t\tlayout = QVBoxLayout()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\tself.functions_by_name[f[\"name\"]]",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\tself.functions_by_name[f[\"name\"]] = f\n\t\tself.header_label.setText(\"Object File {} Functions ({} total):\".format(name, len(self.asm_data[\"functions\"])))\n\t\tself.function_list.setModel(self.function_list_model)\n\t\tself.function_list.clicked.connect(self.display_function)\n\t\tfunction_splitter.addWidget(self.function_list)\n\t\tlayout = QVBoxLayout()\n\t\tself.function_header_label = QLabel(\"No function selected\")\n\t\tself.function_header_label.setFont(monospaced_font)\n\t\tself.header_label.setSizePolicy(QSizePolicy(QSizePolicy.Minimum,\n                                                 QSizePolicy.Minimum))",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tlayout",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tlayout = QVBoxLayout()\n\t\tself.function_header_label = QLabel(\"No function selected\")\n\t\tself.function_header_label.setFont(monospaced_font)\n\t\tself.header_label.setSizePolicy(QSizePolicy(QSizePolicy.Minimum,\n                                                 QSizePolicy.Minimum))\n\t\tlayout.addWidget(self.function_header_label)\n\t\tself.op_asm_split_view = QSplitter()\n\t\tself.op_asm_split_view.setSizePolicy(QSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding))\n\t\tself.basic_op_pane = QListView()\n\t\tself.basic_op_pane.clicked.connect(self.basic_op_clicked)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.function_header_label",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.function_header_label = QLabel(\"No function selected\")\n\t\tself.function_header_label.setFont(monospaced_font)\n\t\tself.header_label.setSizePolicy(QSizePolicy(QSizePolicy.Minimum,\n                                                 QSizePolicy.Minimum))\n\t\tlayout.addWidget(self.function_header_label)\n\t\tself.op_asm_split_view = QSplitter()\n\t\tself.op_asm_split_view.setSizePolicy(QSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding))\n\t\tself.basic_op_pane = QListView()\n\t\tself.basic_op_pane.clicked.connect(self.basic_op_clicked)\n\t\t#layout.addWidget(self.basic_op_pane)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.op_asm_split_view",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.op_asm_split_view = QSplitter()\n\t\tself.op_asm_split_view.setSizePolicy(QSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding))\n\t\tself.basic_op_pane = QListView()\n\t\tself.basic_op_pane.clicked.connect(self.basic_op_clicked)\n\t\t#layout.addWidget(self.basic_op_pane)\n\t\tself.op_asm_split_view.addWidget(self.basic_op_pane)\n\t\tself.asm_pane = QListView()\n\t\tself.op_asm_split_view.addWidget(self.asm_pane)\n\t\tlayout.addWidget(self.op_asm_split_view)\n\t\tself.asm_display = QPlainTextEdit()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.basic_op_pane",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.basic_op_pane = QListView()\n\t\tself.basic_op_pane.clicked.connect(self.basic_op_clicked)\n\t\t#layout.addWidget(self.basic_op_pane)\n\t\tself.op_asm_split_view.addWidget(self.basic_op_pane)\n\t\tself.asm_pane = QListView()\n\t\tself.op_asm_split_view.addWidget(self.asm_pane)\n\t\tlayout.addWidget(self.op_asm_split_view)\n\t\tself.asm_display = QPlainTextEdit()\n\t\tself.asm_display.setMaximumHeight(80)\n\t\tlayout.addWidget(self.asm_display)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.asm_pane",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.asm_pane = QListView()\n\t\tself.op_asm_split_view.addWidget(self.asm_pane)\n\t\tlayout.addWidget(self.op_asm_split_view)\n\t\tself.asm_display = QPlainTextEdit()\n\t\tself.asm_display.setMaximumHeight(80)\n\t\tlayout.addWidget(self.asm_display)\n\t\tself.warnings_label = QLabel()\n\t\tlayout.addWidget(self.warnings_label)\n\t\twidget = QWidget()\n\t\twidget.setLayout(layout)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.asm_display",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.asm_display = QPlainTextEdit()\n\t\tself.asm_display.setMaximumHeight(80)\n\t\tlayout.addWidget(self.asm_display)\n\t\tself.warnings_label = QLabel()\n\t\tlayout.addWidget(self.warnings_label)\n\t\twidget = QWidget()\n\t\twidget.setLayout(layout)\n\t\tfunction_splitter.addWidget(widget)\n\t\tmain_layout.addWidget(function_splitter)\n\t\t# add it to the window!",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.warnings_label",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.warnings_label = QLabel()\n\t\tlayout.addWidget(self.warnings_label)\n\t\twidget = QWidget()\n\t\twidget.setLayout(layout)\n\t\tfunction_splitter.addWidget(widget)\n\t\tmain_layout.addWidget(function_splitter)\n\t\t# add it to the window!\n\t\tself.setLayout(main_layout)\n\tdef display_function(self, item):\n\t\tname = item.data()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\twidget",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\twidget = QWidget()\n\t\twidget.setLayout(layout)\n\t\tfunction_splitter.addWidget(widget)\n\t\tmain_layout.addWidget(function_splitter)\n\t\t# add it to the window!\n\t\tself.setLayout(main_layout)\n\tdef display_function(self, item):\n\t\tname = item.data()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tfunc = self.functions_by_name[name]",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tname",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tname = item.data()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tfunc = self.functions_by_name[name]\n\t\tbasic_op_model = QStandardItemModel()\n\t\tbasic_op_root = basic_op_model.invisibleRootItem()\n\t\tasm_model = QStandardItemModel()\n\t\tasm_root = asm_model.invisibleRootItem()\n\t\tself.basic_id_to_asm = []\n\t\tself.current_function = name\n\t\top_idx = 0",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tmonospaced_font",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tmonospaced_font = get_monospaced_font()\n\t\tfunc = self.functions_by_name[name]\n\t\tbasic_op_model = QStandardItemModel()\n\t\tbasic_op_root = basic_op_model.invisibleRootItem()\n\t\tasm_model = QStandardItemModel()\n\t\tasm_root = asm_model.invisibleRootItem()\n\t\tself.basic_id_to_asm = []\n\t\tself.current_function = name\n\t\top_idx = 0\n\t\tbasic_idx = 0",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tfunc",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tfunc = self.functions_by_name[name]\n\t\tbasic_op_model = QStandardItemModel()\n\t\tbasic_op_root = basic_op_model.invisibleRootItem()\n\t\tasm_model = QStandardItemModel()\n\t\tasm_root = asm_model.invisibleRootItem()\n\t\tself.basic_id_to_asm = []\n\t\tself.current_function = name\n\t\top_idx = 0\n\t\tbasic_idx = 0\n\t\tfor op in func[\"asm\"]:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tbasic_op_model",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tbasic_op_model = QStandardItemModel()\n\t\tbasic_op_root = basic_op_model.invisibleRootItem()\n\t\tasm_model = QStandardItemModel()\n\t\tasm_root = asm_model.invisibleRootItem()\n\t\tself.basic_id_to_asm = []\n\t\tself.current_function = name\n\t\top_idx = 0\n\t\tbasic_idx = 0\n\t\tfor op in func[\"asm\"]:\n\t\t\tif \"label\" in op:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tbasic_op_root",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tbasic_op_root = basic_op_model.invisibleRootItem()\n\t\tasm_model = QStandardItemModel()\n\t\tasm_root = asm_model.invisibleRootItem()\n\t\tself.basic_id_to_asm = []\n\t\tself.current_function = name\n\t\top_idx = 0\n\t\tbasic_idx = 0\n\t\tfor op in func[\"asm\"]:\n\t\t\tif \"label\" in op:\n\t\t\t\tasm_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"asm_op\"])",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tasm_model",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tasm_model = QStandardItemModel()\n\t\tasm_root = asm_model.invisibleRootItem()\n\t\tself.basic_id_to_asm = []\n\t\tself.current_function = name\n\t\top_idx = 0\n\t\tbasic_idx = 0\n\t\tfor op in func[\"asm\"]:\n\t\t\tif \"label\" in op:\n\t\t\t\tasm_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"asm_op\"])\n\t\t\telse:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tasm_root",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tasm_root = asm_model.invisibleRootItem()\n\t\tself.basic_id_to_asm = []\n\t\tself.current_function = name\n\t\top_idx = 0\n\t\tbasic_idx = 0\n\t\tfor op in func[\"asm\"]:\n\t\t\tif \"label\" in op:\n\t\t\t\tasm_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"asm_op\"])\n\t\t\telse:\n\t\t\t\tasm_item = QStandardItem(\"    \" + op[\"asm_op\"])",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.basic_id_to_asm",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.basic_id_to_asm = []\n\t\tself.current_function = name\n\t\top_idx = 0\n\t\tbasic_idx = 0\n\t\tfor op in func[\"asm\"]:\n\t\t\tif \"label\" in op:\n\t\t\t\tasm_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"asm_op\"])\n\t\t\telse:\n\t\t\t\tasm_item = QStandardItem(\"    \" + op[\"asm_op\"])\n\t\t\tasm_item.setFont(monospaced_font)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.current_function",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.current_function = name\n\t\top_idx = 0\n\t\tbasic_idx = 0\n\t\tfor op in func[\"asm\"]:\n\t\t\tif \"label\" in op:\n\t\t\t\tasm_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"asm_op\"])\n\t\t\telse:\n\t\t\t\tasm_item = QStandardItem(\"    \" + op[\"asm_op\"])\n\t\t\tasm_item.setFont(monospaced_font)\n\t\t\tasm_item.setEditable(False)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\top_idx",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\top_idx = 0\n\t\tbasic_idx = 0\n\t\tfor op in func[\"asm\"]:\n\t\t\tif \"label\" in op:\n\t\t\t\tasm_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"asm_op\"])\n\t\t\telse:\n\t\t\t\tasm_item = QStandardItem(\"    \" + op[\"asm_op\"])\n\t\t\tasm_item.setFont(monospaced_font)\n\t\t\tasm_item.setEditable(False)\n\t\t\tasm_root.appendRow(asm_item)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tbasic_idx",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tbasic_idx = 0\n\t\tfor op in func[\"asm\"]:\n\t\t\tif \"label\" in op:\n\t\t\t\tasm_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"asm_op\"])\n\t\t\telse:\n\t\t\t\tasm_item = QStandardItem(\"    \" + op[\"asm_op\"])\n\t\t\tasm_item.setFont(monospaced_font)\n\t\t\tasm_item.setEditable(False)\n\t\t\tasm_root.appendRow(asm_item)\n\t\t\tif \"basic_op\" in op:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tasm_item",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\t\tasm_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"asm_op\"])\n\t\t\telse:\n\t\t\t\tasm_item = QStandardItem(\"    \" + op[\"asm_op\"])\n\t\t\tasm_item.setFont(monospaced_font)\n\t\t\tasm_item.setEditable(False)\n\t\t\tasm_root.appendRow(asm_item)\n\t\t\tif \"basic_op\" in op:\n\t\t\t\tif \"label\" in op:\n\t\t\t\t\tbasic_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"basic_op\"])\n\t\t\t\telse:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tasm_item",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\t\tasm_item = QStandardItem(\"    \" + op[\"asm_op\"])\n\t\t\tasm_item.setFont(monospaced_font)\n\t\t\tasm_item.setEditable(False)\n\t\t\tasm_root.appendRow(asm_item)\n\t\t\tif \"basic_op\" in op:\n\t\t\t\tif \"label\" in op:\n\t\t\t\t\tbasic_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"basic_op\"])\n\t\t\t\telse:\n\t\t\t\t\tbasic_item = QStandardItem(\"    \" + op[\"basic_op\"])\n\t\t\t\tbasic_item.setFont(monospaced_font)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tbasic_item",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\t\t\tbasic_item = QStandardItem(op[\"label\"] + \"\\n    \" + op[\"basic_op\"])\n\t\t\t\telse:\n\t\t\t\t\tbasic_item = QStandardItem(\"    \" + op[\"basic_op\"])\n\t\t\t\tbasic_item.setFont(monospaced_font)\n\t\t\t\tbasic_item.setEditable(False)\n\t\t\t\tbasic_op_root.appendRow(basic_item)\n\t\t\t\tself.basic_id_to_asm.append(op_idx)\n\t\t\t\tbasic_idx = basic_idx + 1\n\t\t\top_idx = op_idx + 1\n\t\tself.basic_id_to_asm.append(op_idx)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tbasic_item",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\t\t\tbasic_item = QStandardItem(\"    \" + op[\"basic_op\"])\n\t\t\t\tbasic_item.setFont(monospaced_font)\n\t\t\t\tbasic_item.setEditable(False)\n\t\t\t\tbasic_op_root.appendRow(basic_item)\n\t\t\t\tself.basic_id_to_asm.append(op_idx)\n\t\t\t\tbasic_idx = basic_idx + 1\n\t\t\top_idx = op_idx + 1\n\t\tself.basic_id_to_asm.append(op_idx)\n\t\tself.basic_op_pane.setModel(basic_op_model)\n\t\tself.asm_pane.setModel(asm_model)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tbasic_idx",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\t\tbasic_idx = basic_idx + 1\n\t\t\top_idx = op_idx + 1\n\t\tself.basic_id_to_asm.append(op_idx)\n\t\tself.basic_op_pane.setModel(basic_op_model)\n\t\tself.asm_pane.setModel(asm_model)\n\t\tself.warnings_label.setText(func[\"warnings\"])\n\t\tself.asm_display.setPlainText(\"\")\n\t\tself.function_header_label.setText(\"{}, type: {}\\nfunc: {} obj: {}\".format(name, func[\"type\"], func[\"name\"], func[\"parent_object\"]))\n\tdef basic_op_clicked(self, item):\n\t\ttext = \"\"",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\top_idx",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\top_idx = op_idx + 1\n\t\tself.basic_id_to_asm.append(op_idx)\n\t\tself.basic_op_pane.setModel(basic_op_model)\n\t\tself.asm_pane.setModel(asm_model)\n\t\tself.warnings_label.setText(func[\"warnings\"])\n\t\tself.asm_display.setPlainText(\"\")\n\t\tself.function_header_label.setText(\"{}, type: {}\\nfunc: {} obj: {}\".format(name, func[\"type\"], func[\"name\"], func[\"parent_object\"]))\n\tdef basic_op_clicked(self, item):\n\t\ttext = \"\"\n\t\tadded_reg = 0",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\ttext",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\ttext = \"\"\n\t\tadded_reg = 0\n\t\tasm_idx = self.basic_id_to_asm[item.row()]\n\t\tasm_op = self.functions_by_name[self.current_function][\"asm\"][asm_idx]\n\t\tif \"type_map\" in asm_op:\n\t\t\tfor reg, type_name in asm_op[\"type_map\"].items():\n\t\t\t\ttext += \"{}: {} \".format(reg, type_name)\n\t\t\t\tadded_reg += 1\n\t\t\t\tif added_reg >= 4:\n\t\t\t\t\ttext += \"\\n\"",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tadded_reg",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tadded_reg = 0\n\t\tasm_idx = self.basic_id_to_asm[item.row()]\n\t\tasm_op = self.functions_by_name[self.current_function][\"asm\"][asm_idx]\n\t\tif \"type_map\" in asm_op:\n\t\t\tfor reg, type_name in asm_op[\"type_map\"].items():\n\t\t\t\ttext += \"{}: {} \".format(reg, type_name)\n\t\t\t\tadded_reg += 1\n\t\t\t\tif added_reg >= 4:\n\t\t\t\t\ttext += \"\\n\"\n\t\t\t\t\tadded_reg = 0",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tasm_idx",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tasm_idx = self.basic_id_to_asm[item.row()]\n\t\tasm_op = self.functions_by_name[self.current_function][\"asm\"][asm_idx]\n\t\tif \"type_map\" in asm_op:\n\t\t\tfor reg, type_name in asm_op[\"type_map\"].items():\n\t\t\t\ttext += \"{}: {} \".format(reg, type_name)\n\t\t\t\tadded_reg += 1\n\t\t\t\tif added_reg >= 4:\n\t\t\t\t\ttext += \"\\n\"\n\t\t\t\t\tadded_reg = 0\n\t\t\ttext += \"\\n\"",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tasm_op",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tasm_op = self.functions_by_name[self.current_function][\"asm\"][asm_idx]\n\t\tif \"type_map\" in asm_op:\n\t\t\tfor reg, type_name in asm_op[\"type_map\"].items():\n\t\t\t\ttext += \"{}: {} \".format(reg, type_name)\n\t\t\t\tadded_reg += 1\n\t\t\t\tif added_reg >= 4:\n\t\t\t\t\ttext += \"\\n\"\n\t\t\t\t\tadded_reg = 0\n\t\t\ttext += \"\\n\"\n\t\tfor i in range(asm_idx, self.basic_id_to_asm[item.row() + 1]):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tadded_reg",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\t\t\tadded_reg = 0\n\t\t\ttext += \"\\n\"\n\t\tfor i in range(asm_idx, self.basic_id_to_asm[item.row() + 1]):\n\t\t\ttext += self.functions_by_name[self.current_function][\"asm\"][i][\"asm_op\"] + \"\\n\"\n\t\top = self.functions_by_name[self.current_function][\"asm\"][asm_idx]\n\t\tif \"referenced_string\" in op:\n\t\t\ttext += op[\"referenced_string\"]\n\t\tself.asm_display.setPlainText(text)\n\t\tself.asm_display.setFont(get_monospaced_font())\n\t\tself.asm_pane.setCurrentIndex(self.asm_pane.model().index(asm_idx, 0))",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\top",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\top = self.functions_by_name[self.current_function][\"asm\"][asm_idx]\n\t\tif \"referenced_string\" in op:\n\t\t\ttext += op[\"referenced_string\"]\n\t\tself.asm_display.setPlainText(text)\n\t\tself.asm_display.setFont(get_monospaced_font())\n\t\tself.asm_pane.setCurrentIndex(self.asm_pane.model().index(asm_idx, 0))\n# A window for browsing all the object files.\n# Doesn't actually know anything about what's in the files, it's just used to select a file.\nclass ObjectFileBrowser(QMainWindow):\n\tdef __init__(self, obj_map):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.obj_map",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.obj_map = obj_map\n\t\tsuper().__init__()\n\t\tself.setWindowTitle(\"Object File Browser\")\n\t\tself.childen_windows = []\n\t\tlayout = QVBoxLayout()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tlayout.addWidget(QLabel(\"Browse object files by dgo...\"))\n\t\t# Set up the tree view\n\t\tself.tree = QTreeView()\n\t\tself.tree_model = QStandardItemModel()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.childen_windows",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.childen_windows = []\n\t\tlayout = QVBoxLayout()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tlayout.addWidget(QLabel(\"Browse object files by dgo...\"))\n\t\t# Set up the tree view\n\t\tself.tree = QTreeView()\n\t\tself.tree_model = QStandardItemModel()\n\t\tself.tree_root = self.tree_model.invisibleRootItem()\n\t\tfor dgo_name, dgo in obj_map.dgo_files.items():\n\t\t\tdgo_entry = QStandardItem(dgo_name)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tlayout",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tlayout = QVBoxLayout()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tlayout.addWidget(QLabel(\"Browse object files by dgo...\"))\n\t\t# Set up the tree view\n\t\tself.tree = QTreeView()\n\t\tself.tree_model = QStandardItemModel()\n\t\tself.tree_root = self.tree_model.invisibleRootItem()\n\t\tfor dgo_name, dgo in obj_map.dgo_files.items():\n\t\t\tdgo_entry = QStandardItem(dgo_name)\n\t\t\tdgo_entry.setFont(monospaced_font)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tmonospaced_font",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tmonospaced_font = get_monospaced_font()\n\t\tlayout.addWidget(QLabel(\"Browse object files by dgo...\"))\n\t\t# Set up the tree view\n\t\tself.tree = QTreeView()\n\t\tself.tree_model = QStandardItemModel()\n\t\tself.tree_root = self.tree_model.invisibleRootItem()\n\t\tfor dgo_name, dgo in obj_map.dgo_files.items():\n\t\t\tdgo_entry = QStandardItem(dgo_name)\n\t\t\tdgo_entry.setFont(monospaced_font)\n\t\t\tdgo_entry.setEditable(False)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.tree",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.tree = QTreeView()\n\t\tself.tree_model = QStandardItemModel()\n\t\tself.tree_root = self.tree_model.invisibleRootItem()\n\t\tfor dgo_name, dgo in obj_map.dgo_files.items():\n\t\t\tdgo_entry = QStandardItem(dgo_name)\n\t\t\tdgo_entry.setFont(monospaced_font)\n\t\t\tdgo_entry.setEditable(False)\n\t\t\tfor obj_name, obj in dgo.obj_files.items():\n\t\t\t\tobj_entry = QStandardItem(obj_name)\n\t\t\t\tobj_entry.setFont(monospaced_font)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.tree_model",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.tree_model = QStandardItemModel()\n\t\tself.tree_root = self.tree_model.invisibleRootItem()\n\t\tfor dgo_name, dgo in obj_map.dgo_files.items():\n\t\t\tdgo_entry = QStandardItem(dgo_name)\n\t\t\tdgo_entry.setFont(monospaced_font)\n\t\t\tdgo_entry.setEditable(False)\n\t\t\tfor obj_name, obj in dgo.obj_files.items():\n\t\t\t\tobj_entry = QStandardItem(obj_name)\n\t\t\t\tobj_entry.setFont(monospaced_font)\n\t\t\t\tobj_entry.setEditable(False)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.tree_root",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.tree_root = self.tree_model.invisibleRootItem()\n\t\tfor dgo_name, dgo in obj_map.dgo_files.items():\n\t\t\tdgo_entry = QStandardItem(dgo_name)\n\t\t\tdgo_entry.setFont(monospaced_font)\n\t\t\tdgo_entry.setEditable(False)\n\t\t\tfor obj_name, obj in dgo.obj_files.items():\n\t\t\t\tobj_entry = QStandardItem(obj_name)\n\t\t\t\tobj_entry.setFont(monospaced_font)\n\t\t\t\tobj_entry.setEditable(False)\n\t\t\t\tdgo_entry.appendRow(obj_entry)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\tdgo_entry",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\tdgo_entry = QStandardItem(dgo_name)\n\t\t\tdgo_entry.setFont(monospaced_font)\n\t\t\tdgo_entry.setEditable(False)\n\t\t\tfor obj_name, obj in dgo.obj_files.items():\n\t\t\t\tobj_entry = QStandardItem(obj_name)\n\t\t\t\tobj_entry.setFont(monospaced_font)\n\t\t\t\tobj_entry.setEditable(False)\n\t\t\t\tdgo_entry.appendRow(obj_entry)\n\t\t\tself.tree_root.appendRow(dgo_entry)\n\t\tself.tree.setModel(self.tree_model)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tobj_entry",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\t\tobj_entry = QStandardItem(obj_name)\n\t\t\t\tobj_entry.setFont(monospaced_font)\n\t\t\t\tobj_entry.setEditable(False)\n\t\t\t\tdgo_entry.appendRow(obj_entry)\n\t\t\tself.tree_root.appendRow(dgo_entry)\n\t\tself.tree.setModel(self.tree_model)\n\t\tself.tree.clicked.connect(self.handle_tree_click)\n\t\tself.tree.doubleClicked.connect(self.handle_tree_double_click)\n\t\tlayout.addWidget(self.tree)\n\t\t# Set up the Search Box",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.search_box",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.search_box = QLineEdit()\n\t\tself.search_box.textChanged.connect(self.handle_search_change)\n\t\tlayout.addWidget(self.search_box)\n\t\t# Set up Search Results\n\t\tself.search_result = QListView()\n\t\tlayout.addWidget(self.search_result)\n\t\tself.search_result.clicked.connect(self.handle_search_result_click)\n\t\tself.search_result.doubleClicked.connect(self.handle_search_result_double_click)\n\t\tself.search_result.setMaximumHeight(200)\n\t\t# Set up the info box at the bottom",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.search_result",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.search_result = QListView()\n\t\tlayout.addWidget(self.search_result)\n\t\tself.search_result.clicked.connect(self.handle_search_result_click)\n\t\tself.search_result.doubleClicked.connect(self.handle_search_result_double_click)\n\t\tself.search_result.setMaximumHeight(200)\n\t\t# Set up the info box at the bottom\n\t\tself.text_box = QPlainTextEdit()\n\t\tself.text_box.setReadOnly(True)\n\t\tself.text_box.setFont(monospaced_font)\n\t\tlayout.addWidget(self.text_box)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tself.text_box",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tself.text_box = QPlainTextEdit()\n\t\tself.text_box.setReadOnly(True)\n\t\tself.text_box.setFont(monospaced_font)\n\t\tlayout.addWidget(self.text_box)\n\t\tself.text_box.setMaximumHeight(100)\n\t\tself.text_box.setPlainText(\"Select an object file to see details. Double click to open.\")\n\t\t# add it to the window!\n\t\twidget = QWidget()\n\t\twidget.setLayout(layout)\n\t\tself.setCentralWidget(widget)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\twidget",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\twidget = QWidget()\n\t\twidget.setLayout(layout)\n\t\tself.setCentralWidget(widget)\n\tdef handle_tree_click(self, val):\n\t\tif not(val.parent().isValid()):\n\t\t\treturn\n\t\tdgo = val.parent().data()\n\t\tobj = val.data()\n\t\tobj_info = self.obj_map.dgo_files[dgo].obj_files[obj]\n\t\tself.text_box.setPlainText(\"{}\\n  DGO: {}\".format(obj_info.get_description(), dgo))",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tdgo",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tdgo = val.parent().data()\n\t\tobj = val.data()\n\t\tobj_info = self.obj_map.dgo_files[dgo].obj_files[obj]\n\t\tself.text_box.setPlainText(\"{}\\n  DGO: {}\".format(obj_info.get_description(), dgo))\n\tdef handle_search_change(self, text):\n\t\tobjs = self.obj_map.get_objs_matching_regex(text)\n\t\tmodel = QStandardItemModel()\n\t\troot = model.invisibleRootItem()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tfor x in objs:",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tobj",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tobj = val.data()\n\t\tobj_info = self.obj_map.dgo_files[dgo].obj_files[obj]\n\t\tself.text_box.setPlainText(\"{}\\n  DGO: {}\".format(obj_info.get_description(), dgo))\n\tdef handle_search_change(self, text):\n\t\tobjs = self.obj_map.get_objs_matching_regex(text)\n\t\tmodel = QStandardItemModel()\n\t\troot = model.invisibleRootItem()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tfor x in objs:\n\t\t\tentry = QStandardItem(x)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tobj_info",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tobj_info = self.obj_map.dgo_files[dgo].obj_files[obj]\n\t\tself.text_box.setPlainText(\"{}\\n  DGO: {}\".format(obj_info.get_description(), dgo))\n\tdef handle_search_change(self, text):\n\t\tobjs = self.obj_map.get_objs_matching_regex(text)\n\t\tmodel = QStandardItemModel()\n\t\troot = model.invisibleRootItem()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tfor x in objs:\n\t\t\tentry = QStandardItem(x)\n\t\t\tentry.setFont(monospaced_font)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tobjs",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tobjs = self.obj_map.get_objs_matching_regex(text)\n\t\tmodel = QStandardItemModel()\n\t\troot = model.invisibleRootItem()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tfor x in objs:\n\t\t\tentry = QStandardItem(x)\n\t\t\tentry.setFont(monospaced_font)\n\t\t\tentry.setEditable(False)\n\t\t\troot.appendRow(entry)\n\t\tself.search_result.setModel(model)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tmodel",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tmodel = QStandardItemModel()\n\t\troot = model.invisibleRootItem()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tfor x in objs:\n\t\t\tentry = QStandardItem(x)\n\t\t\tentry.setFont(monospaced_font)\n\t\t\tentry.setEditable(False)\n\t\t\troot.appendRow(entry)\n\t\tself.search_result.setModel(model)\n\tdef handle_search_result_click(self, val):\t\t",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\troot",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\troot = model.invisibleRootItem()\n\t\tmonospaced_font = get_monospaced_font()\n\t\tfor x in objs:\n\t\t\tentry = QStandardItem(x)\n\t\t\tentry.setFont(monospaced_font)\n\t\t\tentry.setEditable(False)\n\t\t\troot.appendRow(entry)\n\t\tself.search_result.setModel(model)\n\tdef handle_search_result_click(self, val):\t\t\n\t\tobj = val.data()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tmonospaced_font",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tmonospaced_font = get_monospaced_font()\n\t\tfor x in objs:\n\t\t\tentry = QStandardItem(x)\n\t\t\tentry.setFont(monospaced_font)\n\t\t\tentry.setEditable(False)\n\t\t\troot.appendRow(entry)\n\t\tself.search_result.setModel(model)\n\tdef handle_search_result_click(self, val):\t\t\n\t\tobj = val.data()\n\t\tobj_info = self.obj_map.all_objs[obj]",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\t\tentry",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\t\tentry = QStandardItem(x)\n\t\t\tentry.setFont(monospaced_font)\n\t\t\tentry.setEditable(False)\n\t\t\troot.appendRow(entry)\n\t\tself.search_result.setModel(model)\n\tdef handle_search_result_click(self, val):\t\t\n\t\tobj = val.data()\n\t\tobj_info = self.obj_map.all_objs[obj]\n\t\tself.text_box.setPlainText(obj_info.get_description())\n\tdef handle_search_result_double_click(self, val):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tobj",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tobj = val.data()\n\t\tobj_info = self.obj_map.all_objs[obj]\n\t\tself.text_box.setPlainText(obj_info.get_description())\n\tdef handle_search_result_double_click(self, val):\n\t\tobj = val.data()\n\t\twindow = ObjectFileView(obj)\n\t\twindow.show()\n\t\t# prevents window from being GC'd and closed.\n\t\tself.childen_windows.append(window)\n\tdef handle_tree_double_click(self, val):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tobj_info",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tobj_info = self.obj_map.all_objs[obj]\n\t\tself.text_box.setPlainText(obj_info.get_description())\n\tdef handle_search_result_double_click(self, val):\n\t\tobj = val.data()\n\t\twindow = ObjectFileView(obj)\n\t\twindow.show()\n\t\t# prevents window from being GC'd and closed.\n\t\tself.childen_windows.append(window)\n\tdef handle_tree_double_click(self, val):\n\t\tif not(val.parent().isValid()):",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tobj",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tobj = val.data()\n\t\twindow = ObjectFileView(obj)\n\t\twindow.show()\n\t\t# prevents window from being GC'd and closed.\n\t\tself.childen_windows.append(window)\n\tdef handle_tree_double_click(self, val):\n\t\tif not(val.parent().isValid()):\n\t\t\treturn\n\t\tobj = val.data()\n\t\twindow = ObjectFileView(obj)",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\twindow",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\twindow = ObjectFileView(obj)\n\t\twindow.show()\n\t\t# prevents window from being GC'd and closed.\n\t\tself.childen_windows.append(window)\n\tdef handle_tree_double_click(self, val):\n\t\tif not(val.parent().isValid()):\n\t\t\treturn\n\t\tobj = val.data()\n\t\twindow = ObjectFileView(obj)\n\t\twindow.show()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\tobj",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\tobj = val.data()\n\t\twindow = ObjectFileView(obj)\n\t\twindow.show()\n\t\t# prevents window from being GC'd and closed.\n\t\tself.childen_windows.append(window)\nmap_file = load_obj_map_file(os.path.join(get_jak_path(), \"decompiler_out\", \"obj.txt\"))\napp = QApplication([])\napp.setStyle('Windows')\nwindow = ObjectFileBrowser(map_file)\nwindow.show()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "\t\twindow",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "\t\twindow = ObjectFileView(obj)\n\t\twindow.show()\n\t\t# prevents window from being GC'd and closed.\n\t\tself.childen_windows.append(window)\nmap_file = load_obj_map_file(os.path.join(get_jak_path(), \"decompiler_out\", \"obj.txt\"))\napp = QApplication([])\napp.setStyle('Windows')\nwindow = ObjectFileBrowser(map_file)\nwindow.show()\napp.exec_()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "map_file",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "map_file = load_obj_map_file(os.path.join(get_jak_path(), \"decompiler_out\", \"obj.txt\"))\napp = QApplication([])\napp.setStyle('Windows')\nwindow = ObjectFileBrowser(map_file)\nwindow.show()\napp.exec_()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "app = QApplication([])\napp.setStyle('Windows')\nwindow = ObjectFileBrowser(map_file)\nwindow.show()\napp.exec_()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "window",
        "kind": 5,
        "importPath": "decompiler.gui.decompiler_gui",
        "description": "decompiler.gui.decompiler_gui",
        "peekOfCode": "window = ObjectFileBrowser(map_file)\nwindow.show()\napp.exec_()",
        "detail": "decompiler.gui.decompiler_gui",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "decompiler.scripts.create_dgo_name_list",
        "description": "decompiler.scripts.create_dgo_name_list",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(dest='folder', help='folder containing dgos')\n    args = parser.parse_args()\n    files = sorted([os.path.basename(x) for x in glob.glob(os.path.join(args.folder, \"*.*GO\"))])\n    dgo_names = \"\\\"dgo_names\\\":[\"\n    count = 0\n    for file in files:\n        dgo_names += \"\\\"\" + file + \"\\\", \"\n        count += 1",
        "detail": "decompiler.scripts.create_dgo_name_list",
        "documentation": {}
    },
    {
        "label": "create_text_file",
        "kind": 2,
        "importPath": "game.assets.jak2.update-text-from-jak1",
        "description": "game.assets.jak2.update-text-from-jak1",
        "peekOfCode": "def create_text_file(locale):\n    if not os.path.exists(f\"./text/game_custom_text_{locale}.json\"):\n        with open(f\"./text/game_custom_text_{locale}.json\", \"w\", encoding=\"utf-8\") as f:\n            json.dump(default_jak2_english, f, indent=2, ensure_ascii=False)\n    with open(f\"./text/game_custom_text_{locale}.json\", \"r\", encoding=\"utf-8\") as f:\n        jak2_file = json.load(f)\n    with open(\n        f\"../jak1/text/game_custom_text_{locale}.json\", \"r\", encoding=\"utf-8\"\n    ) as f:\n        jak1_file = json.load(f)",
        "detail": "game.assets.jak2.update-text-from-jak1",
        "documentation": {}
    },
    {
        "label": "convert_lights_to_sql",
        "kind": 2,
        "importPath": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "description": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "peekOfCode": "def convert_lights_to_sql():\n    sql_lines = []\n    with open(\"fixture-lights.json\", \"r\", encoding=\"utf-8\") as f:\n        fixtures = json.load(f)\n    for level_name, lights in fixtures.items():\n        if level_name not in levels_added:\n            levels_added.add(level_name)\n            # since we get all the levels from the final game, the translate offset can always be 0\n            level_info_sql_lines.append(\n                f\"INSERT INTO level_info (name, translate_x, translate_y, translate_z, last_update, sample_point_update) VALUES ('{level_name}', 0, 0, 0, NULL, NULL);\\n\"",
        "detail": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "documentation": {}
    },
    {
        "label": "convert_regions_to_sql",
        "kind": 2,
        "importPath": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "description": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "peekOfCode": "def convert_regions_to_sql():\n    sql_lines = []\n    with open(\"fixture-regions.json\", \"r\", encoding=\"utf-8\") as f:\n        fixtures = json.load(f)\n    region_face_id = 0\n    for level_name, regions in fixtures.items():\n        if level_name not in levels_added:\n            levels_added.add(level_name)\n            # since we get all the levels from the final game, the translate offset can always be 0\n            level_info_sql_lines.append(",
        "detail": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "documentation": {}
    },
    {
        "label": "levels_added",
        "kind": 5,
        "importPath": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "description": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "peekOfCode": "levels_added = set()\nlevel_info_sql_lines = []\ndef convert_lights_to_sql():\n    sql_lines = []\n    with open(\"fixture-lights.json\", \"r\", encoding=\"utf-8\") as f:\n        fixtures = json.load(f)\n    for level_name, lights in fixtures.items():\n        if level_name not in levels_added:\n            levels_added.add(level_name)\n            # since we get all the levels from the final game, the translate offset can always be 0",
        "detail": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "documentation": {}
    },
    {
        "label": "level_info_sql_lines",
        "kind": 5,
        "importPath": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "description": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "peekOfCode": "level_info_sql_lines = []\ndef convert_lights_to_sql():\n    sql_lines = []\n    with open(\"fixture-lights.json\", \"r\", encoding=\"utf-8\") as f:\n        fixtures = json.load(f)\n    for level_name, lights in fixtures.items():\n        if level_name not in levels_added:\n            levels_added.add(level_name)\n            # since we get all the levels from the final game, the translate offset can always be 0\n            level_info_sql_lines.append(",
        "detail": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "documentation": {}
    },
    {
        "label": "lights_sql_lines",
        "kind": 5,
        "importPath": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "description": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "peekOfCode": "lights_sql_lines = convert_lights_to_sql()\n# write out the SQL files\n# with open(\"fixture-level_info.sql\", \"w\", encoding=\"utf-8\") as f:\n#   f.writelines(level_info_sql_lines)\n# with open(\"fixture-light.sql\", \"w\", encoding=\"utf-8\") as f:\n#   f.writelines(lights_sql_lines)\ndef convert_regions_to_sql():\n    sql_lines = []\n    with open(\"fixture-regions.json\", \"r\", encoding=\"utf-8\") as f:\n        fixtures = json.load(f)",
        "detail": "goal_src.jak2.tools.db-fixtures.data.convert-to-sql",
        "documentation": {}
    },
    {
        "label": "masks",
        "kind": 5,
        "importPath": "goal_src.replace_code",
        "description": "goal_src.replace_code",
        "peekOfCode": "masks = {\n    \"#b0001\": \"x\",\n    \"#b0010\": \"y\",\n    \"#b0100\": \"z\",\n    \"#b1000\": \"w\",\n    \"#b0011\": \"xy\",\n    \"#b0101\": \"xz\",\n    \"#b1001\": \"xw\",\n    \"#b0110\": \"yz\",\n    \"#b1010\": \"yw\",",
        "detail": "goal_src.replace_code",
        "documentation": {}
    },
    {
        "label": "relevant_files",
        "kind": 5,
        "importPath": "goal_src.replace_code",
        "description": "goal_src.replace_code",
        "peekOfCode": "relevant_files = glob.glob(\"./jak3/**/*.gc\", recursive=True)\nmask_regex = re.compile(r\"(:mask #b[0,1]+)\")\nop_regex = re.compile(r\"\\(.*(\\.vf)\\s\")\nfor file in relevant_files:\n    print(file)\n    new_lines = []\n    with open(file, mode=\"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()\n        for line in lines:\n            if \":mask #b\" in line:",
        "detail": "goal_src.replace_code",
        "documentation": {}
    },
    {
        "label": "mask_regex",
        "kind": 5,
        "importPath": "goal_src.replace_code",
        "description": "goal_src.replace_code",
        "peekOfCode": "mask_regex = re.compile(r\"(:mask #b[0,1]+)\")\nop_regex = re.compile(r\"\\(.*(\\.vf)\\s\")\nfor file in relevant_files:\n    print(file)\n    new_lines = []\n    with open(file, mode=\"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()\n        for line in lines:\n            if \":mask #b\" in line:\n                # find the operation name in the line and the mask value",
        "detail": "goal_src.replace_code",
        "documentation": {}
    },
    {
        "label": "op_regex",
        "kind": 5,
        "importPath": "goal_src.replace_code",
        "description": "goal_src.replace_code",
        "peekOfCode": "op_regex = re.compile(r\"\\(.*(\\.vf)\\s\")\nfor file in relevant_files:\n    print(file)\n    new_lines = []\n    with open(file, mode=\"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()\n        for line in lines:\n            if \":mask #b\" in line:\n                # find the operation name in the line and the mask value\n                mask_result = mask_regex.search(line)",
        "detail": "goal_src.replace_code",
        "documentation": {}
    },
    {
        "label": "op_names_2arg",
        "kind": 5,
        "importPath": "goal_src.temp",
        "description": "goal_src.temp",
        "peekOfCode": "op_names_2arg = [\n    \".mov.vf\",\n    \".abs.vf\",\n]\nop_names_3arg = [\n    \".xor.vf\",\n    \".blend.vf\",\n    \".max.vf\",\n    \".max.x.vf\",\n    \".max.y.vf\",",
        "detail": "goal_src.temp",
        "documentation": {}
    },
    {
        "label": "op_names_3arg",
        "kind": 5,
        "importPath": "goal_src.temp",
        "description": "goal_src.temp",
        "peekOfCode": "op_names_3arg = [\n    \".xor.vf\",\n    \".blend.vf\",\n    \".max.vf\",\n    \".max.x.vf\",\n    \".max.y.vf\",\n    \".max.z.vf\",\n    \".max.w.vf\",\n    \".min.vf\",\n    \".min.x.vf\",",
        "detail": "goal_src.temp",
        "documentation": {}
    },
    {
        "label": "op_names_4arg",
        "kind": 5,
        "importPath": "goal_src.temp",
        "description": "goal_src.temp",
        "peekOfCode": "op_names_4arg = [\n    \".add.mul.vf\",\n    \".add.mul.x.vf\",\n    \".add.mul.y.vf\",\n    \".add.mul.z.vf\",\n    \".add.mul.w.vf\",\n    \".sub.mul.vf\",\n    \".sub.mul.x.vf\",\n    \".sub.mul.y.vf\",\n    \".sub.mul.z.vf\",",
        "detail": "goal_src.temp",
        "documentation": {}
    },
    {
        "label": "masks",
        "kind": 5,
        "importPath": "goal_src.temp",
        "description": "goal_src.temp",
        "peekOfCode": "masks = {\n    \"x\": \"#b0001\",\n    \"y\": \"#b0010\",\n    \"z\": \"#b0100\",\n    \"w\": \"#b1000\",\n    \"xy\": \"#b0011\",\n    \"xz\": \"#b0101\",\n    \"xw\": \"#b1001\",\n    \"yz\": \"#b0110\",\n    \"yw\": \"#b1010\",",
        "detail": "goal_src.temp",
        "documentation": {}
    },
    {
        "label": "get_file_comment",
        "kind": 2,
        "importPath": "scripts.ci.docs.append-file-docs",
        "description": "scripts.ci.docs.append-file-docs",
        "peekOfCode": "def get_file_comment(path):\n  full_path = \"./goal_src/{}\".format(path)\n  if os.path.exists(full_path):\n    with open(full_path, 'r') as f:\n      lines = f.readlines()\n      parsing_comment = False\n      comment = []\n      for idx, line in enumerate(lines):\n        if parsing_comment is False and idx >= 100:\n          return None",
        "detail": "scripts.ci.docs.append-file-docs",
        "documentation": {}
    },
    {
        "label": "append_file_docs",
        "kind": 2,
        "importPath": "scripts.ci.docs.append-file-docs",
        "description": "scripts.ci.docs.append-file-docs",
        "peekOfCode": "def append_file_docs(game_name):\n  with open('./{}-file-docs.json'.format(game_name), 'r') as f:\n    file_docs = json.load(f)\n  for file_path, file_info in file_docs.items():\n    # Go and find the file in goal_src\n    # Check to see if it has a #|@file line (within the first 100 lines)\n    # If it does, parse out the description from that block comment and update the json\n    comment = get_file_comment(file_path)\n    if comment is not None:\n      file_info[\"description\"] = comment",
        "detail": "scripts.ci.docs.append-file-docs",
        "documentation": {}
    },
    {
        "label": "folders_to_check",
        "kind": 5,
        "importPath": "scripts.ci.check-for-asserts",
        "description": "scripts.ci.check-for-asserts",
        "peekOfCode": "folders_to_check = [\"common\", \"decompiler\", \"game\", \"goalc\", \"test\", \"tools\", \"lsp\"]\nflagged_instances = []\nfor folder in folders_to_check:\n  files_to_check = glob.glob(\"./{}/**/*.cpp\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.h\".format(folder), recursive=True)\n  for filename in files_to_check:\n    # Get the file contents\n    with open(filename, \"r\", encoding=\"utf-8\") as f:\n      lines = f.readlines()\n      for i, line in enumerate(lines):",
        "detail": "scripts.ci.check-for-asserts",
        "documentation": {}
    },
    {
        "label": "flagged_instances",
        "kind": 5,
        "importPath": "scripts.ci.check-for-asserts",
        "description": "scripts.ci.check-for-asserts",
        "peekOfCode": "flagged_instances = []\nfor folder in folders_to_check:\n  files_to_check = glob.glob(\"./{}/**/*.cpp\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.h\".format(folder), recursive=True)\n  for filename in files_to_check:\n    # Get the file contents\n    with open(filename, \"r\", encoding=\"utf-8\") as f:\n      lines = f.readlines()\n      for i, line in enumerate(lines):\n        results = re.findall(r\"\\bassert\\(\", line)",
        "detail": "scripts.ci.check-for-asserts",
        "documentation": {}
    },
    {
        "label": "jak1_is_allowed_code",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def jak1_is_allowed_code(pos, text):\n    # Find any occurences of allowed codes in the string\n    # if the position overlaps with these occurrences, it's allowed\n    for code in JAK1_ALLOWED_CODES:\n        for match in re.finditer(code, text):\n            if pos >= match.start() and pos <= match.end():\n                return match.end()\n    return -1\ndef jak1_char_allowed(char):\n    return char in JAK1_ALLOWED_CHARACTERS",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "jak1_char_allowed",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def jak1_char_allowed(char):\n    return char in JAK1_ALLOWED_CHARACTERS\ndef jak1_fix_character(char):\n    # First let's try upper-casing it, if that's allowed, let's use that instead\n    upper_case = char.upper()\n    if jak1_char_allowed(upper_case):\n        return upper_case\n    if char in JAK1_AUTO_REPLACEMENTS:\n        return JAK1_AUTO_REPLACEMENTS[char]\n    return char",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "jak1_fix_character",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def jak1_fix_character(char):\n    # First let's try upper-casing it, if that's allowed, let's use that instead\n    upper_case = char.upper()\n    if jak1_char_allowed(upper_case):\n        return upper_case\n    if char in JAK1_AUTO_REPLACEMENTS:\n        return JAK1_AUTO_REPLACEMENTS[char]\n    return char\ndef jak1_replace_character(string, position, new_character):\n    string_list = list(string)",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "jak1_replace_character",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def jak1_replace_character(string, position, new_character):\n    string_list = list(string)\n    string_list[position] = new_character\n    new_string = \"\".join(string_list)\n    return new_string\ndef lint_jak1_characters(text):\n    invalid_characters_found = False\n    pos = 0\n    while pos < len(text):\n        character = text[pos]",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "lint_jak1_characters",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def lint_jak1_characters(text):\n    invalid_characters_found = False\n    pos = 0\n    while pos < len(text):\n        character = text[pos]\n        if not jak1_char_allowed(character):\n            # Check to see if it's an allowed code\n            code_end_pos = jak1_is_allowed_code(pos, text)\n            if code_end_pos == -1:\n                # If we are fixing instances, attempt to do so",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "jak2_is_allowed_code",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def jak2_is_allowed_code(pos, text):\n    # Find any occurences of allowed codes in the string\n    # if the position overlaps with these occurrences, it's allowed\n    for code in JAK2_ALLOWED_CODES:\n        for match in re.finditer(code, text):\n            if pos >= match.start() and pos <= match.end():\n                return match.end()\n    return -1\ndef jak2_char_allowed(char):\n    return char in JAK2_ALLOWED_CHARACTERS",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "jak2_char_allowed",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def jak2_char_allowed(char):\n    return char in JAK2_ALLOWED_CHARACTERS\ndef jak2_fix_character(char):\n    if char in JAK2_AUTO_REPLACEMENTS:\n        return JAK2_AUTO_REPLACEMENTS[char]\n    return char\ndef jak2_replace_character(string, position, new_character):\n    string_list = list(string)\n    string_list[position] = new_character\n    new_string = \"\".join(string_list)",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "jak2_fix_character",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def jak2_fix_character(char):\n    if char in JAK2_AUTO_REPLACEMENTS:\n        return JAK2_AUTO_REPLACEMENTS[char]\n    return char\ndef jak2_replace_character(string, position, new_character):\n    string_list = list(string)\n    string_list[position] = new_character\n    new_string = \"\".join(string_list)\n    return new_string\ndef lint_jak2_characters(text):",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "jak2_replace_character",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def jak2_replace_character(string, position, new_character):\n    string_list = list(string)\n    string_list[position] = new_character\n    new_string = \"\".join(string_list)\n    return new_string\ndef lint_jak2_characters(text):\n    invalid_characters_found = False\n    pos = 0\n    while pos < len(text):\n        character = text[pos]",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "lint_jak2_characters",
        "kind": 2,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "def lint_jak2_characters(text):\n    invalid_characters_found = False\n    pos = 0\n    while pos < len(text):\n        character = text[pos]\n        if not jak2_char_allowed(character):\n            # Check to see if it's an allowed code\n            code_end_pos = jak2_is_allowed_code(pos, text)\n            if code_end_pos == -1:\n                # If we are fixing instances, attempt to do so",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--fix\", action=\"store_true\")\nparser.set_defaults(fix=False)\nargs = parser.parse_args()\n# TODO - trim strings\n# fmt: off\nJAK1_ALLOWED_CHARACTERS = [\n    \"_\", # NOTE - not an actual underscore, adds a long space!\n    \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n    \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "args = parser.parse_args()\n# TODO - trim strings\n# fmt: off\nJAK1_ALLOWED_CHARACTERS = [\n    \"_\", # NOTE - not an actual underscore, adds a long space!\n    \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n    \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n    \"'\", \"!\", \"(\", \")\", \"+\", \"-\", \",\", \".\", \"/\", \":\", \"=\", \"<\", \">\", \"*\", \"%\", \"?\", \"\\\"\",\n    \"`\", \"ˇ\", \"¨\", \"º\", \"¡\", \"¿\", \"Æ\", \"Ç\", \"ß\", \"™\", \"、\", \" \", \"Å\", \"Ø\", \"Ą\", \"Ę\", \"Ł\", \"Ż\",\"Ů\", \"Ý\", \"Č\", \"Ň\", \"Ř\", \"Š\", \"Ť\", \"Ž\",\n    \"Ñ\", \"Ã\", \"Õ\", \"Á\", \"É\", \"Í\", \"Ó\", \"Ú\", \"Ć\", \"Ń\", \"Ś\", \"Ź\", \"Ő\", \"Ű\", \"Â\", \"Ê\", \"Î\", \"Ô\", \"Û\", \"À\", \"È\", \"Ì\", \"Ò\", \"Ù\", \"Ä\", \"Ë\", \"Ï\", \"Ö\", \"ö\", \"Ü\", \"Ė\",\"Č\",\"Š\",\"Ž\",\"Ų\",\"Ū\",\"Į\",\"Ǎ\",\"Ě\",\"Ǧ\",\"Ǐ\",\"Ǒ\",\"Ǔ\",\"Y̌\",",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "JAK1_ALLOWED_CHARACTERS",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "JAK1_ALLOWED_CHARACTERS = [\n    \"_\", # NOTE - not an actual underscore, adds a long space!\n    \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n    \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n    \"'\", \"!\", \"(\", \")\", \"+\", \"-\", \",\", \".\", \"/\", \":\", \"=\", \"<\", \">\", \"*\", \"%\", \"?\", \"\\\"\",\n    \"`\", \"ˇ\", \"¨\", \"º\", \"¡\", \"¿\", \"Æ\", \"Ç\", \"ß\", \"™\", \"、\", \" \", \"Å\", \"Ø\", \"Ą\", \"Ę\", \"Ł\", \"Ż\",\"Ů\", \"Ý\", \"Č\", \"Ň\", \"Ř\", \"Š\", \"Ť\", \"Ž\",\n    \"Ñ\", \"Ã\", \"Õ\", \"Á\", \"É\", \"Í\", \"Ó\", \"Ú\", \"Ć\", \"Ń\", \"Ś\", \"Ź\", \"Ő\", \"Ű\", \"Â\", \"Ê\", \"Î\", \"Ô\", \"Û\", \"À\", \"È\", \"Ì\", \"Ò\", \"Ù\", \"Ä\", \"Ë\", \"Ï\", \"Ö\", \"ö\", \"Ü\", \"Ė\",\"Č\",\"Š\",\"Ž\",\"Ų\",\"Ū\",\"Į\",\"Ǎ\",\"Ě\",\"Ǧ\",\"Ǐ\",\"Ǒ\",\"Ǔ\",\"Y̌\",\n    \"海\", \"界\", \"学\", \"ワ\", \"ヲ\", \"ン\", \"岩\", \"旧\", \"空\", \"ヮ\", \"撃\", \"賢\", \"湖\", \"口\", \"行\", \"合\", \"士\", \"寺\", \"山\", \"者\", \"所\", \"書\", \"小\", \"沼\", \"上\", \"城\", \"場\", \"出\", \"闇\", \"遺\", \"黄\", \"屋\", \"下\", \"家\", \"火\", \"花\", \"レ\", \"ロ\", \"青\", \"・\", \"゛\", \"゜\", \"ー\", \"『\", \"』\", \"宝\", \"石\", \"赤\", \"跡\", \"川\", \"戦\", \"村\", \"隊\", \"台\", \"長\", \"鳥\", \"艇\", \"洞\", \"道\", \"発\", \"飛\", \"噴\", \"池\", \"中\", \"塔\", \"島\", \"部\", \"砲\", \"産\", \"眷\", \"力\", \"緑\", \"岸\", \"像\", \"谷\", \"心\", \"森\", \"水\", \"船\", \"世\",\n    \"ぁ\", \"あ\", \"ぃ\", \"い\", \"ぅ\", \"う\", \"ぇ\", \"え\", \"ぉ\", \"お\", \"か\", \"き\", \"く\", \"け\", \"こ\", \"さ\", \"し\", \"す\", \"せ\", \"そ\", \"た\", \"ち\", \"っ\", \"つ\", \"て\", \"と\", \"な\", \"に\", \"ぬ\", \"ね\", \"の\", \"は\", \"ひ\", \"ふ\", \"へ\", \"ほ\", \"ま\", \"み\", \"む\", \"め\", \"も\", \"ゃ\", \"や\", \"ゅ\", \"ゆ\", \"ょ\", \"よ\", \"ら\", \"り\", \"る\", \"れ\", \"ろ\", \"ゎ\", \"わ\", \"を\", \"ん\",\n    \"が\", \"ぎ\", \"ぐ\", \"げ\", \"ご\", \"ざ\", \"じ\", \"ず\", \"ぜ\", \"ぞ\", \"だ\", \"ぢ\", \"づ\", \"で\", \"ど\", \"ば\", \"び\", \"ぶ\", \"べ\", \"ぼ\",",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "JAK1_ALLOWED_CODES",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "JAK1_ALLOWED_CODES = [\n    \"<TIL>\",\n    \"<PAD_X>\", \"<PAD_TRIANGLE>\", \"<PAD_CIRCLE>\", \"<PAD_SQUARE>\"\n]\nJAK1_AUTO_REPLACEMENTS = {\n    \"ª\": \"º\",\n    \"\\n\": \"\",\n    \"’\": \"'\",\n    \"·\": \"-\",\n    \"–\": \"-\",",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "JAK1_AUTO_REPLACEMENTS",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "JAK1_AUTO_REPLACEMENTS = {\n    \"ª\": \"º\",\n    \"\\n\": \"\",\n    \"’\": \"'\",\n    \"·\": \"-\",\n    \"–\": \"-\",\n    \"​\": \"\",\n    \"„\": \",,\",\n    \"”\": \"\\\"\",\n    \"　\": \" \",",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "JAK2_ALLOWED_CHARACTERS",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "JAK2_ALLOWED_CHARACTERS = [\n    \"_\", # NOTE - not an actual underscore, adds a long space!\n    \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n    \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\",\n    \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n    \"'\", \"!\", \"(\", \")\", \"+\", \"-\", \",\", \".\", \"/\", \":\", \"=\", \"<\", \">\", \"*\", \"%\", \"?\", \"\\\"\",\n    \"`\", \"ˇ\", \"¨\", \"º\", \"¡\", \"¿\", \"Æ\", \"Ç\", \"ß\", \"™\", \"、\", \" \", \"Å\", \"Ø\", \"Ą\", \"Ę\", \"Ł\", \"Ż\",\n    \"Ů\", \"ů\", \"Ý\", \"ý\", \"Č\", \"č\", \"Ň\", \"ň\", \"Ř\", \"ř\", \"Š\", \"š\", \"Ť\", \"ť\", \"Ž\", \"ž\",\n    \"æ\", \"ø\", \"œ\",\n    \"Ñ\", \"Ã\", \"Õ\", \"Á\", \"É\", \"Í\", \"Ó\", \"Ú\", \"Ć\", \"Ń\", \"Ś\", \"Ź\", \"ź\", \"Ő\", \"Ű\", \"Â\", \"Ê\", \"Î\", \"Ô\", \"Û\", \"À\", \"È\", \"Ì\", \"Ò\", \"Ù\", \"Ä\", \"Ë\", \"Ï\", \"ï\", \"Ö\", \"ö\", \"Ü\", \"Ė\",\"Č\",\"Š\",\"Ž\",\"Ų\",\"Ū\",\"Į\",",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "JAK2_ALLOWED_CODES",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "JAK2_ALLOWED_CODES = [\n    \"<TIL>\", \"<SUPERSCRIPT_QUOTE>\",\n    \"<PAD_X>\", \"<PAD_TRIANGLE>\", \"<PAD_CIRCLE>\", \"<PAD_SQUARE>\", \"<PAD_DPAD_UP>\", \"<PAD_DPAD_DOWN>\", \"<PAD_DPAD_ANY>\", \"<PAD_L1>\", \"<PAD_R1>\", \"<PAD_R2>\", \"<PAD_L2>\", \"<PAD_ANALOG_ANY>\", \"<PAD_ANALOG_LEFT_RIGHT>\", \"<PAD_ANALOG_UP_DOWN>\", \"<ICON_MISSION_COMPLETE>\", \"<ICON_MISSION_TODO>\", \"<FLAG_ITALIAN>\", \"<FLAG_SPAIN>\", \"<FLAG_GERMAN>\", \"<FLAG_FRANCE>\", \"<FLAG_UK>\", \"<FLAG_USA>\", \"<FLAG_KOREA>\", \"<FLAG_JAPAN>\", \"<FLAG_FINLAND>\", \"<FLAG_SWEDEN>\", \"<FLAG_DENMARK>\", \"<FLAG_NORWAY>\", \"<FLAG_ICELAND>\"\n]\nJAK2_AUTO_REPLACEMENTS = {\n    \"ª\": \"º\",\n    \"\\n\": \"\",\n    \"’\": \"'\",\n    \"·\": \"-\",\n    \"–\": \"-\",",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "JAK2_AUTO_REPLACEMENTS",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "JAK2_AUTO_REPLACEMENTS = {\n    \"ª\": \"º\",\n    \"\\n\": \"\",\n    \"’\": \"'\",\n    \"·\": \"-\",\n    \"–\": \"-\",\n    \"​\": \"\",\n    \"„\": \",,\",\n    \"”\": \"\\\"\",\n    \"　\": \" \",",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "invalid_characters_found",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "invalid_characters_found = False\n# TODO - reduce duplication\ndef jak1_is_allowed_code(pos, text):\n    # Find any occurences of allowed codes in the string\n    # if the position overlaps with these occurrences, it's allowed\n    for code in JAK1_ALLOWED_CODES:\n        for match in re.finditer(code, text):\n            if pos >= match.start() and pos <= match.end():\n                return match.end()\n    return -1",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "text_files",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "text_files = glob.glob(\"./game/assets/jak1/text/*.json\")\nfor text_file in text_files:\n    print(\"Checking {}\".format(text_file))\n    with open(text_file, encoding=\"utf-8\") as f:\n        file_data = json.load(f)\n    for id, text in file_data.items():\n        invalid_chars_exist, new_text = lint_jak1_characters(text)\n        if args.fix:\n            file_data[id] = new_text\n        if invalid_chars_exist:",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "subtitle_files",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "subtitle_files = glob.glob(\"./game/assets/jak1/subtitle/*lines*.json\")\nfor subtitle_file in subtitle_files:\n    print(\"Checking {}...\".format(subtitle_file))\n    with open(subtitle_file, encoding=\"utf-8\") as f:\n        file_data = json.load(f)\n    # Check Speakers\n    for id, text in file_data[\"speakers\"].items():\n        invalid_chars_exist, new_text = lint_jak1_characters(text)\n        if args.fix and new_text != text:\n            file_data[\"speakers\"][id] = new_text",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "text_files",
        "kind": 5,
        "importPath": "scripts.ci.lint-characters",
        "description": "scripts.ci.lint-characters",
        "peekOfCode": "text_files = glob.glob(\"./game/assets/jak2/text/*.json\")\nfor text_file in text_files:\n    print(\"Checking {}\".format(text_file))\n    with open(text_file, encoding=\"utf-8\") as f:\n        file_data = json.load(f)\n    for id, text in file_data.items():\n        invalid_chars_exist, new_text = lint_jak2_characters(text)\n        if args.fix:\n            file_data[id] = new_text\n        if invalid_chars_exist:",
        "detail": "scripts.ci.lint-characters",
        "documentation": {}
    },
    {
        "label": "patch_set",
        "kind": 5,
        "importPath": "scripts.ci.lint-gsrc-removals",
        "description": "scripts.ci.lint-gsrc-removals",
        "peekOfCode": "patch_set = unidiff.PatchSet.from_string(diff)\nflagged_deletions = []\nfor patched_file in patch_set:\n    file_path = patched_file.path\n    for hunk in patched_file:\n        for line in hunk:\n            if line.is_removed and \"og:preserve-this\" in line.value.strip():\n                flagged_deletions.append(\n                    {\n                        \"file\": file_path,",
        "detail": "scripts.ci.lint-gsrc-removals",
        "documentation": {}
    },
    {
        "label": "flagged_deletions",
        "kind": 5,
        "importPath": "scripts.ci.lint-gsrc-removals",
        "description": "scripts.ci.lint-gsrc-removals",
        "peekOfCode": "flagged_deletions = []\nfor patched_file in patch_set:\n    file_path = patched_file.path\n    for hunk in patched_file:\n        for line in hunk:\n            if line.is_removed and \"og:preserve-this\" in line.value.strip():\n                flagged_deletions.append(\n                    {\n                        \"file\": file_path,\n                        \"line_num\": line.source_line_no,",
        "detail": "scripts.ci.lint-gsrc-removals",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.ci.lint-trailing-whitespace",
        "description": "scripts.ci.lint-trailing-whitespace",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--fix\", action=\"store_true\")\nparser.set_defaults(fix=False)\nargs = parser.parse_args()\nfolders_to_check = [\"goal_src\"]\nflagged_instances = []\nfor folder in folders_to_check:\n  files_to_check = glob.glob(\"./{}/**/*.gc\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.gs\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.gd\".format(folder), recursive=True)",
        "detail": "scripts.ci.lint-trailing-whitespace",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.ci.lint-trailing-whitespace",
        "description": "scripts.ci.lint-trailing-whitespace",
        "peekOfCode": "args = parser.parse_args()\nfolders_to_check = [\"goal_src\"]\nflagged_instances = []\nfor folder in folders_to_check:\n  files_to_check = glob.glob(\"./{}/**/*.gc\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.gs\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.gd\".format(folder), recursive=True)\n  for filename in files_to_check:\n    # Get the file contents\n    with open(filename, \"r\", encoding=\"utf-8\") as f:",
        "detail": "scripts.ci.lint-trailing-whitespace",
        "documentation": {}
    },
    {
        "label": "folders_to_check",
        "kind": 5,
        "importPath": "scripts.ci.lint-trailing-whitespace",
        "description": "scripts.ci.lint-trailing-whitespace",
        "peekOfCode": "folders_to_check = [\"goal_src\"]\nflagged_instances = []\nfor folder in folders_to_check:\n  files_to_check = glob.glob(\"./{}/**/*.gc\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.gs\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.gd\".format(folder), recursive=True)\n  for filename in files_to_check:\n    # Get the file contents\n    with open(filename, \"r\", encoding=\"utf-8\") as f:\n      lines = f.readlines()",
        "detail": "scripts.ci.lint-trailing-whitespace",
        "documentation": {}
    },
    {
        "label": "flagged_instances",
        "kind": 5,
        "importPath": "scripts.ci.lint-trailing-whitespace",
        "description": "scripts.ci.lint-trailing-whitespace",
        "peekOfCode": "flagged_instances = []\nfor folder in folders_to_check:\n  files_to_check = glob.glob(\"./{}/**/*.gc\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.gs\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.gd\".format(folder), recursive=True)\n  for filename in files_to_check:\n    # Get the file contents\n    with open(filename, \"r\", encoding=\"utf-8\") as f:\n      lines = f.readlines()\n      lines_with_trailing_whitespace = [line.rstrip('\\n').endswith(' ') for line in lines]",
        "detail": "scripts.ci.lint-trailing-whitespace",
        "documentation": {}
    },
    {
        "label": "folders_to_check",
        "kind": 5,
        "importPath": "scripts.cpp.format-includes",
        "description": "scripts.cpp.format-includes",
        "peekOfCode": "folders_to_check = [\"common\", \"decompiler\", \"game\", \"goalc\", \"test\", \"tools\", \"lsp\"]\nfor folder in folders_to_check:\n  files_to_check = glob.glob(\"./{}/**/*.cpp\".format(folder), recursive=True)\n  files_to_check += glob.glob(\"./{}/**/*.h\".format(folder), recursive=True)\n  for filename in files_to_check:\n    # Get the file contents\n    with open(filename, \"r\", encoding=\"utf-8\") as f:\n      lines = f.readlines()\n      new_lines = []\n      need_to_write = False",
        "detail": "scripts.cpp.format-includes",
        "documentation": {}
    },
    {
        "label": "clientSocket",
        "kind": 5,
        "importPath": "scripts.examples.nrepl-test",
        "description": "scripts.examples.nrepl-test",
        "peekOfCode": "clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM);\nclientSocket.connect((\"127.0.0.1\", 8181))\nprint(clientSocket)\ndata = clientSocket.recv(1024)\nprint(data.decode())\nform = \"(:status)\"\nheader = struct.pack('<II', len(form), 10)\nclientSocket.sendall(header + form.encode())\nsleep(1)\nclientSocket.sendall(header + form.encode())",
        "detail": "scripts.examples.nrepl-test",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "scripts.examples.nrepl-test",
        "description": "scripts.examples.nrepl-test",
        "peekOfCode": "data = clientSocket.recv(1024)\nprint(data.decode())\nform = \"(:status)\"\nheader = struct.pack('<II', len(form), 10)\nclientSocket.sendall(header + form.encode())\nsleep(1)\nclientSocket.sendall(header + form.encode())",
        "detail": "scripts.examples.nrepl-test",
        "documentation": {}
    },
    {
        "label": "form",
        "kind": 5,
        "importPath": "scripts.examples.nrepl-test",
        "description": "scripts.examples.nrepl-test",
        "peekOfCode": "form = \"(:status)\"\nheader = struct.pack('<II', len(form), 10)\nclientSocket.sendall(header + form.encode())\nsleep(1)\nclientSocket.sendall(header + form.encode())",
        "detail": "scripts.examples.nrepl-test",
        "documentation": {}
    },
    {
        "label": "header",
        "kind": 5,
        "importPath": "scripts.examples.nrepl-test",
        "description": "scripts.examples.nrepl-test",
        "peekOfCode": "header = struct.pack('<II', len(form), 10)\nclientSocket.sendall(header + form.encode())\nsleep(1)\nclientSocket.sendall(header + form.encode())",
        "detail": "scripts.examples.nrepl-test",
        "documentation": {}
    },
    {
        "label": "AllTypesUpdateBlock",
        "kind": 6,
        "importPath": "scripts.gsrc.code_retention.all_types_retention",
        "description": "scripts.gsrc.code_retention.all_types_retention",
        "peekOfCode": "class AllTypesUpdateBlock:\n    def __init__(self):\n        self.data = []\n        self.file_name = \"\"\n        self.block_id = \"\"\n    def __str__(self):\n        return \"{}:{}:{}...\".format(self.file_name, self.block_id, self.data[0:20])\ndef update_alltypes_named_blocks(game_name):\n    block_dict = {}\n    # Step 1: Get the blocks",
        "detail": "scripts.gsrc.code_retention.all_types_retention",
        "documentation": {}
    },
    {
        "label": "update_alltypes_named_blocks",
        "kind": 2,
        "importPath": "scripts.gsrc.code_retention.all_types_retention",
        "description": "scripts.gsrc.code_retention.all_types_retention",
        "peekOfCode": "def update_alltypes_named_blocks(game_name):\n    block_dict = {}\n    # Step 1: Get the blocks\n    get_all_blocks(game_name, block_dict)\n    # Step 2: Update the blocks (group by file name to minimize file IO operations)\n    update_all_blocks(game_name, block_dict)\ndef get_all_blocks(game_name, block_dict):\n    with open(get_alltypes_path_from_game(game_name)) as f:\n        lines = f.readlines()\n        i = 0",
        "detail": "scripts.gsrc.code_retention.all_types_retention",
        "documentation": {}
    },
    {
        "label": "get_all_blocks",
        "kind": 2,
        "importPath": "scripts.gsrc.code_retention.all_types_retention",
        "description": "scripts.gsrc.code_retention.all_types_retention",
        "peekOfCode": "def get_all_blocks(game_name, block_dict):\n    with open(get_alltypes_path_from_game(game_name)) as f:\n        lines = f.readlines()\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if line.startswith(\";; +++\") and \":\" in line:\n                info = line.replace(\";; +++\", \"\")\n                file_name, block_id = info.split(\":\")\n                new_block = AllTypesUpdateBlock()",
        "detail": "scripts.gsrc.code_retention.all_types_retention",
        "documentation": {}
    },
    {
        "label": "update_all_blocks",
        "kind": 2,
        "importPath": "scripts.gsrc.code_retention.all_types_retention",
        "description": "scripts.gsrc.code_retention.all_types_retention",
        "peekOfCode": "def update_all_blocks(game_name, block_dict):\n    for file_name, blocks in block_dict.items():\n        # Get the file's lines\n        path = get_gsrc_path_from_filename(game_name, file_name)\n        lines = []\n        final_lines = []\n        with open(path) as f:\n            lines = f.readlines()\n        # Iterate through lines, (before ;; decomp begins) and update the blocks if we find them\n        i = 0",
        "detail": "scripts.gsrc.code_retention.all_types_retention",
        "documentation": {}
    },
    {
        "label": "is_line_start_of_form",
        "kind": 2,
        "importPath": "scripts.gsrc.code_retention.code_retention",
        "description": "scripts.gsrc.code_retention.code_retention",
        "peekOfCode": "def is_line_start_of_form(line):\n    if line.lstrip().startswith(\";\") or \"(when *debug-segment*\" in line:\n        return None\n    matches = re.search(r\"\\(\\s*([^\\s.]*)\\s+\", line)\n    if matches is not None:\n        return line\n    return None\ndef has_form_ended(stack, line):\n    # if the stack is empty, return true\n    line_before_comment = line.partition(\";\")[0]",
        "detail": "scripts.gsrc.code_retention.code_retention",
        "documentation": {}
    },
    {
        "label": "has_form_ended",
        "kind": 2,
        "importPath": "scripts.gsrc.code_retention.code_retention",
        "description": "scripts.gsrc.code_retention.code_retention",
        "peekOfCode": "def has_form_ended(stack, line):\n    # if the stack is empty, return true\n    line_before_comment = line.partition(\";\")[0]\n    for char in line_before_comment:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                # unbalanced parens?\n                return True",
        "detail": "scripts.gsrc.code_retention.code_retention",
        "documentation": {}
    },
    {
        "label": "get_md5_from_file",
        "kind": 2,
        "importPath": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "peekOfCode": "def get_md5_from_file(filename):\n  file_bytes = open(filename, \"rb\").read()\n  # Remove the last 16bytes of the data as it's 16-byte aligned\n  # if this is the only difference in the entire file, it is very likely identical\n  # but this data is potentially garbage\n  length_bytes = bytes([file_bytes[12], file_bytes[13], file_bytes[14], file_bytes[15]])\n  offset_to_truncate = int.from_bytes(length_bytes, \"little\")\n  bytes_chopped = len(file_bytes) - offset_to_truncate\n  file_bytes = file_bytes[:offset_to_truncate]\n  return [hashlib.md5(file_bytes).hexdigest(), bytes_chopped]",
        "detail": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "documentation": {}
    },
    {
        "label": "jak2_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "peekOfCode": "jak2_files = None\nimport json\nimport hashlib\ndef get_md5_from_file(filename):\n  file_bytes = open(filename, \"rb\").read()\n  # Remove the last 16bytes of the data as it's 16-byte aligned\n  # if this is the only difference in the entire file, it is very likely identical\n  # but this data is potentially garbage\n  length_bytes = bytes([file_bytes[12], file_bytes[13], file_bytes[14], file_bytes[15]])\n  offset_to_truncate = int.from_bytes(length_bytes, \"little\")",
        "detail": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "documentation": {}
    },
    {
        "label": "dgos",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "peekOfCode": "dgos = set()\nfor file in jak2_files:\n  for dgo in file[3]:\n    dgos.add(dgo.lower())\nimport glob\nfrom pathlib import Path\nobj_files = glob.glob(\"../../decompiler_out/jak2/raw_obj/*\")\nprint(len(obj_files))\n# Find all the files that have the same name, but a different prefix\npotentially_identical_files = {}",
        "detail": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "documentation": {}
    },
    {
        "label": "obj_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "peekOfCode": "obj_files = glob.glob(\"../../decompiler_out/jak2/raw_obj/*\")\nprint(len(obj_files))\n# Find all the files that have the same name, but a different prefix\npotentially_identical_files = {}\nprint(\"WARNING: Be aware of the NOTE below, double check the output that the assumption has not changed\")\nfor file in obj_files:\n  name = Path(file).stem\n  base_name = None\n  duplicate = False\n  for dgo in dgos:",
        "detail": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "documentation": {}
    },
    {
        "label": "potentially_identical_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "peekOfCode": "potentially_identical_files = {}\nprint(\"WARNING: Be aware of the NOTE below, double check the output that the assumption has not changed\")\nfor file in obj_files:\n  name = Path(file).stem\n  base_name = None\n  duplicate = False\n  for dgo in dgos:\n    if name.lower().endswith(\"-{}\".format(dgo)):\n      # some files have multiple dgos in the name\n      base_name_parts = []",
        "detail": "scripts.gsrc.skeleton_creation.check_for_identical_objs",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.generate_dgo_files",
        "description": "scripts.gsrc.skeleton_creation.generate_dgo_files",
        "peekOfCode": "parser = argparse.ArgumentParser(\"generate_dgo_files\")\nparser.add_argument(\"--game\", help=\"The name of the game\", type=str)\nparser.add_argument(\"--dgotxt\", help=\"Path to the dgo.txt file\", type=str)\nargs = parser.parse_args()\n# Read in the dgo.txt file\nwith open(args.dgotxt, \"r\") as f:\n  lines = f.readlines()[2:] # skip the first two lines, assumed to be a comment header and an empty line\n  # OpenGOAL still doesn't have a data serialization/deserialization format\n  # so read line by line, assuming each DGO is seperated by an empty line\n  current_dgo_name = None",
        "detail": "scripts.gsrc.skeleton_creation.generate_dgo_files",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.generate_dgo_files",
        "description": "scripts.gsrc.skeleton_creation.generate_dgo_files",
        "peekOfCode": "args = parser.parse_args()\n# Read in the dgo.txt file\nwith open(args.dgotxt, \"r\") as f:\n  lines = f.readlines()[2:] # skip the first two lines, assumed to be a comment header and an empty line\n  # OpenGOAL still doesn't have a data serialization/deserialization format\n  # so read line by line, assuming each DGO is seperated by an empty line\n  current_dgo_name = None\n  current_dgo_lines = []\n  current_o_files = []\n  for line in lines:",
        "detail": "scripts.gsrc.skeleton_creation.generate_dgo_files",
        "documentation": {}
    },
    {
        "label": "common_deps",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "description": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "peekOfCode": "common_deps = '(\"$OUT/obj/cty-guard-turret-button.o\")'\nignored_dgos = [\"ENGINE\", \"KERNEL\", \"ART\", \"COMMON\", \"GAME\", \"NO-XGO\"]\ndgos_encountered = set()\ndgos_handled = set()\njak2_files = None\nwith open(\"./goal_src/jak2/build/all_objs.json\", \"r\") as f:\n  jak2_files = json.load(f)\n# Enumerate the files, order is dictated by code files (version 3)\n# At the end we will fill in any dgos that weren't considerd \"required\"\nlines = []",
        "detail": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "documentation": {}
    },
    {
        "label": "ignored_dgos",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "description": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "peekOfCode": "ignored_dgos = [\"ENGINE\", \"KERNEL\", \"ART\", \"COMMON\", \"GAME\", \"NO-XGO\"]\ndgos_encountered = set()\ndgos_handled = set()\njak2_files = None\nwith open(\"./goal_src/jak2/build/all_objs.json\", \"r\") as f:\n  jak2_files = json.load(f)\n# Enumerate the files, order is dictated by code files (version 3)\n# At the end we will fill in any dgos that weren't considerd \"required\"\nlines = []\nfor file in jak2_files:",
        "detail": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "documentation": {}
    },
    {
        "label": "dgos_encountered",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "description": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "peekOfCode": "dgos_encountered = set()\ndgos_handled = set()\njak2_files = None\nwith open(\"./goal_src/jak2/build/all_objs.json\", \"r\") as f:\n  jak2_files = json.load(f)\n# Enumerate the files, order is dictated by code files (version 3)\n# At the end we will fill in any dgos that weren't considerd \"required\"\nlines = []\nfor file in jak2_files:\n  file_name = file[0]",
        "detail": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "documentation": {}
    },
    {
        "label": "dgos_handled",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "description": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "peekOfCode": "dgos_handled = set()\njak2_files = None\nwith open(\"./goal_src/jak2/build/all_objs.json\", \"r\") as f:\n  jak2_files = json.load(f)\n# Enumerate the files, order is dictated by code files (version 3)\n# At the end we will fill in any dgos that weren't considerd \"required\"\nlines = []\nfor file in jak2_files:\n  file_name = file[0]\n  version = file[2]",
        "detail": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "documentation": {}
    },
    {
        "label": "jak2_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "description": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "peekOfCode": "jak2_files = None\nwith open(\"./goal_src/jak2/build/all_objs.json\", \"r\") as f:\n  jak2_files = json.load(f)\n# Enumerate the files, order is dictated by code files (version 3)\n# At the end we will fill in any dgos that weren't considerd \"required\"\nlines = []\nfor file in jak2_files:\n  file_name = file[0]\n  version = file[2]\n  dgo_list = file[3]",
        "detail": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "documentation": {}
    },
    {
        "label": "lines",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "description": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "peekOfCode": "lines = []\nfor file in jak2_files:\n  file_name = file[0]\n  version = file[2]\n  dgo_list = file[3]\n  for dgo in dgo_list:\n    dgos_encountered.add(dgo)\n  if version == 3:\n    dgo = dgo_list[0]\n    if dgo.lower() not in dgos_handled and dgo not in ignored_dgos:",
        "detail": "scripts.gsrc.skeleton_creation.generate_dgo_proj",
        "documentation": {}
    },
    {
        "label": "level_name",
        "kind": 2,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "def level_name(file_meta):\n  dgos = file_meta[3]\n  # Handle files unique to one level\n  if dgos == [\"HIDEOUT\"] or dgos == [\"LHIPOUT\"] or dgos == [\"LTHRNOUT\"] or dgos == [\"LTRNTESS\"] or dgos == [\"LTRNKRKD\"]:\n    return \"levels/hideout\"\n  elif dgos == [\"ORACLE\"]:\n    return \"levels/city/oracle\"\n  elif dgos == [\"DEMO\"] or dgos == [\"DEMO\", \"TITLE\"]:\n    return \"levels/demo\"\n  elif dgos == [\"ONINTENT\"] or dgos == [\"LTENTOB\"] or dgos == [\"LTENTOUT\"]:",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "jak1_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "jak1_files = None\njak2_files = None\nimport json\nwith open('../../goal_src/jak1/build/all_objs.json', 'r') as f:\n  jak1_files = json.load(f)\nwith open('../../goal_src/jak2/build/all_objs.json', 'r') as f:\n  jak2_files = json.load(f)\nnum_replicated = 0\nnum_left = 0\nengine_files = {",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "jak2_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "jak2_files = None\nimport json\nwith open('../../goal_src/jak1/build/all_objs.json', 'r') as f:\n  jak1_files = json.load(f)\nwith open('../../goal_src/jak2/build/all_objs.json', 'r') as f:\n  jak2_files = json.load(f)\nnum_replicated = 0\nnum_left = 0\nengine_files = {\n  \"profile\": \"util\",",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "num_replicated",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "num_replicated = 0\nnum_left = 0\nengine_files = {\n  \"profile\": \"util\",\n  \"texture-anim\": \"gfx/texture\",\n  \"capture\": \"util\",\n  \"text-id\": \"ui\",\n  \"camera-defs\": \"camera\",\n  \"minimap\": \"ui\",\n  \"bigmap\": \"ui\",",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "num_left",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "num_left = 0\nengine_files = {\n  \"profile\": \"util\",\n  \"texture-anim\": \"gfx/texture\",\n  \"capture\": \"util\",\n  \"text-id\": \"ui\",\n  \"camera-defs\": \"camera\",\n  \"minimap\": \"ui\",\n  \"bigmap\": \"ui\",\n  \"blit-displays\": \"gfx\",",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "engine_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "engine_files = {\n  \"profile\": \"util\",\n  \"texture-anim\": \"gfx/texture\",\n  \"capture\": \"util\",\n  \"text-id\": \"ui\",\n  \"camera-defs\": \"camera\",\n  \"minimap\": \"ui\",\n  \"bigmap\": \"ui\",\n  \"blit-displays\": \"gfx\",\n  \"region\": \"level\",",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "path_overrides",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "path_overrides = {\n  \"hopper-ag\": \"levels/common/enemy\",\n  \"oracle\": \"levels/city/oracle\",\n  \"hopper\": \"levels/common/enemy\",\n  \"bouncer\": \"levels/common/enemy\",\n  \"yakow\": \"levels/city/farm\",\n  \"yakow-ag\": \"levels/city/farm\",\n  \"trail\": \"levels/city/common\",\n  \"village1-vis\": \"levels/jak1/village1\"\n}",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "remaining_dgos",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "remaining_dgos = {}\nfolders = {}\nfor jak2_file in jak2_files:\n  if jak2_file[3] == [\"NO-XGO\"]:\n    num_replicated = num_replicated + 1\n    continue\n  # manual overrides\n  if jak2_file[0] in path_overrides or jak2_file[0].removesuffix(\"-h\") in path_overrides:\n    num_replicated = num_replicated + 1\n    if jak2_file[0] in path_overrides:",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "folders",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "folders = {}\nfor jak2_file in jak2_files:\n  if jak2_file[3] == [\"NO-XGO\"]:\n    num_replicated = num_replicated + 1\n    continue\n  # manual overrides\n  if jak2_file[0] in path_overrides or jak2_file[0].removesuffix(\"-h\") in path_overrides:\n    num_replicated = num_replicated + 1\n    if jak2_file[0] in path_overrides:\n      jak2_file[4] = path_overrides[jak2_file[0]]",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "limit",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "peekOfCode": "limit = 0\nfor dgo_set in dict(sorted(remaining_dgos.items(), reverse=True, key=lambda item: item[1])):\n  dgo_set_nice = \"\"\n  for dgo in dgo_set.split(\",\"):\n    dgo_set_nice += \"\\\"{}\\\", \".format(dgo)\n  dgo_set_nice = dgo_set_nice.removesuffix(\", \")\n  print(\"or dgos == [{}]: {}\".format(dgo_set_nice, remaining_dgos[dgo_set]))\n  if limit > 100:\n    break\n  limit = limit + 1",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak2",
        "documentation": {}
    },
    {
        "label": "level_name",
        "kind": 2,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "def level_name(file_meta):\n  dgos = file_meta[3]\n  # Handle files unique to one level\n  if dgos == [\"DESA\"] or dgos == [\"DESB\"] or dgos == [\"DESC\"] or dgos == [\"DESD\"] or dgos == [\"DESE\"] or dgos == [\"DESF\"] or dgos == [\"DESG\"] or dgos == [\"DESH\"] or dgos == [\"DST\"] or dgos == [\"DESD\", \"WIN\"] or dgos == [\"LWASBBV\"] or dgos == [\"HGA\", \"WIN\", \"DST\"] or dgos == [\"LDESGCST\"] or dgos == [\"LWLANDM\"] or dgos == [\"WARPCAST\"]:\n    return \"levels/desert\"\n  elif dgos == [\"DESRACE2\", \"DESJUMP\", \"DESOASIS\", \"DESRESCG\", \"DESRACE1\", \"DESRALLY\", \"DESTRACK\", \"DESINTER\", \"DESCHASE\"] or dgos == [\"DESRACE2\", \"DESOASIS\", \"DESRESCG\", \"DESRACE1\", \"DESRALLY\", \"DESTRACK\", \"DESINTER\", \"DESCHASE\"] or dgos == [\"DESINTER\"]:\n      return \"levels/desert\"\n  elif dgos == [\"LBBRING1\"] or dgos == [\"LBBRING2\"] or dgos == [\"LBBRING3\"] or dgos == [\"LBBRING4\"] or dgos == [\"LBBRING5\"] or dgos == [\"LBBRING6\"] or dgos == [\"LBBSPID\"] or dgos == [\"LBBSPIRT\"] or dgos == [\"LBBSPRT2\"] or dgos == [\"LBBSPRT3\"]:\n    return \"levels/desert/bbush\"\n  elif dgos == [\"DESRALLY\"] or dgos == [\"DESTRACK\"] or dgos == [\"DESRALLY\", \"DESTRACK\"]:",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "jak2_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "jak2_files = None\njak3_files = None\nimport json\nwith open('../../../goal_src/jak2/build/all_objs.json', 'r') as f:\n  jak2_files = json.load(f)\nwith open('../../../goal_src/jak3/build/all_objs.json', 'r') as f:\n  jak3_files = json.load(f)\nnum_replicated = 0\nnum_left = 0\nengine_files = {",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "jak3_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "jak3_files = None\nimport json\nwith open('../../../goal_src/jak2/build/all_objs.json', 'r') as f:\n  jak2_files = json.load(f)\nwith open('../../../goal_src/jak3/build/all_objs.json', 'r') as f:\n  jak3_files = json.load(f)\nnum_replicated = 0\nnum_left = 0\nengine_files = {\n  \"profile\": \"util\",",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "num_replicated",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "num_replicated = 0\nnum_left = 0\nengine_files = {\n  \"profile\": \"util\",\n  \"texture-anim\": \"gfx/texture\",\n  \"capture\": \"util\",\n  \"text-id\": \"ui\",\n  \"camera-defs\": \"camera\",\n  \"minimap\": \"ui\",\n  \"bigmap\": \"ui\",",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "num_left",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "num_left = 0\nengine_files = {\n  \"profile\": \"util\",\n  \"texture-anim\": \"gfx/texture\",\n  \"capture\": \"util\",\n  \"text-id\": \"ui\",\n  \"camera-defs\": \"camera\",\n  \"minimap\": \"ui\",\n  \"bigmap\": \"ui\",\n  \"blit-displays\": \"gfx\",",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "engine_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "engine_files = {\n  \"profile\": \"util\",\n  \"texture-anim\": \"gfx/texture\",\n  \"capture\": \"util\",\n  \"text-id\": \"ui\",\n  \"camera-defs\": \"camera\",\n  \"minimap\": \"ui\",\n  \"bigmap\": \"ui\",\n  \"blit-displays\": \"gfx\",\n  \"region\": \"level\",",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "path_overrides",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "path_overrides = {\n  \"trail\": \"levels/city/common\",\n  \"tomb-baby-spider\": \"levels/temple\",\n  \"tomb-baby-spider-ag\": \"levels/temple\",\n  \"mhcity-obs\": \"levels/mhcity\",\n  \"mhcity-obs2\": \"levels/mhcity\",\n  \"mhcity-part\": \"levels/mhcity\",\n  \"race-control\": \"levels/common/race\",\n  \"rhino-ag\": \"levels/desert/wvehicle\",\n  \"mantis\": \"levels/common/enemy\",",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "remaining_dgos",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "remaining_dgos = {}\nfolders = {}\nfor jak3_file in jak3_files:\n  if jak3_file[3] == [\"NO-XGO\"]:\n    num_replicated = num_replicated + 1\n    continue\n  # manual overrides\n  if jak3_file[0] in path_overrides or jak3_file[0].removesuffix(\"-h\") in path_overrides:\n    num_replicated = num_replicated + 1\n    if jak3_file[0] in path_overrides:",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "folders",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "folders = {}\nfor jak3_file in jak3_files:\n  if jak3_file[3] == [\"NO-XGO\"]:\n    num_replicated = num_replicated + 1\n    continue\n  # manual overrides\n  if jak3_file[0] in path_overrides or jak3_file[0].removesuffix(\"-h\") in path_overrides:\n    num_replicated = num_replicated + 1\n    if jak3_file[0] in path_overrides:\n      jak3_file[4] = path_overrides[jak3_file[0]]",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "limit",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "description": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "peekOfCode": "limit = 0\nfor dgo_set in dict(sorted(remaining_dgos.items(), reverse=True, key=lambda item: item[1])):\n  dgo_set_nice = \"\"\n  for dgo in dgo_set.split(\",\"):\n    dgo_set_nice += \"\\\"{}\\\", \".format(dgo)\n  dgo_set_nice = dgo_set_nice.removesuffix(\", \")\n  print(\"or dgos == [{}]: {}\".format(dgo_set_nice, remaining_dgos[dgo_set]))\n  if limit > 100:\n    break\n  limit = limit + 1",
        "detail": "scripts.gsrc.skeleton_creation.init_folder_struct_jak3",
        "documentation": {}
    },
    {
        "label": "dgo_names_string",
        "kind": 2,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "peekOfCode": "def dgo_names_string(names):\n\tresult = \"\"\n\tfor x in names:\n\t\tresult += x + \", \"\n\tresult = result[:-2]\n\treturn result\ndef make_file(root, path, name, name_in_dgo, dgos, version):\n\tif version == 3:\n\t\tfilename = name + \".gc\"\n\t\ttext = \"\"\";;-*-Lisp-*-",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "documentation": {}
    },
    {
        "label": "make_file",
        "kind": 2,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "peekOfCode": "def make_file(root, path, name, name_in_dgo, dgos, version):\n\tif version == 3:\n\t\tfilename = name + \".gc\"\n\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)\n;; name: {}\n;; name in dgo: {}\n;; dgos: {}\n;; DECOMP BEGINS\n\"\"\".format(filename, name_in_dgo, dgo_names_string(dgos))",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "documentation": {}
    },
    {
        "label": "file_list",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "peekOfCode": "file_list = None\nwith open('../../goal_src/jak2/build/all_objs.json', 'r') as f:\n  file_list = json.load(f)\ndef dgo_names_string(names):\n\tresult = \"\"\n\tfor x in names:\n\t\tresult += x + \", \"\n\tresult = result[:-2]\n\treturn result\ndef make_file(root, path, name, name_in_dgo, dgos, version):",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "documentation": {}
    },
    {
        "label": "\tresult",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "peekOfCode": "\tresult = \"\"\n\tfor x in names:\n\t\tresult += x + \", \"\n\tresult = result[:-2]\n\treturn result\ndef make_file(root, path, name, name_in_dgo, dgos, version):\n\tif version == 3:\n\t\tfilename = name + \".gc\"\n\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "documentation": {}
    },
    {
        "label": "\tresult",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "peekOfCode": "\tresult = result[:-2]\n\treturn result\ndef make_file(root, path, name, name_in_dgo, dgos, version):\n\tif version == 3:\n\t\tfilename = name + \".gc\"\n\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)\n;; name: {}\n;; name in dgo: {}\n;; dgos: {}",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "documentation": {}
    },
    {
        "label": "\t\tfilename",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "peekOfCode": "\t\tfilename = name + \".gc\"\n\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)\n;; name: {}\n;; name in dgo: {}\n;; dgos: {}\n;; DECOMP BEGINS\n\"\"\".format(filename, name_in_dgo, dgo_names_string(dgos))\n\t\tPath(os.path.join(root, path)).mkdir(parents=True, exist_ok=True)\n\t\twith open(os.path.join(root, path, filename), \"w\") as f:",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "documentation": {}
    },
    {
        "label": "\t\ttext",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "peekOfCode": "\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)\n;; name: {}\n;; name in dgo: {}\n;; dgos: {}\n;; DECOMP BEGINS\n\"\"\".format(filename, name_in_dgo, dgo_names_string(dgos))\n\t\tPath(os.path.join(root, path)).mkdir(parents=True, exist_ok=True)\n\t\twith open(os.path.join(root, path, filename), \"w\") as f:\n\t\t\tf.write(text)",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files",
        "documentation": {}
    },
    {
        "label": "dgo_names_string",
        "kind": 2,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "peekOfCode": "def dgo_names_string(names):\n\tresult = \"\"\n\tfor x in names:\n\t\tresult += x + \", \"\n\tresult = result[:-2]\n\treturn result\ndef is_code_file(name, dgos):\n\treturn not name.endswith(\"-ag\") and not name.endswith(\"-vis\") and not name.startswith(\"tpage-\") and not name.endswith(\"COMMON\") and not dgos[0].lower() == name and not name.endswith(\"-tx\")\ndef make_file(root, path, name, name_in_dgo, dgos, version):\n\tif is_code_file(name, dgos):",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "documentation": {}
    },
    {
        "label": "is_code_file",
        "kind": 2,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "peekOfCode": "def is_code_file(name, dgos):\n\treturn not name.endswith(\"-ag\") and not name.endswith(\"-vis\") and not name.startswith(\"tpage-\") and not name.endswith(\"COMMON\") and not dgos[0].lower() == name and not name.endswith(\"-tx\")\ndef make_file(root, path, name, name_in_dgo, dgos, version):\n\tif is_code_file(name, dgos):\n\t\tfilename = name + \".gc\"\n\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)\n;; name: {}\n;; name in dgo: {}\n;; dgos: {}",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "documentation": {}
    },
    {
        "label": "make_file",
        "kind": 2,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "peekOfCode": "def make_file(root, path, name, name_in_dgo, dgos, version):\n\tif is_code_file(name, dgos):\n\t\tfilename = name + \".gc\"\n\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)\n;; name: {}\n;; name in dgo: {}\n;; dgos: {}\n;; DECOMP BEGINS\n\"\"\".format(filename, name_in_dgo, dgo_names_string(dgos))",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "documentation": {}
    },
    {
        "label": "file_list",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "peekOfCode": "file_list = None\nwith open('../../../goal_src/jak3/build/all_objs.json', 'r') as f:\n  file_list = json.load(f)\ndef dgo_names_string(names):\n\tresult = \"\"\n\tfor x in names:\n\t\tresult += x + \", \"\n\tresult = result[:-2]\n\treturn result\ndef is_code_file(name, dgos):",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "documentation": {}
    },
    {
        "label": "\tresult",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "peekOfCode": "\tresult = \"\"\n\tfor x in names:\n\t\tresult += x + \", \"\n\tresult = result[:-2]\n\treturn result\ndef is_code_file(name, dgos):\n\treturn not name.endswith(\"-ag\") and not name.endswith(\"-vis\") and not name.startswith(\"tpage-\") and not name.endswith(\"COMMON\") and not dgos[0].lower() == name and not name.endswith(\"-tx\")\ndef make_file(root, path, name, name_in_dgo, dgos, version):\n\tif is_code_file(name, dgos):\n\t\tfilename = name + \".gc\"",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "documentation": {}
    },
    {
        "label": "\tresult",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "peekOfCode": "\tresult = result[:-2]\n\treturn result\ndef is_code_file(name, dgos):\n\treturn not name.endswith(\"-ag\") and not name.endswith(\"-vis\") and not name.startswith(\"tpage-\") and not name.endswith(\"COMMON\") and not dgos[0].lower() == name and not name.endswith(\"-tx\")\ndef make_file(root, path, name, name_in_dgo, dgos, version):\n\tif is_code_file(name, dgos):\n\t\tfilename = name + \".gc\"\n\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)\n;; name: {}",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "documentation": {}
    },
    {
        "label": "\t\tfilename",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "peekOfCode": "\t\tfilename = name + \".gc\"\n\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)\n;; name: {}\n;; name in dgo: {}\n;; dgos: {}\n;; DECOMP BEGINS\n\"\"\".format(filename, name_in_dgo, dgo_names_string(dgos))\n\t\tPath(os.path.join(root, path)).mkdir(parents=True, exist_ok=True)\n\t\twith open(os.path.join(root, path, filename), \"w\") as f:",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "documentation": {}
    },
    {
        "label": "\t\ttext",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "description": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "peekOfCode": "\t\ttext = \"\"\";;-*-Lisp-*-\n(in-package goal)\n;; name: {}\n;; name in dgo: {}\n;; dgos: {}\n;; DECOMP BEGINS\n\"\"\".format(filename, name_in_dgo, dgo_names_string(dgos))\n\t\tPath(os.path.join(root, path)).mkdir(parents=True, exist_ok=True)\n\t\twith open(os.path.join(root, path, filename), \"w\") as f:\n\t\t\tf.write(text)",
        "detail": "scripts.gsrc.skeleton_creation.make_empty_obj_files_jak3",
        "documentation": {}
    },
    {
        "label": "basename_in_file_list",
        "kind": 2,
        "importPath": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "peekOfCode": "def basename_in_file_list(name):\n  for file in jak2_files:\n    if file[0] == name:\n      return True\n  return False\nfor file in jak2_files:\n  if file[0] in ignore_list:\n    jak2_files_cleaned.append(file)\n    continue\n  name = Path(file[0]).stem",
        "detail": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "documentation": {}
    },
    {
        "label": "jak2_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "peekOfCode": "jak2_files = None\nimport json\nfrom pathlib import Path\nwith open(\"../../goal_src/jak2/build/all_objs.json\", \"r\") as f:\n  jak2_files = json.load(f)\ndgos = set()\njak2_files_cleaned = []\nfor file in jak2_files:\n  for dgo in file[3]:\n    dgos.add(dgo.lower())",
        "detail": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "documentation": {}
    },
    {
        "label": "dgos",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "peekOfCode": "dgos = set()\njak2_files_cleaned = []\nfor file in jak2_files:\n  for dgo in file[3]:\n    dgos.add(dgo.lower())\nignore_list = [\n  \"dir-tpages-ART\",\n  \"dir-tpages-GAME\",\n  \"traffic-engine\",\n  \"onin-game\"",
        "detail": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "documentation": {}
    },
    {
        "label": "jak2_files_cleaned",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "peekOfCode": "jak2_files_cleaned = []\nfor file in jak2_files:\n  for dgo in file[3]:\n    dgos.add(dgo.lower())\nignore_list = [\n  \"dir-tpages-ART\",\n  \"dir-tpages-GAME\",\n  \"traffic-engine\",\n  \"onin-game\"\n]",
        "detail": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "documentation": {}
    },
    {
        "label": "ignore_list",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "peekOfCode": "ignore_list = [\n  \"dir-tpages-ART\",\n  \"dir-tpages-GAME\",\n  \"traffic-engine\",\n  \"onin-game\"\n]\nremoved_files = {}\ndef basename_in_file_list(name):\n  for file in jak2_files:\n    if file[0] == name:",
        "detail": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "documentation": {}
    },
    {
        "label": "removed_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "peekOfCode": "removed_files = {}\ndef basename_in_file_list(name):\n  for file in jak2_files:\n    if file[0] == name:\n      return True\n  return False\nfor file in jak2_files:\n  if file[0] in ignore_list:\n    jak2_files_cleaned.append(file)\n    continue",
        "detail": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "documentation": {}
    },
    {
        "label": "encountered_files",
        "kind": 5,
        "importPath": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "description": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "peekOfCode": "encountered_files = []\nfor file in jak2_files_cleaned:\n  if file[0] in removed_files:\n    dgos = removed_files[file[0]]\n    for dgo in file[3]:\n      dgos.add(dgo)\n    file[3] = dgos\n    encountered_files.append(removed_files)\nwith open('../../goal_src/jak2/build/all_objs.json', 'w') as json_file:\n  # hard-coded to maintain spacing to only diff lines that actually change",
        "detail": "scripts.gsrc.skeleton_creation.remove_identical_objs",
        "documentation": {}
    },
    {
        "label": "create_graph",
        "kind": 2,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "def create_graph(dependencies):\n    graph = nx.DiGraph()\n    for key, files in dependencies.items():\n        for file in files:\n            graph.add_edge(key, Path(file).stem)\n    return graph\ndef transitive_reduction(graph):\n    transitive_reduced_graph = nx.transitive_reduction(graph)\n    return transitive_reduced_graph\ngraph = create_graph(missing_requires)",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "transitive_reduction",
        "kind": 2,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "def transitive_reduction(graph):\n    transitive_reduced_graph = nx.transitive_reduction(graph)\n    return transitive_reduced_graph\ngraph = create_graph(missing_requires)\n# print(nx.find_cycle(graph)) DEBUGGING CYCLES\nreduced_graph = transitive_reduction(graph)\n# Convert reduced graph to dictionary\nreduced_dependencies = {}\nfor node, successors in reduced_graph.adjacency():\n    reduced_dependencies[node] = list(successors.keys())",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "macro_definitions",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "macro_definitions = {}\nvirtual_state_definitions = {}\n# find definitions\nfiles = glob.glob(\"../../goal_src/jak1/**/*.gc\", recursive=True)\nfor file in files:\n    with open(file, 'r') as f:\n        lines = f.readlines()\n        for line_no, line in enumerate(lines):\n            if line.lstrip().startswith(\"(defmacro \"):\n                name = line.split(\"(defmacro \")[1].split(\" \")[0]",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "virtual_state_definitions",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "virtual_state_definitions = {}\n# find definitions\nfiles = glob.glob(\"../../goal_src/jak1/**/*.gc\", recursive=True)\nfor file in files:\n    with open(file, 'r') as f:\n        lines = f.readlines()\n        for line_no, line in enumerate(lines):\n            if line.lstrip().startswith(\"(defmacro \"):\n                name = line.split(\"(defmacro \")[1].split(\" \")[0]\n                macro_definitions[name] = file",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "files",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "files = glob.glob(\"../../goal_src/jak1/**/*.gc\", recursive=True)\nfor file in files:\n    with open(file, 'r') as f:\n        lines = f.readlines()\n        for line_no, line in enumerate(lines):\n            if line.lstrip().startswith(\"(defmacro \"):\n                name = line.split(\"(defmacro \")[1].split(\" \")[0]\n                macro_definitions[name] = file\n            elif line.lstrip().startswith(\"(defstate \") and line_no + 1 < len(lines) and \":virtual #t\" in lines[line_no + 1]:\n                name = line.split(\"(defstate \")[1].split(\" \")[0]",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "output_file",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "output_file = \"jak1-missing-requires-final.json\"\nwith open(output_file, \"w\") as f:\n    json.dump(missing_requires, f, indent=2)\ndef create_graph(dependencies):\n    graph = nx.DiGraph()\n    for key, files in dependencies.items():\n        for file in files:\n            graph.add_edge(key, Path(file).stem)\n    return graph\ndef transitive_reduction(graph):",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "graph = create_graph(missing_requires)\n# print(nx.find_cycle(graph)) DEBUGGING CYCLES\nreduced_graph = transitive_reduction(graph)\n# Convert reduced graph to dictionary\nreduced_dependencies = {}\nfor node, successors in reduced_graph.adjacency():\n    reduced_dependencies[node] = list(successors.keys())\noutput_file = \"transitive_reduced_dependencies.json\"\nwith open(output_file, \"w\") as f:\n    json.dump(reduced_dependencies, f, indent=4)",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "reduced_graph",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "reduced_graph = transitive_reduction(graph)\n# Convert reduced graph to dictionary\nreduced_dependencies = {}\nfor node, successors in reduced_graph.adjacency():\n    reduced_dependencies[node] = list(successors.keys())\noutput_file = \"transitive_reduced_dependencies.json\"\nwith open(output_file, \"w\") as f:\n    json.dump(reduced_dependencies, f, indent=4)\nprint(f\"Transitive reduced dependencies written to {output_file}\")\n# Figure out packages by looking at .gd files",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "reduced_dependencies",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "reduced_dependencies = {}\nfor node, successors in reduced_graph.adjacency():\n    reduced_dependencies[node] = list(successors.keys())\noutput_file = \"transitive_reduced_dependencies.json\"\nwith open(output_file, \"w\") as f:\n    json.dump(reduced_dependencies, f, indent=4)\nprint(f\"Transitive reduced dependencies written to {output_file}\")\n# Figure out packages by looking at .gd files\nfile_bundles = {}\ngd_files = glob.glob(\"../../goal_src/jak1/**/*.gd\", recursive=True)",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "output_file",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "output_file = \"transitive_reduced_dependencies.json\"\nwith open(output_file, \"w\") as f:\n    json.dump(reduced_dependencies, f, indent=4)\nprint(f\"Transitive reduced dependencies written to {output_file}\")\n# Figure out packages by looking at .gd files\nfile_bundles = {}\ngd_files = glob.glob(\"../../goal_src/jak1/**/*.gd\", recursive=True)\nfor file in gd_files:\n    with open(file, 'r') as f:\n        lines = f.readlines()",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "file_bundles",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "file_bundles = {}\ngd_files = glob.glob(\"../../goal_src/jak1/**/*.gd\", recursive=True)\nfor file in gd_files:\n    with open(file, 'r') as f:\n        lines = f.readlines()\n        bundle_name = lines[0].replace(\"(\", \"\").replace(\")\", \"\").replace(\"\\\"\", \"\").strip()\n        for line_no, line in enumerate(lines):\n           if line_no == 0:\n              continue\n           stripped_line = line.replace(\"(\", \"\").replace(\")\", \"\").replace(\"\\\"\", \"\").strip()",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "gd_files",
        "kind": 5,
        "importPath": "scripts.gsrc.add-missing-requires",
        "description": "scripts.gsrc.add-missing-requires",
        "peekOfCode": "gd_files = glob.glob(\"../../goal_src/jak1/**/*.gd\", recursive=True)\nfor file in gd_files:\n    with open(file, 'r') as f:\n        lines = f.readlines()\n        bundle_name = lines[0].replace(\"(\", \"\").replace(\")\", \"\").replace(\"\\\"\", \"\").strip()\n        for line_no, line in enumerate(lines):\n           if line_no == 0:\n              continue\n           stripped_line = line.replace(\"(\", \"\").replace(\")\", \"\").replace(\"\\\"\", \"\").strip()\n           if '.o' in stripped_line:",
        "detail": "scripts.gsrc.add-missing-requires",
        "documentation": {}
    },
    {
        "label": "files_with_unresolved_conflicts",
        "kind": 5,
        "importPath": "scripts.gsrc.check-for-conflicts",
        "description": "scripts.gsrc.check-for-conflicts",
        "peekOfCode": "files_with_unresolved_conflicts = []\nfor dirpath, subdirs, files in os.walk(\"./goal_src\"):\n  for filename in files:\n    # Get the file contents\n    with open(os.path.join(dirpath, filename), \"r\") as f:\n      lines = f.readlines()\n      for line in lines:\n        if \"<<<<<<<\" in line:\n          files_with_unresolved_conflicts.append(os.path.join(dirpath, filename))\n          break",
        "detail": "scripts.gsrc.check-for-conflicts",
        "documentation": {}
    },
    {
        "label": "hash_file",
        "kind": 2,
        "importPath": "scripts.gsrc.compare-compilation-outputs",
        "description": "scripts.gsrc.compare-compilation-outputs",
        "peekOfCode": "def hash_file(filepath):\n    \"\"\"Returns the MD5 hash of the file.\"\"\"\n    hasher = hashlib.md5()\n    with open(filepath, 'rb') as f:\n        buf = f.read()\n        hasher.update(buf)\n    return hasher.hexdigest()\ndef compare_directories(base_dir, compare_dir):\n    \"\"\"Compares files in two directories based on their MD5 hash.\"\"\"\n    mismatched_files = []",
        "detail": "scripts.gsrc.compare-compilation-outputs",
        "documentation": {}
    },
    {
        "label": "compare_directories",
        "kind": 2,
        "importPath": "scripts.gsrc.compare-compilation-outputs",
        "description": "scripts.gsrc.compare-compilation-outputs",
        "peekOfCode": "def compare_directories(base_dir, compare_dir):\n    \"\"\"Compares files in two directories based on their MD5 hash.\"\"\"\n    mismatched_files = []\n    missing_files = []\n    # Iterate through files in the base directory\n    total_files = 0\n    for root, _, files in os.walk(base_dir):\n        for file in files:\n            if file == \".gitignore\":\n                continue",
        "detail": "scripts.gsrc.compare-compilation-outputs",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.gsrc.compare-compilation-outputs",
        "description": "scripts.gsrc.compare-compilation-outputs",
        "peekOfCode": "parser = argparse.ArgumentParser(\"compare-compilation-outputs\")\nparser.add_argument(\"--base\", help=\"The base branch directories\", type=str)\nparser.add_argument(\"--compare\", help=\"The potentially modified directories to compare\", type=str)\nparser.add_argument(\"--markdown\", help=\"The format to output results as a markdown file './comp-diff-report.md'\", action=\"store_true\")\nargs = parser.parse_args()\nto_markdown_file = False\nif args.markdown:\n    to_markdown_file = True\nmarkdown_lines = []\ndef hash_file(filepath):",
        "detail": "scripts.gsrc.compare-compilation-outputs",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.gsrc.compare-compilation-outputs",
        "description": "scripts.gsrc.compare-compilation-outputs",
        "peekOfCode": "args = parser.parse_args()\nto_markdown_file = False\nif args.markdown:\n    to_markdown_file = True\nmarkdown_lines = []\ndef hash_file(filepath):\n    \"\"\"Returns the MD5 hash of the file.\"\"\"\n    hasher = hashlib.md5()\n    with open(filepath, 'rb') as f:\n        buf = f.read()",
        "detail": "scripts.gsrc.compare-compilation-outputs",
        "documentation": {}
    },
    {
        "label": "to_markdown_file",
        "kind": 5,
        "importPath": "scripts.gsrc.compare-compilation-outputs",
        "description": "scripts.gsrc.compare-compilation-outputs",
        "peekOfCode": "to_markdown_file = False\nif args.markdown:\n    to_markdown_file = True\nmarkdown_lines = []\ndef hash_file(filepath):\n    \"\"\"Returns the MD5 hash of the file.\"\"\"\n    hasher = hashlib.md5()\n    with open(filepath, 'rb') as f:\n        buf = f.read()\n        hasher.update(buf)",
        "detail": "scripts.gsrc.compare-compilation-outputs",
        "documentation": {}
    },
    {
        "label": "markdown_lines",
        "kind": 5,
        "importPath": "scripts.gsrc.compare-compilation-outputs",
        "description": "scripts.gsrc.compare-compilation-outputs",
        "peekOfCode": "markdown_lines = []\ndef hash_file(filepath):\n    \"\"\"Returns the MD5 hash of the file.\"\"\"\n    hasher = hashlib.md5()\n    with open(filepath, 'rb') as f:\n        buf = f.read()\n        hasher.update(buf)\n    return hasher.hexdigest()\ndef compare_directories(base_dir, compare_dir):\n    \"\"\"Compares files in two directories based on their MD5 hash.\"\"\"",
        "detail": "scripts.gsrc.compare-compilation-outputs",
        "documentation": {}
    },
    {
        "label": "base_directory_list",
        "kind": 5,
        "importPath": "scripts.gsrc.compare-compilation-outputs",
        "description": "scripts.gsrc.compare-compilation-outputs",
        "peekOfCode": "base_directory_list = args.base.split(\",\")\ncompare_directory_list = args.compare.split(\",\")\nresult = 0\nfor base_dir, comp_dir in zip(base_directory_list, compare_directory_list):\n    latest_result = compare_directories(base_dir, comp_dir)\n    if latest_result != 0:\n        result = latest_result\nif to_markdown_file:\n    with open('./comp-diff-report.md', 'w', encoding='utf-8') as md_file:\n        md_file.writelines(markdown_lines)",
        "detail": "scripts.gsrc.compare-compilation-outputs",
        "documentation": {}
    },
    {
        "label": "compare_directory_list",
        "kind": 5,
        "importPath": "scripts.gsrc.compare-compilation-outputs",
        "description": "scripts.gsrc.compare-compilation-outputs",
        "peekOfCode": "compare_directory_list = args.compare.split(\",\")\nresult = 0\nfor base_dir, comp_dir in zip(base_directory_list, compare_directory_list):\n    latest_result = compare_directories(base_dir, comp_dir)\n    if latest_result != 0:\n        result = latest_result\nif to_markdown_file:\n    with open('./comp-diff-report.md', 'w', encoding='utf-8') as md_file:\n        md_file.writelines(markdown_lines)\n        print(\"Wrote results to ./comp-diff-report.md\")",
        "detail": "scripts.gsrc.compare-compilation-outputs",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "scripts.gsrc.compare-compilation-outputs",
        "description": "scripts.gsrc.compare-compilation-outputs",
        "peekOfCode": "result = 0\nfor base_dir, comp_dir in zip(base_directory_list, compare_directory_list):\n    latest_result = compare_directories(base_dir, comp_dir)\n    if latest_result != 0:\n        result = latest_result\nif to_markdown_file:\n    with open('./comp-diff-report.md', 'w', encoding='utf-8') as md_file:\n        md_file.writelines(markdown_lines)\n        print(\"Wrote results to ./comp-diff-report.md\")\nexit(result)",
        "detail": "scripts.gsrc.compare-compilation-outputs",
        "documentation": {}
    },
    {
        "label": "find_all_function_defs",
        "kind": 2,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "def find_all_function_defs(lines):\n  store = {}\n  in_function_def = False\n  in_docstring = False\n  passed_potential_docstring = False\n  current_function_name = None\n  for line in lines:\n    if line.startswith(\"; .function\") and \"top-level\" not in line:\n      current_function_name = line.split(\".function\")[1].strip()\n      store[current_function_name] = {",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "get_var_casts_for_game",
        "kind": 2,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "def get_var_casts_for_game(game_name):\n  return json.load(open(\"./decompiler/config/{}/ntsc_v1/var_names.jsonc\".format(game_name), \"r\"))\ndef save_var_casts_for_game(game_name, casts):\n  with open(\"./decompiler/config/{}/ntsc_v1/var_names.jsonc\".format(game_name), \"w\") as f:\n    json.dump(casts, f, indent=2)\ndef get_all_types_for_game(game_name):\n  return open(\"./decompiler/config/{}/all-types.gc\".format(game_name), \"r\").readlines()\njak2_alltypes = get_all_types_for_game(\"jak2\")\njak3_alltypes = get_all_types_for_game(\"jak3\")\nfile_stats = \"\"",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "save_var_casts_for_game",
        "kind": 2,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "def save_var_casts_for_game(game_name, casts):\n  with open(\"./decompiler/config/{}/ntsc_v1/var_names.jsonc\".format(game_name), \"w\") as f:\n    json.dump(casts, f, indent=2)\ndef get_all_types_for_game(game_name):\n  return open(\"./decompiler/config/{}/all-types.gc\".format(game_name), \"r\").readlines()\njak2_alltypes = get_all_types_for_game(\"jak2\")\njak3_alltypes = get_all_types_for_game(\"jak3\")\nfile_stats = \"\"\ndef update_file_var_name_casts(file_name, modify_alltypes):\n  global file_stats",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "get_all_types_for_game",
        "kind": 2,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "def get_all_types_for_game(game_name):\n  return open(\"./decompiler/config/{}/all-types.gc\".format(game_name), \"r\").readlines()\njak2_alltypes = get_all_types_for_game(\"jak2\")\njak3_alltypes = get_all_types_for_game(\"jak3\")\nfile_stats = \"\"\ndef update_file_var_name_casts(file_name, modify_alltypes):\n  global file_stats\n  # Check if the file exists in both games\n  if not is_file_in_game(\"jak3\", file_name) or not is_file_in_game(\"jak2\", file_name):\n    print(\"File not found in both games\")",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "update_file_var_name_casts",
        "kind": 2,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "def update_file_var_name_casts(file_name, modify_alltypes):\n  global file_stats\n  # Check if the file exists in both games\n  if not is_file_in_game(\"jak3\", file_name) or not is_file_in_game(\"jak2\", file_name):\n    print(\"File not found in both games\")\n    return\n  # Decompile the file for both games\n  decompile_file(args.decompiler, \"jak3/jak3_config.jsonc\", \"ntsc_v1\", \"[\\\"{}\\\"]\".format(file_name), True)\n  decompile_file(args.decompiler, \"jak2/jak2_config.jsonc\", \"ntsc_v1\", \"[\\\"{}\\\"]\".format(file_name), True)\n  # Go grab the contents of each file",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "get_type_docstrings_from_alltypes",
        "kind": 2,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "def get_type_docstrings_from_alltypes(lines):\n  store = {}\n  awaiting_next_docstring = True\n  current_type_name = None\n  for line in lines:\n    if line.startswith(\"(deftype\"):\n      current_type_name = line.split(\"deftype \")[1].split(\"(\")[0].strip()\n      awaiting_next_docstring = False\n      store[current_type_name] = []\n      continue",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "get_all_types_for_game",
        "kind": 2,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "def get_all_types_for_game(game_name, lines):\n  with open(\"./decompiler/config/{}/all-types.gc\".format(game_name), \"w\") as f:\n    f.writelines(lines)\nget_all_types_for_game(\"jak2\", jak2_alltypes)\nget_all_types_for_game(\"jak3\", jak3_alltypes)",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "parser = argparse.ArgumentParser(\"copy-common-naming\")\nparser.add_argument(\"--file\", help=\"The name of the file\", type=str)\nparser.add_argument(\"--decompiler\", help=\"The path to the decompiler\", type=str)\nparser.add_argument(\"--update-names-from-refs\", help=\"The decomp config version\", action='store_true')\nargs = parser.parse_args()\ndef find_all_function_defs(lines):\n  store = {}\n  in_function_def = False\n  in_docstring = False\n  passed_potential_docstring = False",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "args = parser.parse_args()\ndef find_all_function_defs(lines):\n  store = {}\n  in_function_def = False\n  in_docstring = False\n  passed_potential_docstring = False\n  current_function_name = None\n  for line in lines:\n    if line.startswith(\"; .function\") and \"top-level\" not in line:\n      current_function_name = line.split(\".function\")[1].strip()",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "jak2_alltypes",
        "kind": 5,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "jak2_alltypes = get_all_types_for_game(\"jak2\")\njak3_alltypes = get_all_types_for_game(\"jak3\")\nfile_stats = \"\"\ndef update_file_var_name_casts(file_name, modify_alltypes):\n  global file_stats\n  # Check if the file exists in both games\n  if not is_file_in_game(\"jak3\", file_name) or not is_file_in_game(\"jak2\", file_name):\n    print(\"File not found in both games\")\n    return\n  # Decompile the file for both games",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "jak3_alltypes",
        "kind": 5,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "jak3_alltypes = get_all_types_for_game(\"jak3\")\nfile_stats = \"\"\ndef update_file_var_name_casts(file_name, modify_alltypes):\n  global file_stats\n  # Check if the file exists in both games\n  if not is_file_in_game(\"jak3\", file_name) or not is_file_in_game(\"jak2\", file_name):\n    print(\"File not found in both games\")\n    return\n  # Decompile the file for both games\n  decompile_file(args.decompiler, \"jak3/jak3_config.jsonc\", \"ntsc_v1\", \"[\\\"{}\\\"]\".format(file_name), True)",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "file_stats",
        "kind": 5,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "file_stats = \"\"\ndef update_file_var_name_casts(file_name, modify_alltypes):\n  global file_stats\n  # Check if the file exists in both games\n  if not is_file_in_game(\"jak3\", file_name) or not is_file_in_game(\"jak2\", file_name):\n    print(\"File not found in both games\")\n    return\n  # Decompile the file for both games\n  decompile_file(args.decompiler, \"jak3/jak3_config.jsonc\", \"ntsc_v1\", \"[\\\"{}\\\"]\".format(file_name), True)\n  decompile_file(args.decompiler, \"jak2/jak2_config.jsonc\", \"ntsc_v1\", \"[\\\"{}\\\"]\".format(file_name), True)",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "jak2_type_docs",
        "kind": 5,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "jak2_type_docs = get_type_docstrings_from_alltypes(jak2_alltypes)\njak3_type_docs = get_type_docstrings_from_alltypes(jak3_alltypes)\n# If a docstring exists in jak3 but not in jak2, copy it back\nnew_jak2_alltypes = []\nfor line_no, line in enumerate(jak2_alltypes):\n  line = jak2_alltypes[line_no]\n  new_jak2_alltypes.append(line)\n  if line.startswith(\"(deftype \"):\n    current_type_name = line.split(\"deftype \")[1].split(\"(\")[0].strip()\n    if current_type_name in jak3_type_docs and len(jak2_type_docs[current_type_name]) == 0:",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "jak3_type_docs",
        "kind": 5,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "jak3_type_docs = get_type_docstrings_from_alltypes(jak3_alltypes)\n# If a docstring exists in jak3 but not in jak2, copy it back\nnew_jak2_alltypes = []\nfor line_no, line in enumerate(jak2_alltypes):\n  line = jak2_alltypes[line_no]\n  new_jak2_alltypes.append(line)\n  if line.startswith(\"(deftype \"):\n    current_type_name = line.split(\"deftype \")[1].split(\"(\")[0].strip()\n    if current_type_name in jak3_type_docs and len(jak2_type_docs[current_type_name]) == 0:\n      for docstring_line in jak3_type_docs[current_type_name]:",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "new_jak2_alltypes",
        "kind": 5,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "new_jak2_alltypes = []\nfor line_no, line in enumerate(jak2_alltypes):\n  line = jak2_alltypes[line_no]\n  new_jak2_alltypes.append(line)\n  if line.startswith(\"(deftype \"):\n    current_type_name = line.split(\"deftype \")[1].split(\"(\")[0].strip()\n    if current_type_name in jak3_type_docs and len(jak2_type_docs[current_type_name]) == 0:\n      for docstring_line in jak3_type_docs[current_type_name]:\n        new_jak2_alltypes.append(\"  \" + docstring_line + \"\\n\")\njak2_alltypes = new_jak2_alltypes",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "jak2_alltypes",
        "kind": 5,
        "importPath": "scripts.gsrc.copy-common-naming",
        "description": "scripts.gsrc.copy-common-naming",
        "peekOfCode": "jak2_alltypes = new_jak2_alltypes\n# Save all-types\ndef get_all_types_for_game(game_name, lines):\n  with open(\"./decompiler/config/{}/all-types.gc\".format(game_name), \"w\") as f:\n    f.writelines(lines)\nget_all_types_for_game(\"jak2\", jak2_alltypes)\nget_all_types_for_game(\"jak3\", jak3_alltypes)",
        "detail": "scripts.gsrc.copy-common-naming",
        "documentation": {}
    },
    {
        "label": "file_list",
        "kind": 5,
        "importPath": "scripts.gsrc.find-missing-refs",
        "description": "scripts.gsrc.find-missing-refs",
        "peekOfCode": "file_list = get_file_list(\"jak2\")\n# TODO - function for getting just the names\nmissing_files = []\nfor file in file_list:\n  file_name = \"\"\n  if file[2] != 3:\n    continue\n  else:\n    file_name = file[0]\n  # check gsrc",
        "detail": "scripts.gsrc.find-missing-refs",
        "documentation": {}
    },
    {
        "label": "missing_files",
        "kind": 5,
        "importPath": "scripts.gsrc.find-missing-refs",
        "description": "scripts.gsrc.find-missing-refs",
        "peekOfCode": "missing_files = []\nfor file in file_list:\n  file_name = \"\"\n  if file[2] != 3:\n    continue\n  else:\n    file_name = file[0]\n  # check gsrc\n  gsrc_path = get_gsrc_path_from_filename(\"jak2\", file_name)\n  if gsrc_path:",
        "detail": "scripts.gsrc.find-missing-refs",
        "documentation": {}
    },
    {
        "label": "format_the_file",
        "kind": 2,
        "importPath": "scripts.gsrc.format-gsrc-file",
        "description": "scripts.gsrc.format-gsrc-file",
        "peekOfCode": "def format_the_file(apply_status):\n    with open(\"./scripts/gsrc/format-jak1.json\", \"r\") as f:\n        formatting_progress = json.load(f)\n    # find the next file\n    curr_file = None\n    go_to_next = False\n    open_file_in_vscode = False\n    if apply_status == \"next\":\n        go_to_next = True\n        open_file_in_vscode = True",
        "detail": "scripts.gsrc.format-gsrc-file",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.gsrc.format-gsrc-file",
        "description": "scripts.gsrc.format-gsrc-file",
        "peekOfCode": "def main():\n    while True:\n        user_input = input(Fore.CYAN + \"Type 'n' to proceed to the next file or just hit enter to re-format the current file: \" + Fore.RESET)\n        if user_input == 'n':\n            format_the_file(\"next\")\n        else:\n            format_the_file(None)\nif __name__ == \"__main__\":\n    main()",
        "detail": "scripts.gsrc.format-gsrc-file",
        "documentation": {}
    },
    {
        "label": "files",
        "kind": 5,
        "importPath": "scripts.gsrc.format-gsrc-folder",
        "description": "scripts.gsrc.format-gsrc-folder",
        "peekOfCode": "files = glob.glob(\"./goal_src/jak1/**/*.gc\", recursive=True)\ntotal_ms = 0\nfor file in files:\n    start_time = time.perf_counter()\n    subprocess.run([\"./out/build/Release/bin/formatter\", \"--write\", \"--file\", file])\n    elapsed_ms = (time.perf_counter() - start_time) * 1000\n    total_ms = total_ms + elapsed_ms\n    print(f\"Formatted .../{Path(file).stem} in {Fore.CYAN} {elapsed_ms:.2f}ms {Fore.RESET}\")\nprint(f\"In total that took {total_ms}ms for {len(files)} files!\")\nsubprocess.run([\"git\", \"diff\", \"--shortstat\", \"origin/master\"])",
        "detail": "scripts.gsrc.format-gsrc-folder",
        "documentation": {}
    },
    {
        "label": "total_ms",
        "kind": 5,
        "importPath": "scripts.gsrc.format-gsrc-folder",
        "description": "scripts.gsrc.format-gsrc-folder",
        "peekOfCode": "total_ms = 0\nfor file in files:\n    start_time = time.perf_counter()\n    subprocess.run([\"./out/build/Release/bin/formatter\", \"--write\", \"--file\", file])\n    elapsed_ms = (time.perf_counter() - start_time) * 1000\n    total_ms = total_ms + elapsed_ms\n    print(f\"Formatted .../{Path(file).stem} in {Fore.CYAN} {elapsed_ms:.2f}ms {Fore.RESET}\")\nprint(f\"In total that took {total_ms}ms for {len(files)} files!\")\nsubprocess.run([\"git\", \"diff\", \"--shortstat\", \"origin/master\"])",
        "detail": "scripts.gsrc.format-gsrc-folder",
        "documentation": {}
    },
    {
        "label": "check_return_value",
        "kind": 2,
        "importPath": "scripts.gsrc.jak1-sprite-adjustments",
        "description": "scripts.gsrc.jak1-sprite-adjustments",
        "peekOfCode": "def check_return_value(aspect_ratio, coefs):\n    return coefs[0] + coefs[1] * aspect_ratio + coefs[2] * aspect_ratio**2\nfor adjust in adjustments:\n    # collect the values\n    data_values = []\n    for dataset in values:\n        data_values.append(dataset[adjust])\n    np_values = np.array(data_values)\n    # polynomial regression to interpolate between values\n    poly = Polynomial.fit(aspect_ratios, np_values, 3)",
        "detail": "scripts.gsrc.jak1-sprite-adjustments",
        "documentation": {}
    },
    {
        "label": "values",
        "kind": 5,
        "importPath": "scripts.gsrc.jak1-sprite-adjustments",
        "description": "scripts.gsrc.jak1-sprite-adjustments",
        "peekOfCode": "values = [\n    {\n        'aspect': 1.00,\n        'left': 20,\n        'right': -33,\n        'cross-x': -20.0,\n        'cross-y': -20.0,\n        'square-x': -5.0,\n        'square-y': -10.0,\n        'triangle-x': 0.0,",
        "detail": "scripts.gsrc.jak1-sprite-adjustments",
        "documentation": {}
    },
    {
        "label": "adjustments",
        "kind": 5,
        "importPath": "scripts.gsrc.jak1-sprite-adjustments",
        "description": "scripts.gsrc.jak1-sprite-adjustments",
        "peekOfCode": "adjustments = [\n    'left', 'right', 'cross-x', 'cross-y', 'square-x', 'square-y', 'triangle-x', 'triangle-y', 'circle-x', 'circle-y', 'percent-x', 'autosave-x', 'orb-x', 'orb-glow-x', 'orb-text-x', 'cell-x', 'cell-text-x', 'buzzer-text-x', 'options-text-x'\n]\naspect_ratio_values = []\nfor dataset in values:\n    aspect_ratio_values.append(dataset['aspect'])\naspect_ratios = np.array(aspect_ratio_values)\ndef check_return_value(aspect_ratio, coefs):\n    return coefs[0] + coefs[1] * aspect_ratio + coefs[2] * aspect_ratio**2\nfor adjust in adjustments:",
        "detail": "scripts.gsrc.jak1-sprite-adjustments",
        "documentation": {}
    },
    {
        "label": "aspect_ratio_values",
        "kind": 5,
        "importPath": "scripts.gsrc.jak1-sprite-adjustments",
        "description": "scripts.gsrc.jak1-sprite-adjustments",
        "peekOfCode": "aspect_ratio_values = []\nfor dataset in values:\n    aspect_ratio_values.append(dataset['aspect'])\naspect_ratios = np.array(aspect_ratio_values)\ndef check_return_value(aspect_ratio, coefs):\n    return coefs[0] + coefs[1] * aspect_ratio + coefs[2] * aspect_ratio**2\nfor adjust in adjustments:\n    # collect the values\n    data_values = []\n    for dataset in values:",
        "detail": "scripts.gsrc.jak1-sprite-adjustments",
        "documentation": {}
    },
    {
        "label": "aspect_ratios",
        "kind": 5,
        "importPath": "scripts.gsrc.jak1-sprite-adjustments",
        "description": "scripts.gsrc.jak1-sprite-adjustments",
        "peekOfCode": "aspect_ratios = np.array(aspect_ratio_values)\ndef check_return_value(aspect_ratio, coefs):\n    return coefs[0] + coefs[1] * aspect_ratio + coefs[2] * aspect_ratio**2\nfor adjust in adjustments:\n    # collect the values\n    data_values = []\n    for dataset in values:\n        data_values.append(dataset[adjust])\n    np_values = np.array(data_values)\n    # polynomial regression to interpolate between values",
        "detail": "scripts.gsrc.jak1-sprite-adjustments",
        "documentation": {}
    },
    {
        "label": "LintMatch",
        "kind": 6,
        "importPath": "scripts.gsrc.lint-gsrc-file",
        "description": "scripts.gsrc.lint-gsrc-file",
        "peekOfCode": "class LintMatch:\n    def __init__(self, src_path, offending_lineno, context):\n        self.src_path = src_path\n        self.offending_lineno = offending_lineno\n        self.context = context\n    def __str__(self):\n        output = (\n            Style.BRIGHT\n            + Fore.MAGENTA\n            + \"@ {}:{}\\n\".format(self.src_path, self.offending_lineno)",
        "detail": "scripts.gsrc.lint-gsrc-file",
        "documentation": {}
    },
    {
        "label": "LinterRule",
        "kind": 6,
        "importPath": "scripts.gsrc.lint-gsrc-file",
        "description": "scripts.gsrc.lint-gsrc-file",
        "peekOfCode": "class LinterRule:\n    def __init__(self, level, rule_name, regex_pattern, context_size):\n        self.level = level\n        self.rule_name = rule_name\n        self.regex_pattern = regex_pattern\n        self.context_size = context_size\n        self.matches = []\n    def __str__(self):\n        level_color = Fore.LIGHTBLUE_EX\n        if self.level == \"WARN\":",
        "detail": "scripts.gsrc.lint-gsrc-file",
        "documentation": {}
    },
    {
        "label": "get_context",
        "kind": 2,
        "importPath": "scripts.gsrc.lint-gsrc-file",
        "description": "scripts.gsrc.lint-gsrc-file",
        "peekOfCode": "def get_context(lines, match_span, idx, amount_inclusive):\n    lines_grabbed = []\n    # Strip left pad, while maintaining indent\n    last_line_indent_width = -1\n    last_line_indent = -1\n    while len(lines_grabbed) < amount_inclusive and len(lines) > idx + len(\n        lines_grabbed\n    ):\n        # TODO - first line, colorize the match\n        # if len(lines_grabbed) == 0:",
        "detail": "scripts.gsrc.lint-gsrc-file",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.gsrc.lint-gsrc-file",
        "description": "scripts.gsrc.lint-gsrc-file",
        "peekOfCode": "parser = argparse.ArgumentParser(\"lint-gsrc-file\")\nparser.add_argument(\"--game\", help=\"The name of the game\", type=str)\nparser.add_argument(\"--file\", help=\"The name of the file\", type=str)\nargs = parser.parse_args()\nclass LintMatch:\n    def __init__(self, src_path, offending_lineno, context):\n        self.src_path = src_path\n        self.offending_lineno = offending_lineno\n        self.context = context\n    def __str__(self):",
        "detail": "scripts.gsrc.lint-gsrc-file",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.gsrc.lint-gsrc-file",
        "description": "scripts.gsrc.lint-gsrc-file",
        "peekOfCode": "args = parser.parse_args()\nclass LintMatch:\n    def __init__(self, src_path, offending_lineno, context):\n        self.src_path = src_path\n        self.offending_lineno = offending_lineno\n        self.context = context\n    def __str__(self):\n        output = (\n            Style.BRIGHT\n            + Fore.MAGENTA",
        "detail": "scripts.gsrc.lint-gsrc-file",
        "documentation": {}
    },
    {
        "label": "linter_rules",
        "kind": 5,
        "importPath": "scripts.gsrc.lint-gsrc-file",
        "description": "scripts.gsrc.lint-gsrc-file",
        "peekOfCode": "linter_rules = []\n# Infos\n# Warnings\nlinter_rules.append(\n    LinterRule(\"WARN\", \"method_splits\", re.compile(\"method-of-(?:type|object)\"), 3)\n)\nlinter_rules.append(\n    LinterRule(\"WARN\", \"func_splits\", re.compile(\"\\(t9-\\d+(?:\\s+[^\\s]+\\s*)?\\)\"), 3)\n)\nlinter_rules.append(",
        "detail": "scripts.gsrc.lint-gsrc-file",
        "documentation": {}
    },
    {
        "label": "src_path",
        "kind": 5,
        "importPath": "scripts.gsrc.lint-gsrc-file",
        "description": "scripts.gsrc.lint-gsrc-file",
        "peekOfCode": "src_path = get_gsrc_path_from_filename(args.game, args.file)\n# Iterate through the file line by line, check against each rule\n# if the rule is violated (it matches) then we append the match with useful details\nprint(\"Linting GOAL_SRC File...\")\ndef get_context(lines, match_span, idx, amount_inclusive):\n    lines_grabbed = []\n    # Strip left pad, while maintaining indent\n    last_line_indent_width = -1\n    last_line_indent = -1\n    while len(lines_grabbed) < amount_inclusive and len(lines) > idx + len(",
        "detail": "scripts.gsrc.lint-gsrc-file",
        "documentation": {}
    },
    {
        "label": "throw_error",
        "kind": 5,
        "importPath": "scripts.gsrc.lint-gsrc-file",
        "description": "scripts.gsrc.lint-gsrc-file",
        "peekOfCode": "throw_error = False\nfor rule in linter_rules:\n    # Iterate through violations\n    if len(rule.matches) > 0:\n        print(rule)\n        for match in rule.matches:\n            if rule.level == \"ERROR\" or rule.level == \"WARN\":\n                throw_error = True\n            print(match)\nif throw_error:",
        "detail": "scripts.gsrc.lint-gsrc-file",
        "documentation": {}
    },
    {
        "label": "should_ignore_line",
        "kind": 2,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "def should_ignore_line(line):\n    for ignore_line in lines_to_ignore:\n        if line.lower().startswith(ignore_line.lower()):\n            return True\n    return False\n# TODO - ignore brackets inside strings!\ndecomp_file_path = \"./decompiler_out/{}/{}_disasm.gc\".format(args.game, args.file)\nwith open(decomp_file_path) as f:\n    lines = f.readlines()\n    i = 0",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "parser = argparse.ArgumentParser(\"update-from-decomp\")\nparser.add_argument(\"--game\", help=\"The name of the game\", type=str)\nparser.add_argument(\"--file\", help=\"The name of the file\", type=str)\nparser.add_argument(\n    \"--debug\", help=\"Output debug metadata on every block\", action=\"store_true\"\n)\nparser.add_argument(\n    \"--clearDebug\", help=\"Clear debug metadata\", action=\"store_true\"\n)  # TODO - implement!\nargs = parser.parse_args()",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "args = parser.parse_args()\ngsrc_path = get_gsrc_path_from_filename(args.game, args.file)\n# Step 1 - Find and update all named blocks from all-types (useful for enums)\nupdate_alltypes_named_blocks(args.game)\ncomments = []\ndebug_lines = []\ndecomp_ignore_forms = [\"defmethod inspect\"]\ndecomp_ignore_errors = False\nwith open(gsrc_path) as f:\n    lines_temp = f.readlines()",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "gsrc_path",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "gsrc_path = get_gsrc_path_from_filename(args.game, args.file)\n# Step 1 - Find and update all named blocks from all-types (useful for enums)\nupdate_alltypes_named_blocks(args.game)\ncomments = []\ndebug_lines = []\ndecomp_ignore_forms = [\"defmethod inspect\"]\ndecomp_ignore_errors = False\nwith open(gsrc_path) as f:\n    lines_temp = f.readlines()\n    lines = []",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "comments",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "comments = []\ndebug_lines = []\ndecomp_ignore_forms = [\"defmethod inspect\"]\ndecomp_ignore_errors = False\nwith open(gsrc_path) as f:\n    lines_temp = f.readlines()\n    lines = []\n    # Get rid of debug lines, this is so i can re-run without having to reset the file\n    for line in lines_temp:\n        if \"[DEBUG]\" in line:",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "debug_lines",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "debug_lines = []\ndecomp_ignore_forms = [\"defmethod inspect\"]\ndecomp_ignore_errors = False\nwith open(gsrc_path) as f:\n    lines_temp = f.readlines()\n    lines = []\n    # Get rid of debug lines, this is so i can re-run without having to reset the file\n    for line in lines_temp:\n        if \"[DEBUG]\" in line:\n            continue",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "decomp_ignore_forms",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "decomp_ignore_forms = [\"defmethod inspect\"]\ndecomp_ignore_errors = False\nwith open(gsrc_path) as f:\n    lines_temp = f.readlines()\n    lines = []\n    # Get rid of debug lines, this is so i can re-run without having to reset the file\n    for line in lines_temp:\n        if \"[DEBUG]\" in line:\n            continue\n        # Check for comment annotate overrides / settings, this is the \"nicest\" place to shove this",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "decomp_ignore_errors",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "decomp_ignore_errors = False\nwith open(gsrc_path) as f:\n    lines_temp = f.readlines()\n    lines = []\n    # Get rid of debug lines, this is so i can re-run without having to reset the file\n    for line in lines_temp:\n        if \"[DEBUG]\" in line:\n            continue\n        # Check for comment annotate overrides / settings, this is the \"nicest\" place to shove this\n        if \"og:ignore-errors\" in line and \"true\" in line:",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "lines_to_ignore",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "lines_to_ignore = [\n    \";;-*-Lisp-*-\",\n    \"(in-package goal)\",\n    \";; definition\",\n    \";; INFO:\",\n    \";; failed to figure\",\n    \";; Used lq/sq\",\n    \";; this part is debug only\",\n    \";; WARN: Return type mismatch int vs none\",\n    \";; WARN: Stack slot offset\",",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "decomp_lines",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "decomp_lines = []\n# cache all form definition lines from the incoming decompilation\n# this way, we can \"quickly\" figure out which form is the most relevant\ndecomp_form_def_lines = []\ndef should_ignore_line(line):\n    for ignore_line in lines_to_ignore:\n        if line.lower().startswith(ignore_line.lower()):\n            return True\n    return False\n# TODO - ignore brackets inside strings!",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "decomp_form_def_lines",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "decomp_form_def_lines = []\ndef should_ignore_line(line):\n    for ignore_line in lines_to_ignore:\n        if line.lower().startswith(ignore_line.lower()):\n            return True\n    return False\n# TODO - ignore brackets inside strings!\ndecomp_file_path = \"./decompiler_out/{}/{}_disasm.gc\".format(args.game, args.file)\nwith open(decomp_file_path) as f:\n    lines = f.readlines()",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "decomp_file_path",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "decomp_file_path = \"./decompiler_out/{}/{}_disasm.gc\".format(args.game, args.file)\nwith open(decomp_file_path) as f:\n    lines = f.readlines()\n    i = 0\n    decomp_form_paren_stack = []\n    decomp_within_form = None\n    while i < len(lines):\n        line = lines[i]\n        if should_ignore_line(line):\n            i = i + 1",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "final_lines",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "final_lines = []\nwith open(gsrc_path) as f:\n    lines = f.readlines()\n    for line in lines:\n        final_lines.append(line)\n        if line.lower().startswith(\";; decomp begins\"):\n            break\n    for line in decomp_lines:\n        final_lines.append(line)\n# Step 4.a: Remove excessive new-lines from the end of the output, only leave a single empty new-line",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "lines_to_ignore",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "lines_to_ignore = 0\ni = len(final_lines) - 1\nwhile i > 0 and (final_lines[i] == \"\\n\" or final_lines[i] == \"0\\n\"):\n    lines_to_ignore = lines_to_ignore + 1\n    i = i - 1\nprint(\"ignoring - {}\".format(lines_to_ignore))\n# Step 4.b: Write it out\nwith open(gsrc_path, \"w\") as f:\n    i = 0\n    while i + lines_to_ignore < len(final_lines):",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "i",
        "kind": 5,
        "importPath": "scripts.gsrc.update-from-decomp",
        "description": "scripts.gsrc.update-from-decomp",
        "peekOfCode": "i = len(final_lines) - 1\nwhile i > 0 and (final_lines[i] == \"\\n\" or final_lines[i] == \"0\\n\"):\n    lines_to_ignore = lines_to_ignore + 1\n    i = i - 1\nprint(\"ignoring - {}\".format(lines_to_ignore))\n# Step 4.b: Write it out\nwith open(gsrc_path, \"w\") as f:\n    i = 0\n    while i + lines_to_ignore < len(final_lines):\n        f.write(final_lines[i])",
        "detail": "scripts.gsrc.update-from-decomp",
        "documentation": {}
    },
    {
        "label": "get_files_via_git",
        "kind": 2,
        "importPath": "scripts.gsrc.update-gsrc-via-refs",
        "description": "scripts.gsrc.update-gsrc-via-refs",
        "peekOfCode": "def get_files_via_git():\n    file_names = set()\n    for item in repo.index.diff(None):\n        path = item.b_rawpath.decode(\"utf-8\")\n        if args.game in path and \"_REF\" in path:\n            file_names.add(os.path.basename(path).replace(\"_REF.gc\", \"\"))\n    for item in repo.untracked_files:\n        path = item\n        if args.game in path and \"_REF\" in path:\n            file_names.add(os.path.basename(path).replace(\"_REF.gc\", \"\"))",
        "detail": "scripts.gsrc.update-gsrc-via-refs",
        "documentation": {}
    },
    {
        "label": "get_files_via_glob",
        "kind": 2,
        "importPath": "scripts.gsrc.update-gsrc-via-refs",
        "description": "scripts.gsrc.update-gsrc-via-refs",
        "peekOfCode": "def get_files_via_glob():\n    file_names = set()\n    for file in glob.glob(\"./test/decompiler/reference/{}/{}\".format(args.game, args.file_pattern), recursive=True):\n        file_names.add(os.path.basename(file).replace(\"_REF.gc\", \"\"))\n    return file_names\n# Get a list of changed files, as well as new files\nfile_names = []\nif args.file_pattern:\n    file_names = get_files_via_glob()\nelse:",
        "detail": "scripts.gsrc.update-gsrc-via-refs",
        "documentation": {}
    },
    {
        "label": "repo",
        "kind": 5,
        "importPath": "scripts.gsrc.update-gsrc-via-refs",
        "description": "scripts.gsrc.update-gsrc-via-refs",
        "peekOfCode": "repo = Repo(\"./\")\nimport argparse\nimport os\nimport glob\nparser = argparse.ArgumentParser(\"update-gsrc-via-refs\")\nparser.add_argument(\"--game\", help=\"The name of the game\", type=str)\nparser.add_argument(\"--decompiler\", help=\"The path to the decompiler\", type=str)\nparser.add_argument(\"--decompiler_config\", help=\"The decomp config\", type=str)\nparser.add_argument(\"--version\", help=\"The decomp config version\", type=str)\nparser.add_argument(\"--file_pattern\", help=\"Provide a glob pattern to find files, instead of using git status. Relative to the reference test folder\", type=str)",
        "detail": "scripts.gsrc.update-gsrc-via-refs",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.gsrc.update-gsrc-via-refs",
        "description": "scripts.gsrc.update-gsrc-via-refs",
        "peekOfCode": "parser = argparse.ArgumentParser(\"update-gsrc-via-refs\")\nparser.add_argument(\"--game\", help=\"The name of the game\", type=str)\nparser.add_argument(\"--decompiler\", help=\"The path to the decompiler\", type=str)\nparser.add_argument(\"--decompiler_config\", help=\"The decomp config\", type=str)\nparser.add_argument(\"--version\", help=\"The decomp config version\", type=str)\nparser.add_argument(\"--file_pattern\", help=\"Provide a glob pattern to find files, instead of using git status. Relative to the reference test folder\", type=str)\nargs = parser.parse_args()\ndef get_files_via_git():\n    file_names = set()\n    for item in repo.index.diff(None):",
        "detail": "scripts.gsrc.update-gsrc-via-refs",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.gsrc.update-gsrc-via-refs",
        "description": "scripts.gsrc.update-gsrc-via-refs",
        "peekOfCode": "args = parser.parse_args()\ndef get_files_via_git():\n    file_names = set()\n    for item in repo.index.diff(None):\n        path = item.b_rawpath.decode(\"utf-8\")\n        if args.game in path and \"_REF\" in path:\n            file_names.add(os.path.basename(path).replace(\"_REF.gc\", \"\"))\n    for item in repo.untracked_files:\n        path = item\n        if args.game in path and \"_REF\" in path:",
        "detail": "scripts.gsrc.update-gsrc-via-refs",
        "documentation": {}
    },
    {
        "label": "file_names",
        "kind": 5,
        "importPath": "scripts.gsrc.update-gsrc-via-refs",
        "description": "scripts.gsrc.update-gsrc-via-refs",
        "peekOfCode": "file_names = []\nif args.file_pattern:\n    file_names = get_files_via_glob()\nelse:\n    file_names = get_files_via_git()\nall_names = str(file_names).replace(\"'\", \"\\\"\").replace(\"{\", \"[\").replace(\"}\", \"]\");\nprint(\"Decompiling - {}\".format(all_names))\ndecompile_file(args.decompiler, args.decompiler_config, args.version, all_names, False)\nfor file_name in file_names:\n    print(\"Updating - {}\".format(file_name))",
        "detail": "scripts.gsrc.update-gsrc-via-refs",
        "documentation": {}
    },
    {
        "label": "all_names",
        "kind": 5,
        "importPath": "scripts.gsrc.update-gsrc-via-refs",
        "description": "scripts.gsrc.update-gsrc-via-refs",
        "peekOfCode": "all_names = str(file_names).replace(\"'\", \"\\\"\").replace(\"{\", \"[\").replace(\"}\", \"]\");\nprint(\"Decompiling - {}\".format(all_names))\ndecompile_file(args.decompiler, args.decompiler_config, args.version, all_names, False)\nfor file_name in file_names:\n    print(\"Updating - {}\".format(file_name))\n    # Update gsrc\n    os.system(\n        \"python ./scripts/gsrc/update-from-decomp.py --game {} --file {}\".format(\n            args.game, file_name\n        )",
        "detail": "scripts.gsrc.update-gsrc-via-refs",
        "documentation": {}
    },
    {
        "label": "get_file_list",
        "kind": 2,
        "importPath": "scripts.gsrc.utils",
        "description": "scripts.gsrc.utils",
        "peekOfCode": "def get_file_list(game_name):\n  match game_name:\n    case \"jak1\":\n      return jak1_files\n    case \"jak2\":\n      return jak2_files\n    case \"jak3\":\n      return jak3_files\ndef is_file_in_game(game_name, file_name):\n  file_list = get_file_list(game_name)",
        "detail": "scripts.gsrc.utils",
        "documentation": {}
    },
    {
        "label": "is_file_in_game",
        "kind": 2,
        "importPath": "scripts.gsrc.utils",
        "description": "scripts.gsrc.utils",
        "peekOfCode": "def is_file_in_game(game_name, file_name):\n  file_list = get_file_list(game_name)\n  for f in file_list:\n    if f[2] != 3 and f[2] != 5:\n      continue\n    if f[0] == file_name:\n      return True\n  return False\ndef get_gsrc_path_from_filename(game_name, file_name):\n  file_list = get_file_list(game_name)",
        "detail": "scripts.gsrc.utils",
        "documentation": {}
    },
    {
        "label": "get_gsrc_path_from_filename",
        "kind": 2,
        "importPath": "scripts.gsrc.utils",
        "description": "scripts.gsrc.utils",
        "peekOfCode": "def get_gsrc_path_from_filename(game_name, file_name):\n  file_list = get_file_list(game_name)\n  src_path = \"\"\n  for f in file_list:\n    if f[2] != 3 and f[2] != 5:\n      continue\n    if f[0] == file_name:\n      src_path = f[4]\n      break\n  path = \"./goal_src/{}/{}/{}.gc\".format(game_name, src_path, file_name)",
        "detail": "scripts.gsrc.utils",
        "documentation": {}
    },
    {
        "label": "get_alltypes_path_from_game",
        "kind": 2,
        "importPath": "scripts.gsrc.utils",
        "description": "scripts.gsrc.utils",
        "peekOfCode": "def get_alltypes_path_from_game(game_name):\n  return \"./decompiler/config/{}/all-types.gc\".format(game_name)\ndef get_ref_path_from_filename(game_name, file_name, ref_folder):\n  file_list = get_file_list(game_name)\n  src_path = \"\"\n  for f in file_list:\n    if f[2] != 3 and f[2] != 5:\n      continue\n    if f[0] == file_name:\n      src_path = f[4]",
        "detail": "scripts.gsrc.utils",
        "documentation": {}
    },
    {
        "label": "get_ref_path_from_filename",
        "kind": 2,
        "importPath": "scripts.gsrc.utils",
        "description": "scripts.gsrc.utils",
        "peekOfCode": "def get_ref_path_from_filename(game_name, file_name, ref_folder):\n  file_list = get_file_list(game_name)\n  src_path = \"\"\n  for f in file_list:\n    if f[2] != 3 and f[2] != 5:\n      continue\n    if f[0] == file_name:\n      src_path = f[4]\n      break\n  if src_path == \"\":",
        "detail": "scripts.gsrc.utils",
        "documentation": {}
    },
    {
        "label": "decompile_file",
        "kind": 2,
        "importPath": "scripts.gsrc.utils",
        "description": "scripts.gsrc.utils",
        "peekOfCode": "def decompile_file(decompiler_path, decompiler_config, game_version, file_names, omit_var_casts=False):\n  decompiler_args = '{{\"levels_extract\": false, \"process_art_groups\": false, \"decompile_code\": true, \"allowed_objects\": {}}}'.format(file_names)\n  if omit_var_casts:\n    decompiler_args = '{{\"levels_extract\": false, \"process_art_groups\": false, \"decompile_code\": true, \"ignore_var_name_casts\": true, \"allowed_objects\": {}}}'.format(file_names)\n  subprocess.run(\n    [\n        decompiler_path,\n        \"./decompiler/config/{}\".format(decompiler_config),\n        \"./iso_data\",\n        \"./decompiler_out\",",
        "detail": "scripts.gsrc.utils",
        "documentation": {}
    },
    {
        "label": "jak1_files",
        "kind": 5,
        "importPath": "scripts.gsrc.utils",
        "description": "scripts.gsrc.utils",
        "peekOfCode": "jak1_files = None\njak2_files = None\njak3_files = None\nwith open('./goal_src/jak1/build/all_objs.json', 'r') as f:\n  jak1_files = json.load(f)\nwith open('./goal_src/jak2/build/all_objs.json', 'r') as f:\n  jak2_files = json.load(f)\nwith open('./goal_src/jak3/build/all_objs.json', 'r') as f:\n  jak3_files = json.load(f)\ndef get_file_list(game_name):",
        "detail": "scripts.gsrc.utils",
        "documentation": {}
    },
    {
        "label": "jak2_files",
        "kind": 5,
        "importPath": "scripts.gsrc.utils",
        "description": "scripts.gsrc.utils",
        "peekOfCode": "jak2_files = None\njak3_files = None\nwith open('./goal_src/jak1/build/all_objs.json', 'r') as f:\n  jak1_files = json.load(f)\nwith open('./goal_src/jak2/build/all_objs.json', 'r') as f:\n  jak2_files = json.load(f)\nwith open('./goal_src/jak3/build/all_objs.json', 'r') as f:\n  jak3_files = json.load(f)\ndef get_file_list(game_name):\n  match game_name:",
        "detail": "scripts.gsrc.utils",
        "documentation": {}
    },
    {
        "label": "jak3_files",
        "kind": 5,
        "importPath": "scripts.gsrc.utils",
        "description": "scripts.gsrc.utils",
        "peekOfCode": "jak3_files = None\nwith open('./goal_src/jak1/build/all_objs.json', 'r') as f:\n  jak1_files = json.load(f)\nwith open('./goal_src/jak2/build/all_objs.json', 'r') as f:\n  jak2_files = json.load(f)\nwith open('./goal_src/jak3/build/all_objs.json', 'r') as f:\n  jak3_files = json.load(f)\ndef get_file_list(game_name):\n  match game_name:\n    case \"jak1\":",
        "detail": "scripts.gsrc.utils",
        "documentation": {}
    },
    {
        "label": "delete_extension",
        "kind": 2,
        "importPath": "scripts.tasks.clean-decomp",
        "description": "scripts.tasks.clean-decomp",
        "peekOfCode": "def delete_extension(ext):\n  fileList = glob.glob('./decompiler_out/{}/*.{}'.format(args.game, ext))\n  for filePath in fileList:\n    os.remove(filePath)\ndelete_extension(\"gc\")\ndelete_extension(\"asm\")",
        "detail": "scripts.tasks.clean-decomp",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.tasks.clean-decomp",
        "description": "scripts.tasks.clean-decomp",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--game\")\nargs = parser.parse_args()\nimport os\nimport glob\ndef delete_extension(ext):\n  fileList = glob.glob('./decompiler_out/{}/*.{}'.format(args.game, ext))\n  for filePath in fileList:\n    os.remove(filePath)\ndelete_extension(\"gc\")",
        "detail": "scripts.tasks.clean-decomp",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.tasks.clean-decomp",
        "description": "scripts.tasks.clean-decomp",
        "peekOfCode": "args = parser.parse_args()\nimport os\nimport glob\ndef delete_extension(ext):\n  fileList = glob.glob('./decompiler_out/{}/*.{}'.format(args.game, ext))\n  for filePath in fileList:\n    os.remove(filePath)\ndelete_extension(\"gc\")\ndelete_extension(\"asm\")",
        "detail": "scripts.tasks.clean-decomp",
        "documentation": {}
    },
    {
        "label": "copy_with_glob",
        "kind": 2,
        "importPath": "scripts.tasks.cp",
        "description": "scripts.tasks.cp",
        "peekOfCode": "def copy_with_glob(source_glob, destination):\n    # Expand the glob pattern\n    paths = glob.glob(source_glob, recursive=True)\n    for path in paths:\n        # Get the destination path by joining the destination directory with the relative path\n        relative_path = os.path.relpath(path, os.path.dirname(source_glob))\n        dest_path = os.path.join(destination, relative_path)\n        # Check if the path is a file or a directory\n        if os.path.isfile(path):\n            # Copy the file",
        "detail": "scripts.tasks.cp",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.tasks.cp",
        "description": "scripts.tasks.cp",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--src\")\nparser.add_argument(\"--dest\")\nargs = parser.parse_args()\nimport shutil\nimport os\ndef copy_with_glob(source_glob, destination):\n    # Expand the glob pattern\n    paths = glob.glob(source_glob, recursive=True)\n    for path in paths:",
        "detail": "scripts.tasks.cp",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.tasks.cp",
        "description": "scripts.tasks.cp",
        "peekOfCode": "args = parser.parse_args()\nimport shutil\nimport os\ndef copy_with_glob(source_glob, destination):\n    # Expand the glob pattern\n    paths = glob.glob(source_glob, recursive=True)\n    for path in paths:\n        # Get the destination path by joining the destination directory with the relative path\n        relative_path = os.path.relpath(path, os.path.dirname(source_glob))\n        dest_path = os.path.join(destination, relative_path)",
        "detail": "scripts.tasks.cp",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.tasks.delete-file-or-folder",
        "description": "scripts.tasks.delete-file-or-folder",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--path\")\nargs = parser.parse_args()\nfrom os import path\nimport shutil\nif path.exists(\"./{}\".format(args.path)):\n  shutil.rmtree(\"./{}\".format(args.path))",
        "detail": "scripts.tasks.delete-file-or-folder",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.tasks.delete-file-or-folder",
        "description": "scripts.tasks.delete-file-or-folder",
        "peekOfCode": "args = parser.parse_args()\nfrom os import path\nimport shutil\nif path.exists(\"./{}\".format(args.path)):\n  shutil.rmtree(\"./{}\".format(args.path))",
        "detail": "scripts.tasks.delete-file-or-folder",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.tasks.extract-zip",
        "description": "scripts.tasks.extract-zip",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--file\")\nparser.add_argument(\"--out\")\nargs = parser.parse_args()\nwith zipfile.ZipFile(args.file, 'r') as p2s:\n  p2s.extractall(args.out)",
        "detail": "scripts.tasks.extract-zip",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.tasks.extract-zip",
        "description": "scripts.tasks.extract-zip",
        "peekOfCode": "args = parser.parse_args()\nwith zipfile.ZipFile(args.file, 'r') as p2s:\n  p2s.extractall(args.out)",
        "detail": "scripts.tasks.extract-zip",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "parser = argparse.ArgumentParser(\"update-env\")\nparser.add_argument(\"--game\", help=\"The name of the game\", type=str)\nparser.add_argument(\"--decomp_config\", help=\"The decompiler config file\", type=str)\nparser.add_argument(\"--info\", help=\"Just print out current settings\", action='store_true')\nargs = parser.parse_args()\n# TODO - read from defaults\nfile = {\n  \"GAME\": \"jak1\",\n  \"DECOMP_CONFIG\": \"jak1/jak1_config.jsonc\",\n  \"DECOMP_CONFIG_VERSION\": \"ntsc_v1\"",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "args = parser.parse_args()\n# TODO - read from defaults\nfile = {\n  \"GAME\": \"jak1\",\n  \"DECOMP_CONFIG\": \"jak1/jak1_config.jsonc\",\n  \"DECOMP_CONFIG_VERSION\": \"ntsc_v1\"\n}\nenv_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), \".env\")\nif not os.path.exists(env_path):\n  with open(env_path, 'w') as env_file:",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "file",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "file = {\n  \"GAME\": \"jak1\",\n  \"DECOMP_CONFIG\": \"jak1/jak1_config.jsonc\",\n  \"DECOMP_CONFIG_VERSION\": \"ntsc_v1\"\n}\nenv_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), \".env\")\nif not os.path.exists(env_path):\n  with open(env_path, 'w') as env_file:\n    for item in file.items():\n      env_file.write(\"{}={}\\n\".format(item[0], item[1]))",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "env_path",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "env_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), \".env\")\nif not os.path.exists(env_path):\n  with open(env_path, 'w') as env_file:\n    for item in file.items():\n      env_file.write(\"{}={}\\n\".format(item[0], item[1]))\nwith open(env_path, 'r') as env_file:\n  flags = env_file.readlines()\n  for flag in flags:\n    tokens = flag.split(\"=\")\n    if tokens[0] in file:",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "valid_games",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "valid_games = [\"jak1\", \"jak2\", \"jak3\"]\ndecomp_config_map = {\n  \"jak1\": \"jak1/jak1_config.jsonc\",\n  \"jak2\": \"jak2/jak2_config.jsonc\",\n  \"jak3\": \"jak3/jak3_config.jsonc\"\n}\ndecomp_config_version_map = {\n  \"jak1\": {\n    \"ntscv1\": \"ntsc_v1\",\n    \"ntscv2\": \"ntsc_v2\",",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "decomp_config_map",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "decomp_config_map = {\n  \"jak1\": \"jak1/jak1_config.jsonc\",\n  \"jak2\": \"jak2/jak2_config.jsonc\",\n  \"jak3\": \"jak3/jak3_config.jsonc\"\n}\ndecomp_config_version_map = {\n  \"jak1\": {\n    \"ntscv1\": \"ntsc_v1\",\n    \"ntscv2\": \"ntsc_v2\",\n    \"pal\": \"pal\",",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "decomp_config_version_map",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "decomp_config_version_map = {\n  \"jak1\": {\n    \"ntscv1\": \"ntsc_v1\",\n    \"ntscv2\": \"ntsc_v2\",\n    \"pal\": \"pal\",\n    \"ntscjp\": \"jp\"\n  },\n  \"jak2\": {\n    \"ntscv1\": \"ntsc_v1\",\n    \"ntscv2\": \"ntsc_v2\",",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "default_config_version_map",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "default_config_version_map = {\n  \"jak1\": \"ntsc_v1\",\n  \"jak2\": \"ntsc_v1\",\n  \"jak3\": \"ntsc_v1\"\n}\ntype_consistency_filter_map = {\n  \"jak1\": \"Jak1TypeConsistency\",\n  \"jak2\": \"Jak2TypeConsistency\",\n  \"jak3\": \"Jak3TypeConsistency\"\n}",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "type_consistency_filter_map",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "type_consistency_filter_map = {\n  \"jak1\": \"Jak1TypeConsistency\",\n  \"jak2\": \"Jak2TypeConsistency\",\n  \"jak3\": \"Jak3TypeConsistency\"\n}\nif args.game:\n  if args.game not in valid_games:\n    print(\"Unsupported game '{}'\".format(args.game))\n    sys.exit(1)\n  curr = file[\"GAME\"]",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "pp",
        "kind": 5,
        "importPath": "scripts.tasks.update-env",
        "description": "scripts.tasks.update-env",
        "peekOfCode": "pp = pprint.PrettyPrinter(indent=2)\npp.pprint(file)",
        "detail": "scripts.tasks.update-env",
        "documentation": {}
    },
    {
        "label": "get_time",
        "kind": 2,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "def get_time(line):\n\treturn float(line.split()[-1])\ndef parse_file(lines):\n\tscanning_pattern = re.compile(\"Scanning dependencies of target \\\\w+\\\\n\")\n\tbuilding_cxx_pattern = re.compile(\"\\\\[....\\\\] Building CXX object .+\\\\n\")\n\tcurrent_target = \"UNKNOWN\"\n\tall_builds = []\n\ttime_by_target = dict()\n\tcount_by_target = dict()\n\ttotal_real_time = 0.0",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "parse_file",
        "kind": 2,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "def parse_file(lines):\n\tscanning_pattern = re.compile(\"Scanning dependencies of target \\\\w+\\\\n\")\n\tbuilding_cxx_pattern = re.compile(\"\\\\[....\\\\] Building CXX object .+\\\\n\")\n\tcurrent_target = \"UNKNOWN\"\n\tall_builds = []\n\ttime_by_target = dict()\n\tcount_by_target = dict()\n\ttotal_real_time = 0.0\n\tfor i in range(len(lines)):\n\t\tif(scanning_pattern.match(lines[i])):",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "def main():\n\tparser = argparse.ArgumentParser()\n\tparser.add_argument(dest = 'input', help = 'Input text file.')\n\targs = parser.parse_args()\n\twith open(args.input, \"r\") as f:\n\t\tparse_file(f.readlines())\nif __name__ == \"__main__\":\n\tmain()",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\tscanning_pattern",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\tscanning_pattern = re.compile(\"Scanning dependencies of target \\\\w+\\\\n\")\n\tbuilding_cxx_pattern = re.compile(\"\\\\[....\\\\] Building CXX object .+\\\\n\")\n\tcurrent_target = \"UNKNOWN\"\n\tall_builds = []\n\ttime_by_target = dict()\n\tcount_by_target = dict()\n\ttotal_real_time = 0.0\n\tfor i in range(len(lines)):\n\t\tif(scanning_pattern.match(lines[i])):\n\t\t\tcurrent_target = lines[i][:-1].split()[-1]",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\tbuilding_cxx_pattern",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\tbuilding_cxx_pattern = re.compile(\"\\\\[....\\\\] Building CXX object .+\\\\n\")\n\tcurrent_target = \"UNKNOWN\"\n\tall_builds = []\n\ttime_by_target = dict()\n\tcount_by_target = dict()\n\ttotal_real_time = 0.0\n\tfor i in range(len(lines)):\n\t\tif(scanning_pattern.match(lines[i])):\n\t\t\tcurrent_target = lines[i][:-1].split()[-1]\n\t\t\tprint(\"current_target is {}\".format(current_target))",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\tcurrent_target",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\tcurrent_target = \"UNKNOWN\"\n\tall_builds = []\n\ttime_by_target = dict()\n\tcount_by_target = dict()\n\ttotal_real_time = 0.0\n\tfor i in range(len(lines)):\n\t\tif(scanning_pattern.match(lines[i])):\n\t\t\tcurrent_target = lines[i][:-1].split()[-1]\n\t\t\tprint(\"current_target is {}\".format(current_target))\n\t\t\tif current_target not in time_by_target:",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\tall_builds",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\tall_builds = []\n\ttime_by_target = dict()\n\tcount_by_target = dict()\n\ttotal_real_time = 0.0\n\tfor i in range(len(lines)):\n\t\tif(scanning_pattern.match(lines[i])):\n\t\t\tcurrent_target = lines[i][:-1].split()[-1]\n\t\t\tprint(\"current_target is {}\".format(current_target))\n\t\t\tif current_target not in time_by_target:\n\t\t\t\ttime_by_target[current_target] = 0.0",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\ttime_by_target",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\ttime_by_target = dict()\n\tcount_by_target = dict()\n\ttotal_real_time = 0.0\n\tfor i in range(len(lines)):\n\t\tif(scanning_pattern.match(lines[i])):\n\t\t\tcurrent_target = lines[i][:-1].split()[-1]\n\t\t\tprint(\"current_target is {}\".format(current_target))\n\t\t\tif current_target not in time_by_target:\n\t\t\t\ttime_by_target[current_target] = 0.0\n\t\t\t\tcount_by_target[current_target] = 0",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\tcount_by_target",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\tcount_by_target = dict()\n\ttotal_real_time = 0.0\n\tfor i in range(len(lines)):\n\t\tif(scanning_pattern.match(lines[i])):\n\t\t\tcurrent_target = lines[i][:-1].split()[-1]\n\t\t\tprint(\"current_target is {}\".format(current_target))\n\t\t\tif current_target not in time_by_target:\n\t\t\t\ttime_by_target[current_target] = 0.0\n\t\t\t\tcount_by_target[current_target] = 0\n\t\telif(building_cxx_pattern.match(lines[i])):",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\ttotal_real_time",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\ttotal_real_time = 0.0\n\tfor i in range(len(lines)):\n\t\tif(scanning_pattern.match(lines[i])):\n\t\t\tcurrent_target = lines[i][:-1].split()[-1]\n\t\t\tprint(\"current_target is {}\".format(current_target))\n\t\t\tif current_target not in time_by_target:\n\t\t\t\ttime_by_target[current_target] = 0.0\n\t\t\t\tcount_by_target[current_target] = 0\n\t\telif(building_cxx_pattern.match(lines[i])):\n\t\t\tobj = lines[i][:-3].split('/')[-1]",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\t\t\tcurrent_target",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\t\t\tcurrent_target = lines[i][:-1].split()[-1]\n\t\t\tprint(\"current_target is {}\".format(current_target))\n\t\t\tif current_target not in time_by_target:\n\t\t\t\ttime_by_target[current_target] = 0.0\n\t\t\t\tcount_by_target[current_target] = 0\n\t\telif(building_cxx_pattern.match(lines[i])):\n\t\t\tobj = lines[i][:-3].split('/')[-1]\n\t\t\treal_time = get_time(lines[i+1])\n\t\t\tuser_time = get_time(lines[i+2])\n\t\t\tsys_time = get_time(lines[i+3])",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ttime_by_target[current_target]",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\t\t\t\ttime_by_target[current_target] = 0.0\n\t\t\t\tcount_by_target[current_target] = 0\n\t\telif(building_cxx_pattern.match(lines[i])):\n\t\t\tobj = lines[i][:-3].split('/')[-1]\n\t\t\treal_time = get_time(lines[i+1])\n\t\t\tuser_time = get_time(lines[i+2])\n\t\t\tsys_time = get_time(lines[i+3])\n\t\t\ti += 3\n\t\t\tprint(\"  building cxx is {}: {}, {}, {}\".format(obj, real_time, user_time, sys_time))\n\t\t\tall_builds.append((obj, real_time, user_time, sys_time))",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tcount_by_target[current_target]",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\t\t\t\tcount_by_target[current_target] = 0\n\t\telif(building_cxx_pattern.match(lines[i])):\n\t\t\tobj = lines[i][:-3].split('/')[-1]\n\t\t\treal_time = get_time(lines[i+1])\n\t\t\tuser_time = get_time(lines[i+2])\n\t\t\tsys_time = get_time(lines[i+3])\n\t\t\ti += 3\n\t\t\tprint(\"  building cxx is {}: {}, {}, {}\".format(obj, real_time, user_time, sys_time))\n\t\t\tall_builds.append((obj, real_time, user_time, sys_time))\n\t\t\ttotal_real_time += real_time",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\t\t\tobj",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\t\t\tobj = lines[i][:-3].split('/')[-1]\n\t\t\treal_time = get_time(lines[i+1])\n\t\t\tuser_time = get_time(lines[i+2])\n\t\t\tsys_time = get_time(lines[i+3])\n\t\t\ti += 3\n\t\t\tprint(\"  building cxx is {}: {}, {}, {}\".format(obj, real_time, user_time, sys_time))\n\t\t\tall_builds.append((obj, real_time, user_time, sys_time))\n\t\t\ttotal_real_time += real_time\n\t\t\ttime_by_target[current_target] += real_time\n\t\t\tcount_by_target[current_target] += 1",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\t\t\treal_time",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\t\t\treal_time = get_time(lines[i+1])\n\t\t\tuser_time = get_time(lines[i+2])\n\t\t\tsys_time = get_time(lines[i+3])\n\t\t\ti += 3\n\t\t\tprint(\"  building cxx is {}: {}, {}, {}\".format(obj, real_time, user_time, sys_time))\n\t\t\tall_builds.append((obj, real_time, user_time, sys_time))\n\t\t\ttotal_real_time += real_time\n\t\t\ttime_by_target[current_target] += real_time\n\t\t\tcount_by_target[current_target] += 1\n\tprint(\"Total build time: {}\".format(total_real_time))",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\t\t\tuser_time",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\t\t\tuser_time = get_time(lines[i+2])\n\t\t\tsys_time = get_time(lines[i+3])\n\t\t\ti += 3\n\t\t\tprint(\"  building cxx is {}: {}, {}, {}\".format(obj, real_time, user_time, sys_time))\n\t\t\tall_builds.append((obj, real_time, user_time, sys_time))\n\t\t\ttotal_real_time += real_time\n\t\t\ttime_by_target[current_target] += real_time\n\t\t\tcount_by_target[current_target] += 1\n\tprint(\"Total build time: {}\".format(total_real_time))\n\tfor k, v in count_by_target.items():",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\t\t\tsys_time",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\t\t\tsys_time = get_time(lines[i+3])\n\t\t\ti += 3\n\t\t\tprint(\"  building cxx is {}: {}, {}, {}\".format(obj, real_time, user_time, sys_time))\n\t\t\tall_builds.append((obj, real_time, user_time, sys_time))\n\t\t\ttotal_real_time += real_time\n\t\t\ttime_by_target[current_target] += real_time\n\t\t\tcount_by_target[current_target] += 1\n\tprint(\"Total build time: {}\".format(total_real_time))\n\tfor k, v in count_by_target.items():\n\t\tprint(\"{}, {}\".format(k, v))",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\tparser",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\tparser = argparse.ArgumentParser()\n\tparser.add_argument(dest = 'input', help = 'Input text file.')\n\targs = parser.parse_args()\n\twith open(args.input, \"r\") as f:\n\t\tparse_file(f.readlines())\nif __name__ == \"__main__\":\n\tmain()",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\tparser.add_argument(dest",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\tparser.add_argument(dest = 'input', help = 'Input text file.')\n\targs = parser.parse_args()\n\twith open(args.input, \"r\") as f:\n\t\tparse_file(f.readlines())\nif __name__ == \"__main__\":\n\tmain()",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "\targs",
        "kind": 5,
        "importPath": "scripts.analyze_build_time",
        "description": "scripts.analyze_build_time",
        "peekOfCode": "\targs = parser.parse_args()\n\twith open(args.input, \"r\") as f:\n\t\tparse_file(f.readlines())\nif __name__ == \"__main__\":\n\tmain()",
        "detail": "scripts.analyze_build_time",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.bundle-linux",
        "description": "scripts.bundle-linux",
        "peekOfCode": "args = {\n    \"outputDir\": os.getenv(\"outputDir\"),\n    \"versionName\": os.getenv(\"versionName\"),\n    \"toolingVersion\": os.getenv(\"toolingVersion\"),\n    \"toolingBinaryDir\": os.getenv(\"toolingBinaryDir\"),\n    \"textureReplacementDir\": os.getenv(\"textureReplacementDir\"),\n    \"customLevelsDir\": os.getenv(\"customLevelsDir\"),\n    \"goalSourceDir\": os.getenv(\"goalSourceDir\")\n}\n# Create our output directory",
        "detail": "scripts.bundle-linux",
        "documentation": {}
    },
    {
        "label": "toolingVersion",
        "kind": 5,
        "importPath": "scripts.bundle-linux",
        "description": "scripts.bundle-linux",
        "peekOfCode": "toolingVersion = args.toolingVersion\nif toolingVersion == \"latest\":\n    # Get the latest open-goal/jak-project release\n    toolingVersion = requests.get(\n        \"https://api.github.com/repos/open-goal/jak-project/releases/latest\"\n    ).json()[\"tag_name\"]\nreleaseAssetUrl = \"https://github.com/open-goal/jak-project/releases/download/{}/opengoal-linux-{}.tar.gz\".format(\n    toolingVersion, toolingVersion\n)\nurllib.request.urlretrieve(",
        "detail": "scripts.bundle-linux",
        "documentation": {}
    },
    {
        "label": "releaseAssetUrl",
        "kind": 5,
        "importPath": "scripts.bundle-linux",
        "description": "scripts.bundle-linux",
        "peekOfCode": "releaseAssetUrl = \"https://github.com/open-goal/jak-project/releases/download/{}/opengoal-linux-{}.tar.gz\".format(\n    toolingVersion, toolingVersion\n)\nurllib.request.urlretrieve(\n    releaseAssetUrl, os.path.join(args.outputDir, \"linux\", \"release.tar.gz\")\n)\n# Extract it\nwith zipfile.ZipFile(\n    os.path.join(args.outputDir, \"linux\", \"release.tar.gz\"), \"r\"\n) as zip_ref:",
        "detail": "scripts.bundle-linux",
        "documentation": {}
    },
    {
        "label": "textureReplacementDir",
        "kind": 5,
        "importPath": "scripts.bundle-linux",
        "description": "scripts.bundle-linux",
        "peekOfCode": "textureReplacementDir = args.textureReplacementDir\nshutil.copytree(\n    textureReplacementDir,\n    os.path.join(args.outputDir, \"linux\", \"data\", \"texture_replacements\"),\n    dirs_exist_ok=True,\n)\ncustomLevelsDir = args.customLevelsDir\nshutil.copytree(\n    customLevelsDir,\n    os.path.join(args.outputDir, \"linux\", \"data\", \"custom_levels\"),",
        "detail": "scripts.bundle-linux",
        "documentation": {}
    },
    {
        "label": "customLevelsDir",
        "kind": 5,
        "importPath": "scripts.bundle-linux",
        "description": "scripts.bundle-linux",
        "peekOfCode": "customLevelsDir = args.customLevelsDir\nshutil.copytree(\n    customLevelsDir,\n    os.path.join(args.outputDir, \"linux\", \"data\", \"custom_levels\"),\n    dirs_exist_ok=True,\n)\ngoalSourceDir = args.goalSourceDir\nshutil.copytree(\n    goalSourceDir,\n    os.path.join(args.outputDir, \"linux\", \"data\", \"goal_src\"),",
        "detail": "scripts.bundle-linux",
        "documentation": {}
    },
    {
        "label": "goalSourceDir",
        "kind": 5,
        "importPath": "scripts.bundle-linux",
        "description": "scripts.bundle-linux",
        "peekOfCode": "goalSourceDir = args.goalSourceDir\nshutil.copytree(\n    goalSourceDir,\n    os.path.join(args.outputDir, \"linux\", \"data\", \"goal_src\"),\n    dirs_exist_ok=True,\n)\n# Rezip it up and prepare it for upload\nshutil.make_archive(\n    \"linux-{}\".format(args.versionName),\n    \"gztar\",",
        "detail": "scripts.bundle-linux",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "scripts.bundle-windows",
        "description": "scripts.bundle-windows",
        "peekOfCode": "args = {\n    \"outputDir\": os.getenv(\"outputDir\"),\n    \"versionName\": os.getenv(\"versionName\"),\n    \"toolingVersion\": os.getenv(\"toolingVersion\"),\n    \"toolingBinaryDir\": os.getenv(\"toolingBinaryDir\"),\n    \"textureReplacementDir\": os.getenv(\"textureReplacementDir\"),\n    \"customLevelsDir\": os.getenv(\"customLevelsDir\"),\n    \"goalSourceDir\": os.getenv(\"goalSourceDir\")\n}\n# Create our output directory",
        "detail": "scripts.bundle-windows",
        "documentation": {}
    },
    {
        "label": "toolingVersion",
        "kind": 5,
        "importPath": "scripts.bundle-windows",
        "description": "scripts.bundle-windows",
        "peekOfCode": "toolingVersion = args.toolingVersion\nif toolingVersion == \"latest\":\n    # Get the latest open-goal/jak-project release\n    toolingVersion = requests.get(\n        \"https://api.github.com/repos/open-goal/jak-project/releases/latest\"\n    ).json()[\"tag_name\"]\nreleaseAssetUrl = \"https://github.com/open-goal/jak-project/releases/download/{}/opengoal-windows-{}.zip\".format(\n    toolingVersion, toolingVersion\n)\nurllib.request.urlretrieve(",
        "detail": "scripts.bundle-windows",
        "documentation": {}
    },
    {
        "label": "releaseAssetUrl",
        "kind": 5,
        "importPath": "scripts.bundle-windows",
        "description": "scripts.bundle-windows",
        "peekOfCode": "releaseAssetUrl = \"https://github.com/open-goal/jak-project/releases/download/{}/opengoal-windows-{}.zip\".format(\n    toolingVersion, toolingVersion\n)\nurllib.request.urlretrieve(\n    releaseAssetUrl, os.path.join(args.outputDir, \"windows\", \"release.zip\")\n)\n# Extract it\nwith zipfile.ZipFile(\n    os.path.join(args.outputDir, \"windows\", \"release.zip\"), \"r\"\n) as zip_ref:",
        "detail": "scripts.bundle-windows",
        "documentation": {}
    },
    {
        "label": "textureReplacementDir",
        "kind": 5,
        "importPath": "scripts.bundle-windows",
        "description": "scripts.bundle-windows",
        "peekOfCode": "textureReplacementDir = args.textureReplacementDir\nshutil.copytree(\n    textureReplacementDir,\n    os.path.join(args.outputDir, \"windows\", \"data\", \"texture_replacements\"),\n    dirs_exist_ok=True,\n)\ncustomLevelsDir = args.customLevelsDir\nshutil.copytree(\n    customLevelsDir,\n    os.path.join(args.outputDir, \"windows\", \"data\", \"custom_levels\"),",
        "detail": "scripts.bundle-windows",
        "documentation": {}
    },
    {
        "label": "customLevelsDir",
        "kind": 5,
        "importPath": "scripts.bundle-windows",
        "description": "scripts.bundle-windows",
        "peekOfCode": "customLevelsDir = args.customLevelsDir\nshutil.copytree(\n    customLevelsDir,\n    os.path.join(args.outputDir, \"windows\", \"data\", \"custom_levels\"),\n    dirs_exist_ok=True,\n)\ngoalSourceDir = args.goalSourceDir\nshutil.copytree(\n    goalSourceDir,\n    os.path.join(args.outputDir, \"windows\", \"data\", \"goal_src\"),",
        "detail": "scripts.bundle-windows",
        "documentation": {}
    },
    {
        "label": "goalSourceDir",
        "kind": 5,
        "importPath": "scripts.bundle-windows",
        "description": "scripts.bundle-windows",
        "peekOfCode": "goalSourceDir = args.goalSourceDir\nshutil.copytree(\n    goalSourceDir,\n    os.path.join(args.outputDir, \"windows\", \"data\", \"goal_src\"),\n    dirs_exist_ok=True,\n)\n# Rezip it up and prepare it for upload\nshutil.make_archive(\n    \"windows-{}\".format(args.versionName),\n    \"zip\",",
        "detail": "scripts.bundle-windows",
        "documentation": {}
    },
    {
        "label": "get_goal_files",
        "kind": 2,
        "importPath": "scripts.combine_all_imports",
        "description": "scripts.combine_all_imports",
        "peekOfCode": "def get_goal_files(root_dir, ext = \"*.gc\"):\n    \"\"\"Get all GOAL source files under root_dir.\"\"\"\n    return [goal_file for file in os.walk(root_dir) for goal_file in glob.glob(os.path.join(file[0], ext))]\nall_files = get_goal_files(\"./decompiler_out/jak2/import\")\nresult = \"\"\nfor file in all_files:\n\twith open(file) as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"(def\"):\n\t\t\t\tresult += line",
        "detail": "scripts.combine_all_imports",
        "documentation": {}
    },
    {
        "label": "all_files",
        "kind": 5,
        "importPath": "scripts.combine_all_imports",
        "description": "scripts.combine_all_imports",
        "peekOfCode": "all_files = get_goal_files(\"./decompiler_out/jak2/import\")\nresult = \"\"\nfor file in all_files:\n\twith open(file) as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"(def\"):\n\t\t\t\tresult += line\nprint(result)",
        "detail": "scripts.combine_all_imports",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "scripts.combine_all_imports",
        "description": "scripts.combine_all_imports",
        "peekOfCode": "result = \"\"\nfor file in all_files:\n\twith open(file) as f:\n\t\tfor line in f:\n\t\t\tif line.startswith(\"(def\"):\n\t\t\t\tresult += line\nprint(result)",
        "detail": "scripts.combine_all_imports",
        "documentation": {}
    },
    {
        "label": "get_goal_files",
        "kind": 2,
        "importPath": "scripts.decomp_progress",
        "description": "scripts.decomp_progress",
        "peekOfCode": "def get_goal_files(root_dir, ext = \"*.gc\"):\n    \"\"\"Get all GOAL source files under root_dir.\"\"\"\n    return [goal_file for file in os.walk(root_dir) for goal_file in glob.glob(os.path.join(file[0], ext))]\ndef lines_in_file(file_path):\n    with open(file_path) as f:\n        lines = 0\n        for _ in f:\n            lines += 1\n        return lines\ndef print_table(game, stats, total_gc_files):",
        "detail": "scripts.decomp_progress",
        "documentation": {}
    },
    {
        "label": "lines_in_file",
        "kind": 2,
        "importPath": "scripts.decomp_progress",
        "description": "scripts.decomp_progress",
        "peekOfCode": "def lines_in_file(file_path):\n    with open(file_path) as f:\n        lines = 0\n        for _ in f:\n            lines += 1\n        return lines\ndef print_table(game, stats, total_gc_files):\n    total_lines = 0\n    print(\"| {: <24} | {: <6} |\".format(\"file name\", \"lines\"))\n    print(\"-------------------------------------\")",
        "detail": "scripts.decomp_progress",
        "documentation": {}
    },
    {
        "label": "print_table",
        "kind": 2,
        "importPath": "scripts.decomp_progress",
        "description": "scripts.decomp_progress",
        "peekOfCode": "def print_table(game, stats, total_gc_files):\n    total_lines = 0\n    print(\"| {: <24} | {: <6} |\".format(\"file name\", \"lines\"))\n    print(\"-------------------------------------\")\n    for x in stats:\n        print(\"  {: <24} | {: >6} |\".format(x[0], x[1]))\n        total_lines += x[1]\n    print(\"-------------------------------------\")\n    print(\"| {: <24} | {: >6} |\".format(\"TOTAL\", total_lines))\n    print(\"-------------------------------------\")",
        "detail": "scripts.decomp_progress",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.decomp_progress",
        "description": "scripts.decomp_progress",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(dest='game', help='game name')\n    args = parser.parse_args()\n    gsrc_path = \"../goal_src/\" + args.game\n    all_files = get_goal_files(gsrc_path)\n    ref_files = get_goal_files(\"../test/decompiler/reference/\" + args.game, \"*_REF.gc\")\n    ref_files_no_ext = [os.path.basename(fn)[:-7] for fn in ref_files]\n    file_stats = []\n    total_gc_files = 0",
        "detail": "scripts.decomp_progress",
        "documentation": {}
    },
    {
        "label": "get_dgo_files",
        "kind": 2,
        "importPath": "scripts.gen-dgo-txt",
        "description": "scripts.gen-dgo-txt",
        "peekOfCode": "def get_dgo_files(path):\n    return glob(path + \"/**/*.go\", recursive=True)\ndef remove_extensions(file_list):\n    for file in file_list:\n        if (file.endswith(\"-bt.go\")):\n            os.rename(file, file[:-3].replace(\"-bt\", \"-vis\"))\n        elif file.endswith(\".go\"):\n            os.rename(file, file[:-3])\ndef move_to_root_folder(root_path, cur_path):\n    for filename in os.listdir(cur_path):",
        "detail": "scripts.gen-dgo-txt",
        "documentation": {}
    },
    {
        "label": "remove_extensions",
        "kind": 2,
        "importPath": "scripts.gen-dgo-txt",
        "description": "scripts.gen-dgo-txt",
        "peekOfCode": "def remove_extensions(file_list):\n    for file in file_list:\n        if (file.endswith(\"-bt.go\")):\n            os.rename(file, file[:-3].replace(\"-bt\", \"-vis\"))\n        elif file.endswith(\".go\"):\n            os.rename(file, file[:-3])\ndef move_to_root_folder(root_path, cur_path):\n    for filename in os.listdir(cur_path):\n        if os.path.isfile(os.path.join(cur_path, filename)):\n            shutil.move(os.path.join(cur_path, filename), os.path.join(root_path, filename))",
        "detail": "scripts.gen-dgo-txt",
        "documentation": {}
    },
    {
        "label": "move_to_root_folder",
        "kind": 2,
        "importPath": "scripts.gen-dgo-txt",
        "description": "scripts.gen-dgo-txt",
        "peekOfCode": "def move_to_root_folder(root_path, cur_path):\n    for filename in os.listdir(cur_path):\n        if os.path.isfile(os.path.join(cur_path, filename)):\n            shutil.move(os.path.join(cur_path, filename), os.path.join(root_path, filename))\n        elif os.path.isdir(os.path.join(cur_path, filename)):\n            move_to_root_folder(root_path, os.path.join(cur_path, filename))\n        else:\n            sys.exit(\"Should never reach here.\")\n    # remove empty folders\n    if cur_path != root_path:",
        "detail": "scripts.gen-dgo-txt",
        "documentation": {}
    },
    {
        "label": "gen_json_for_dgo",
        "kind": 2,
        "importPath": "scripts.gen-dgo-txt",
        "description": "scripts.gen-dgo-txt",
        "peekOfCode": "def gen_json_for_dgo(folder_name, files):\n    dgo_name = os.path.basename(Path(folder_name)) + \".DGO\"\n    dgo = {\n        \"file_name\": dgo_name,\n        \"internal_name\": dgo_name,\n        \"objects\": []\n    }\n    for file in files:\n        internal_name = \"\"\n        if \".\" in file:",
        "detail": "scripts.gen-dgo-txt",
        "documentation": {}
    },
    {
        "label": "gen_gd_file",
        "kind": 2,
        "importPath": "scripts.gen-dgo-txt",
        "description": "scripts.gen-dgo-txt",
        "peekOfCode": "def gen_gd_file(dgo_name, file_list):\n    # (\"SKATEPARK.DGO\"\n    #  (\"drill-turret-ext-ag.go\"\n    #   \"drill-turret-int-ag.go\"\n    #   \"jak-pole+0-ag.go\"\n    #   \"lazerfence-ag.go\"\n    #   \"lazerpit-ag.go\"\n    #   \"mech-ag.go\"\n    #   \"tpage-243.go\"\n    #   \"tpage-354.go\"",
        "detail": "scripts.gen-dgo-txt",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.gen-dgo-txt",
        "description": "scripts.gen-dgo-txt",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"dgo_folder\", type=str)\n    args = parser.parse_args()\n    # generate gd files for all dgo folders in current directory\n    # folders = [name for name in os.listdir(os.getcwd()) if os.path.isdir(os.path.join(os.getcwd(), name))]\n    # for folder in folders:\n    #     gen_gd_file(folder, get_dgo_files(folder))\n    files = get_dgo_files(args.dgo_folder)\n    gen_gd_file(args.dgo_folder, files)",
        "detail": "scripts.gen-dgo-txt",
        "documentation": {}
    },
    {
        "label": "dgo_json",
        "kind": 5,
        "importPath": "scripts.gen-dgo-txt",
        "description": "scripts.gen-dgo-txt",
        "peekOfCode": "dgo_json = {}\ndef get_dgo_files(path):\n    return glob(path + \"/**/*.go\", recursive=True)\ndef remove_extensions(file_list):\n    for file in file_list:\n        if (file.endswith(\"-bt.go\")):\n            os.rename(file, file[:-3].replace(\"-bt\", \"-vis\"))\n        elif file.endswith(\".go\"):\n            os.rename(file, file[:-3])\ndef move_to_root_folder(root_path, cur_path):",
        "detail": "scripts.gen-dgo-txt",
        "documentation": {}
    },
    {
        "label": "content",
        "kind": 5,
        "importPath": "scripts.gen-test-cases",
        "description": "scripts.gen-test-cases",
        "peekOfCode": "content = [x.strip() for x in content]\ntest_cases = {}\n# TODO - there is a bug in this code if we add test-cases with multiple lists of registers.\n# currently, its going to split too much breaking fragile assumptions.  Fix when required\nfor case in content:\n  if not case:\n    continue\n  args = re.split(\",(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\", case)\n  assembly_lines = args[0].replace(\"\\\\n\\\"\", \"\").replace(\"\\\"\", \"\").strip().split(\"\\\\n\")\n  instruction_summary = \"\"",
        "detail": "scripts.gen-test-cases",
        "documentation": {}
    },
    {
        "label": "test_cases",
        "kind": 5,
        "importPath": "scripts.gen-test-cases",
        "description": "scripts.gen-test-cases",
        "peekOfCode": "test_cases = {}\n# TODO - there is a bug in this code if we add test-cases with multiple lists of registers.\n# currently, its going to split too much breaking fragile assumptions.  Fix when required\nfor case in content:\n  if not case:\n    continue\n  args = re.split(\",(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\", case)\n  assembly_lines = args[0].replace(\"\\\\n\\\"\", \"\").replace(\"\\\"\", \"\").strip().split(\"\\\\n\")\n  instruction_summary = \"\"\n  instructions = []",
        "detail": "scripts.gen-test-cases",
        "documentation": {}
    },
    {
        "label": "p2s_name",
        "kind": 5,
        "importPath": "scripts.memory-dump-p2s",
        "description": "scripts.memory-dump-p2s",
        "peekOfCode": "p2s_name = input(\"Select savestate (.p2s) file (drag and drop):\")\nout_dir = input(\"Select output directory:\")\nif (p2s_name.startswith('\"')):\n  p2s_name = p2s_name[1:len(p2s_name)-1]\nif (out_dir.startswith('\"')):\n  out_dir = out_dir[1:len(out_dir)-1]\nwith zipfile.ZipFile(p2s_name, 'r') as p2s:\n  p2s.extractall(out_dir + \"/savestate_out\")\nprint(\"Savestate extracted\")",
        "detail": "scripts.memory-dump-p2s",
        "documentation": {}
    },
    {
        "label": "out_dir",
        "kind": 5,
        "importPath": "scripts.memory-dump-p2s",
        "description": "scripts.memory-dump-p2s",
        "peekOfCode": "out_dir = input(\"Select output directory:\")\nif (p2s_name.startswith('\"')):\n  p2s_name = p2s_name[1:len(p2s_name)-1]\nif (out_dir.startswith('\"')):\n  out_dir = out_dir[1:len(out_dir)-1]\nwith zipfile.ZipFile(p2s_name, 'r') as p2s:\n  p2s.extractall(out_dir + \"/savestate_out\")\nprint(\"Savestate extracted\")",
        "detail": "scripts.memory-dump-p2s",
        "documentation": {}
    },
    {
        "label": "get_goal_files",
        "kind": 2,
        "importPath": "scripts.setup_art_group_imports",
        "description": "scripts.setup_art_group_imports",
        "peekOfCode": "def get_goal_files(root_dir, ext = \"*.gc\"):\n    \"\"\"Get all GOAL source files under root_dir.\"\"\"\n    return [goal_file for file in os.walk(root_dir) for goal_file in glob.glob(os.path.join(file[0], ext))]\ndef get_sgs(goal_file):\n    \"\"\"Get a list of all the skel groups defined in the file, excluding the -sg and *'s.\"\"\"\n    with open(goal_file, \"r\") as f:\n        text = f.read()\n    # given \"(defskelgroup *foo* bar\", will match \"bar\"\n    matches = re.findall(r'\\(defskelgroup \\*[\\w-]+-sg\\* ([\\w-]+)', text)\n    return matches",
        "detail": "scripts.setup_art_group_imports",
        "documentation": {}
    },
    {
        "label": "get_sgs",
        "kind": 2,
        "importPath": "scripts.setup_art_group_imports",
        "description": "scripts.setup_art_group_imports",
        "peekOfCode": "def get_sgs(goal_file):\n    \"\"\"Get a list of all the skel groups defined in the file, excluding the -sg and *'s.\"\"\"\n    with open(goal_file, \"r\") as f:\n        text = f.read()\n    # given \"(defskelgroup *foo* bar\", will match \"bar\"\n    matches = re.findall(r'\\(defskelgroup \\*[\\w-]+-sg\\* ([\\w-]+)', text)\n    return matches\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(dest='goal_src', help='the goal_src folder')",
        "detail": "scripts.setup_art_group_imports",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.setup_art_group_imports",
        "description": "scripts.setup_art_group_imports",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(dest='goal_src', help='the goal_src folder')\n    args = parser.parse_args()\n    all_import_files = get_goal_files(os.path.join(args.goal_src, \"import\"))\n    all_files = get_goal_files(args.goal_src)\n    all_non_import_files = list(set(all_files) - set(all_import_files))\n    output_json = {}\n    to_modify = {}\n    import_map = {}",
        "detail": "scripts.setup_art_group_imports",
        "documentation": {}
    },
    {
        "label": "read_vag_list",
        "kind": 2,
        "importPath": "scripts.subtitle2_gen",
        "description": "scripts.subtitle2_gen",
        "peekOfCode": "def read_vag_list(file_name):\n    with open(file_name) as f:\n        for line in f:\n            vag_list.append(line.strip())\ndef gen_json_for_speaker(speaker):\n    sub = {\n        \"lines\": [\n            {\n                \"end\": 10000.0,\n                \"merge\": False,",
        "detail": "scripts.subtitle2_gen",
        "documentation": {}
    },
    {
        "label": "gen_json_for_speaker",
        "kind": 2,
        "importPath": "scripts.subtitle2_gen",
        "description": "scripts.subtitle2_gen",
        "peekOfCode": "def gen_json_for_speaker(speaker):\n    sub = {\n        \"lines\": [\n            {\n                \"end\": 10000.0,\n                \"merge\": False,\n                \"offscreen\": True,\n                \"speaker\": speaker,\n                \"start\": 0.0,\n                \"text\": \"TODO\",",
        "detail": "scripts.subtitle2_gen",
        "documentation": {}
    },
    {
        "label": "get_vags_for_speaker",
        "kind": 2,
        "importPath": "scripts.subtitle2_gen",
        "description": "scripts.subtitle2_gen",
        "peekOfCode": "def get_vags_for_speaker(speaker):\n    vags = []\n    names = speakers[speaker]\n    if not names:\n        return []\n    else:\n        reg = re.compile(names)\n        result = list(filter(reg.match, vag_list))\n        vags.extend(result)\n    return vags",
        "detail": "scripts.subtitle2_gen",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.subtitle2_gen",
        "description": "scripts.subtitle2_gen",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"vag_list\", type=str)\n    parser.add_argument(\"speaker\", type=str)\n    args = parser.parse_args()\n    read_vag_list(args.vag_list)\n    try:\n        vags = get_vags_for_speaker(args.speaker)\n    except KeyError:\n        print(\"No vags found for speaker \" + args.speaker)",
        "detail": "scripts.subtitle2_gen",
        "documentation": {}
    },
    {
        "label": "speakers",
        "kind": 5,
        "importPath": "scripts.subtitle2_gen",
        "description": "scripts.subtitle2_gen",
        "peekOfCode": "speakers = {\n    \"computer\": \"cityv[0-9]{3}$\",\n    \"jak\": \"(jak|jk|jd)[0-9]{3}$\",\n    \"darkjak\": \"\",\n    \"daxter\": \"(ds|dsek|dsbop)[0-9]{3}$\",\n    \"samos\": \"sam[0-9]{3}$\",\n    \"keira\": \"kei[0-9]{3}$\",\n    \"keira-before-class-3\": \"kei[0-9]{3}$\",\n    \"kid\": \"\",\n    \"kor\": \"kor[0-9]{3}$\",",
        "detail": "scripts.subtitle2_gen",
        "documentation": {}
    },
    {
        "label": "vag_list",
        "kind": 5,
        "importPath": "scripts.subtitle2_gen",
        "description": "scripts.subtitle2_gen",
        "peekOfCode": "vag_list = []\nsub_json = {}\ndef read_vag_list(file_name):\n    with open(file_name) as f:\n        for line in f:\n            vag_list.append(line.strip())\ndef gen_json_for_speaker(speaker):\n    sub = {\n        \"lines\": [\n            {",
        "detail": "scripts.subtitle2_gen",
        "documentation": {}
    },
    {
        "label": "sub_json",
        "kind": 5,
        "importPath": "scripts.subtitle2_gen",
        "description": "scripts.subtitle2_gen",
        "peekOfCode": "sub_json = {}\ndef read_vag_list(file_name):\n    with open(file_name) as f:\n        for line in f:\n            vag_list.append(line.strip())\ndef gen_json_for_speaker(speaker):\n    sub = {\n        \"lines\": [\n            {\n                \"end\": 10000.0,",
        "detail": "scripts.subtitle2_gen",
        "documentation": {}
    },
    {
        "label": "get_failures",
        "kind": 2,
        "importPath": "scripts.update_decomp_reference",
        "description": "scripts.update_decomp_reference",
        "peekOfCode": "def get_failures(root_dir):\n    return [\n        f\n        for file in os.walk(root_dir)\n        for f in glob.glob(os.path.join(file[0], \"*.gc\"))\n    ]\n# removesuffix only added in python 3.9....\ndef removesuffix(self: str, suffix: str, /) -> str:\n    if self.endswith(suffix):\n        return self[:-len(suffix)]",
        "detail": "scripts.update_decomp_reference",
        "documentation": {}
    },
    {
        "label": "removesuffix",
        "kind": 2,
        "importPath": "scripts.update_decomp_reference",
        "description": "scripts.update_decomp_reference",
        "peekOfCode": "def removesuffix(self: str, suffix: str, /) -> str:\n    if self.endswith(suffix):\n        return self[:-len(suffix)]\n    else:\n        return self[:]\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(dest=\"diff\", help=\"the failures folder\")\n    parser.add_argument(dest=\"reference\", help=\"the test/decompiler/reference folder\")\n    parser.add_argument(\"--game\", help=\"The name of the game (jak1/jak2)\", type=str)",
        "detail": "scripts.update_decomp_reference",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.update_decomp_reference",
        "description": "scripts.update_decomp_reference",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(dest=\"diff\", help=\"the failures folder\")\n    parser.add_argument(dest=\"reference\", help=\"the test/decompiler/reference folder\")\n    parser.add_argument(\"--game\", help=\"The name of the game (jak1/jak2)\", type=str)\n    args = parser.parse_args()\n    for replacement in get_failures(args.diff):\n        obj_name = removesuffix(os.path.basename(replacement), \".gc\").replace(\"_REF\", \"\")\n        # Find gsrc path, given game-name\n        ref_path = get_ref_path_from_filename(args.game, obj_name, args.reference)",
        "detail": "scripts.update_decomp_reference",
        "documentation": {}
    },
    {
        "label": "Caddy",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.caddy",
        "description": "third-party.curl.tests.http.testenv.caddy",
        "peekOfCode": "class Caddy:\n    def __init__(self, env: Env):\n        self.env = env\n        self._caddy = os.environ['CADDY'] if 'CADDY' in os.environ else env.caddy\n        self._caddy_dir = os.path.join(env.gen_dir, 'caddy')\n        self._docs_dir = os.path.join(self._caddy_dir, 'docs')\n        self._conf_file = os.path.join(self._caddy_dir, 'Caddyfile')\n        self._error_log = os.path.join(self._caddy_dir, 'caddy.log')\n        self._tmp_dir = os.path.join(self._caddy_dir, 'tmp')\n        self._process = None",
        "detail": "third-party.curl.tests.http.testenv.caddy",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.caddy",
        "description": "third-party.curl.tests.http.testenv.caddy",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass Caddy:\n    def __init__(self, env: Env):\n        self.env = env\n        self._caddy = os.environ['CADDY'] if 'CADDY' in os.environ else env.caddy\n        self._caddy_dir = os.path.join(env.gen_dir, 'caddy')\n        self._docs_dir = os.path.join(self._caddy_dir, 'docs')\n        self._conf_file = os.path.join(self._caddy_dir, 'Caddyfile')\n        self._error_log = os.path.join(self._caddy_dir, 'caddy.log')\n        self._tmp_dir = os.path.join(self._caddy_dir, 'tmp')",
        "detail": "third-party.curl.tests.http.testenv.caddy",
        "documentation": {}
    },
    {
        "label": "CertificateSpec",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.certs",
        "description": "third-party.curl.tests.http.testenv.certs",
        "peekOfCode": "class CertificateSpec:\n    def __init__(self, name: Optional[str] = None,\n                 domains: Optional[List[str]] = None,\n                 email: Optional[str] = None,\n                 key_type: Optional[str] = None,\n                 single_file: bool = False,\n                 valid_from: timedelta = timedelta(days=-1),\n                 valid_to: timedelta = timedelta(days=89),\n                 client: bool = False,\n                 sub_specs: Optional[List['CertificateSpec']] = None):",
        "detail": "third-party.curl.tests.http.testenv.certs",
        "documentation": {}
    },
    {
        "label": "Credentials",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.certs",
        "description": "third-party.curl.tests.http.testenv.certs",
        "peekOfCode": "class Credentials:\n    def __init__(self,\n                 name: str,\n                 cert: Any,\n                 pkey: Any,\n                 issuer: Optional['Credentials'] = None):\n        self._name = name\n        self._cert = cert\n        self._pkey = pkey\n        self._issuer = issuer",
        "detail": "third-party.curl.tests.http.testenv.certs",
        "documentation": {}
    },
    {
        "label": "CertStore",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.certs",
        "description": "third-party.curl.tests.http.testenv.certs",
        "peekOfCode": "class CertStore:\n    def __init__(self, fpath: str):\n        self._store_dir = fpath\n        if not os.path.exists(self._store_dir):\n            os.makedirs(self._store_dir)\n        self._creds_by_name = {}\n    @property\n    def path(self) -> str:\n        return self._store_dir\n    def save(self, creds: Credentials, name: Optional[str] = None,",
        "detail": "third-party.curl.tests.http.testenv.certs",
        "documentation": {}
    },
    {
        "label": "TestCA",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.certs",
        "description": "third-party.curl.tests.http.testenv.certs",
        "peekOfCode": "class TestCA:\n    @classmethod\n    def create_root(cls, name: str, store_dir: str, key_type: str = \"rsa2048\") -> Credentials:\n        store = CertStore(fpath=store_dir)\n        creds = store.load_credentials(name=\"ca\", key_type=key_type, issuer=None)\n        if creds is None:\n            creds = TestCA._make_ca_credentials(name=name, key_type=key_type)\n            store.save(creds, name=\"ca\")\n            creds.set_store(store)\n        return creds",
        "detail": "third-party.curl.tests.http.testenv.certs",
        "documentation": {}
    },
    {
        "label": "EC_SUPPORTED",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.certs",
        "description": "third-party.curl.tests.http.testenv.certs",
        "peekOfCode": "EC_SUPPORTED = {}\nEC_SUPPORTED.update([(curve.name.upper(), curve) for curve in [\n    ec.SECP192R1,\n    ec.SECP224R1,\n    ec.SECP256R1,\n    ec.SECP384R1,\n]])\ndef _private_key(key_type):\n    if isinstance(key_type, str):\n        key_type = key_type.upper()",
        "detail": "third-party.curl.tests.http.testenv.certs",
        "documentation": {}
    },
    {
        "label": "LocalClient",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.client",
        "description": "third-party.curl.tests.http.testenv.client",
        "peekOfCode": "class LocalClient:\n    def __init__(self, name: str, env: Env, run_dir: Optional[str] = None,\n                 timeout: Optional[float] = None):\n        self.name = name\n        self.path = os.path.join(env.project_dir, f'tests/http/clients/{name}')\n        self.env = env\n        self._timeout = timeout if timeout else env.test_timeout\n        self._curl = os.environ['CURL'] if 'CURL' in os.environ else env.curl\n        self._run_dir = run_dir if run_dir else os.path.join(env.gen_dir, name)\n        self._stdoutfile = f'{self._run_dir}/stdout'",
        "detail": "third-party.curl.tests.http.testenv.client",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.client",
        "description": "third-party.curl.tests.http.testenv.client",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass LocalClient:\n    def __init__(self, name: str, env: Env, run_dir: Optional[str] = None,\n                 timeout: Optional[float] = None):\n        self.name = name\n        self.path = os.path.join(env.project_dir, f'tests/http/clients/{name}')\n        self.env = env\n        self._timeout = timeout if timeout else env.test_timeout\n        self._curl = os.environ['CURL'] if 'CURL' in os.environ else env.curl\n        self._run_dir = run_dir if run_dir else os.path.join(env.gen_dir, name)",
        "detail": "third-party.curl.tests.http.testenv.client",
        "documentation": {}
    },
    {
        "label": "ExecResult",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.curl",
        "description": "third-party.curl.tests.http.testenv.curl",
        "peekOfCode": "class ExecResult:\n    def __init__(self, args: List[str], exit_code: int,\n                 stdout: List[str], stderr: List[str],\n                 duration: Optional[timedelta] = None,\n                 with_stats: bool = False,\n                 exception: Optional[str] = None):\n        self._args = args\n        self._exit_code = exit_code\n        self._exception = exception\n        self._stdout = stdout",
        "detail": "third-party.curl.tests.http.testenv.curl",
        "documentation": {}
    },
    {
        "label": "CurlClient",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.curl",
        "description": "third-party.curl.tests.http.testenv.curl",
        "peekOfCode": "class CurlClient:\n    ALPN_ARG = {\n        'http/0.9': '--http0.9',\n        'http/1.0': '--http1.0',\n        'http/1.1': '--http1.1',\n        'h2': '--http2',\n        'h2c': '--http2',\n        'h3': '--http3-only',\n    }\n    def __init__(self, env: Env, run_dir: Optional[str] = None,",
        "detail": "third-party.curl.tests.http.testenv.curl",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.curl",
        "description": "third-party.curl.tests.http.testenv.curl",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass ExecResult:\n    def __init__(self, args: List[str], exit_code: int,\n                 stdout: List[str], stderr: List[str],\n                 duration: Optional[timedelta] = None,\n                 with_stats: bool = False,\n                 exception: Optional[str] = None):\n        self._args = args\n        self._exit_code = exit_code\n        self._exception = exception",
        "detail": "third-party.curl.tests.http.testenv.curl",
        "documentation": {}
    },
    {
        "label": "EnvConfig",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.env",
        "description": "third-party.curl.tests.http.testenv.env",
        "peekOfCode": "class EnvConfig:\n    def __init__(self):\n        self.tests_dir = TESTS_HTTPD_PATH\n        self.gen_dir = os.path.join(self.tests_dir, 'gen')\n        self.project_dir = os.path.dirname(os.path.dirname(self.tests_dir))\n        self.config = DEF_CONFIG\n        # check cur and its features\n        self.curl = CURL\n        if 'CURL' in os.environ:\n            self.curl = os.environ['CURL']",
        "detail": "third-party.curl.tests.http.testenv.env",
        "documentation": {}
    },
    {
        "label": "Env",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.env",
        "description": "third-party.curl.tests.http.testenv.env",
        "peekOfCode": "class Env:\n    CONFIG = EnvConfig()\n    @staticmethod\n    def setup_incomplete() -> bool:\n        return not Env.CONFIG.is_complete()\n    @staticmethod\n    def incomplete_reason() -> Optional[str]:\n        return Env.CONFIG.get_incomplete_reason()\n    @staticmethod\n    def have_nghttpx() -> bool:",
        "detail": "third-party.curl.tests.http.testenv.env",
        "documentation": {}
    },
    {
        "label": "init_config_from",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.testenv.env",
        "description": "third-party.curl.tests.http.testenv.env",
        "peekOfCode": "def init_config_from(conf_path):\n    if os.path.isfile(conf_path):\n        config = ConfigParser(interpolation=ExtendedInterpolation())\n        config.read(conf_path)\n        return config\n    return None\nTESTS_HTTPD_PATH = os.path.dirname(os.path.dirname(__file__))\nDEF_CONFIG = init_config_from(os.path.join(TESTS_HTTPD_PATH, 'config.ini'))\nTOP_PATH = os.path.dirname(os.path.dirname(TESTS_HTTPD_PATH))\nCURL = os.path.join(TOP_PATH, 'src/curl')",
        "detail": "third-party.curl.tests.http.testenv.env",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.env",
        "description": "third-party.curl.tests.http.testenv.env",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef init_config_from(conf_path):\n    if os.path.isfile(conf_path):\n        config = ConfigParser(interpolation=ExtendedInterpolation())\n        config.read(conf_path)\n        return config\n    return None\nTESTS_HTTPD_PATH = os.path.dirname(os.path.dirname(__file__))\nDEF_CONFIG = init_config_from(os.path.join(TESTS_HTTPD_PATH, 'config.ini'))\nTOP_PATH = os.path.dirname(os.path.dirname(TESTS_HTTPD_PATH))",
        "detail": "third-party.curl.tests.http.testenv.env",
        "documentation": {}
    },
    {
        "label": "TESTS_HTTPD_PATH",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.env",
        "description": "third-party.curl.tests.http.testenv.env",
        "peekOfCode": "TESTS_HTTPD_PATH = os.path.dirname(os.path.dirname(__file__))\nDEF_CONFIG = init_config_from(os.path.join(TESTS_HTTPD_PATH, 'config.ini'))\nTOP_PATH = os.path.dirname(os.path.dirname(TESTS_HTTPD_PATH))\nCURL = os.path.join(TOP_PATH, 'src/curl')\nclass EnvConfig:\n    def __init__(self):\n        self.tests_dir = TESTS_HTTPD_PATH\n        self.gen_dir = os.path.join(self.tests_dir, 'gen')\n        self.project_dir = os.path.dirname(os.path.dirname(self.tests_dir))\n        self.config = DEF_CONFIG",
        "detail": "third-party.curl.tests.http.testenv.env",
        "documentation": {}
    },
    {
        "label": "DEF_CONFIG",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.env",
        "description": "third-party.curl.tests.http.testenv.env",
        "peekOfCode": "DEF_CONFIG = init_config_from(os.path.join(TESTS_HTTPD_PATH, 'config.ini'))\nTOP_PATH = os.path.dirname(os.path.dirname(TESTS_HTTPD_PATH))\nCURL = os.path.join(TOP_PATH, 'src/curl')\nclass EnvConfig:\n    def __init__(self):\n        self.tests_dir = TESTS_HTTPD_PATH\n        self.gen_dir = os.path.join(self.tests_dir, 'gen')\n        self.project_dir = os.path.dirname(os.path.dirname(self.tests_dir))\n        self.config = DEF_CONFIG\n        # check cur and its features",
        "detail": "third-party.curl.tests.http.testenv.env",
        "documentation": {}
    },
    {
        "label": "TOP_PATH",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.env",
        "description": "third-party.curl.tests.http.testenv.env",
        "peekOfCode": "TOP_PATH = os.path.dirname(os.path.dirname(TESTS_HTTPD_PATH))\nCURL = os.path.join(TOP_PATH, 'src/curl')\nclass EnvConfig:\n    def __init__(self):\n        self.tests_dir = TESTS_HTTPD_PATH\n        self.gen_dir = os.path.join(self.tests_dir, 'gen')\n        self.project_dir = os.path.dirname(os.path.dirname(self.tests_dir))\n        self.config = DEF_CONFIG\n        # check cur and its features\n        self.curl = CURL",
        "detail": "third-party.curl.tests.http.testenv.env",
        "documentation": {}
    },
    {
        "label": "CURL",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.env",
        "description": "third-party.curl.tests.http.testenv.env",
        "peekOfCode": "CURL = os.path.join(TOP_PATH, 'src/curl')\nclass EnvConfig:\n    def __init__(self):\n        self.tests_dir = TESTS_HTTPD_PATH\n        self.gen_dir = os.path.join(self.tests_dir, 'gen')\n        self.project_dir = os.path.dirname(os.path.dirname(self.tests_dir))\n        self.config = DEF_CONFIG\n        # check cur and its features\n        self.curl = CURL\n        if 'CURL' in os.environ:",
        "detail": "third-party.curl.tests.http.testenv.env",
        "documentation": {}
    },
    {
        "label": "Httpd",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.httpd",
        "description": "third-party.curl.tests.http.testenv.httpd",
        "peekOfCode": "class Httpd:\n    MODULES = [\n        'log_config', 'logio', 'unixd', 'version', 'watchdog',\n        'authn_core', 'authn_file',\n        'authz_user', 'authz_core', 'authz_host',\n        'auth_basic', 'auth_digest',\n        'alias', 'env', 'filter', 'headers', 'mime',\n        'socache_shmcb',\n        'rewrite', 'http2', 'ssl', 'proxy', 'proxy_http', 'proxy_connect',\n        'mpm_event',",
        "detail": "third-party.curl.tests.http.testenv.httpd",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.httpd",
        "description": "third-party.curl.tests.http.testenv.httpd",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass Httpd:\n    MODULES = [\n        'log_config', 'logio', 'unixd', 'version', 'watchdog',\n        'authn_core', 'authn_file',\n        'authz_user', 'authz_core', 'authz_host',\n        'auth_basic', 'auth_digest',\n        'alias', 'env', 'filter', 'headers', 'mime',\n        'socache_shmcb',\n        'rewrite', 'http2', 'ssl', 'proxy', 'proxy_http', 'proxy_connect',",
        "detail": "third-party.curl.tests.http.testenv.httpd",
        "documentation": {}
    },
    {
        "label": "Nghttpx",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.nghttpx",
        "description": "third-party.curl.tests.http.testenv.nghttpx",
        "peekOfCode": "class Nghttpx:\n    def __init__(self, env: Env, port: int, name: str):\n        self.env = env\n        self._name = name\n        self._port = port\n        self._cmd = env.nghttpx\n        self._run_dir = os.path.join(env.gen_dir, name)\n        self._pid_file = os.path.join(self._run_dir, 'nghttpx.pid')\n        self._conf_file = os.path.join(self._run_dir, 'nghttpx.conf')\n        self._error_log = os.path.join(self._run_dir, 'nghttpx.log')",
        "detail": "third-party.curl.tests.http.testenv.nghttpx",
        "documentation": {}
    },
    {
        "label": "NghttpxQuic",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.nghttpx",
        "description": "third-party.curl.tests.http.testenv.nghttpx",
        "peekOfCode": "class NghttpxQuic(Nghttpx):\n    def __init__(self, env: Env):\n        super().__init__(env=env, name='nghttpx-quic', port=env.h3_port)\n    def start(self, wait_live=True):\n        self._mkpath(self._tmp_dir)\n        if self._process:\n            self.stop()\n        args = [\n            self._cmd,\n            f'--frontend=*,{self.env.h3_port};quic',",
        "detail": "third-party.curl.tests.http.testenv.nghttpx",
        "documentation": {}
    },
    {
        "label": "NghttpxFwd",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.testenv.nghttpx",
        "description": "third-party.curl.tests.http.testenv.nghttpx",
        "peekOfCode": "class NghttpxFwd(Nghttpx):\n    def __init__(self, env: Env):\n        super().__init__(env=env, name='nghttpx-fwd', port=env.h2proxys_port)\n    def start(self, wait_live=True):\n        self._mkpath(self._tmp_dir)\n        if self._process:\n            self.stop()\n        args = [\n            self._cmd,\n            f'--http2-proxy',",
        "detail": "third-party.curl.tests.http.testenv.nghttpx",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.nghttpx",
        "description": "third-party.curl.tests.http.testenv.nghttpx",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass Nghttpx:\n    def __init__(self, env: Env, port: int, name: str):\n        self.env = env\n        self._name = name\n        self._port = port\n        self._cmd = env.nghttpx\n        self._run_dir = os.path.join(env.gen_dir, name)\n        self._pid_file = os.path.join(self._run_dir, 'nghttpx.pid')\n        self._conf_file = os.path.join(self._run_dir, 'nghttpx.conf')",
        "detail": "third-party.curl.tests.http.testenv.nghttpx",
        "documentation": {}
    },
    {
        "label": "alloc_ports",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.testenv.ports",
        "description": "third-party.curl.tests.http.testenv.ports",
        "peekOfCode": "def alloc_ports(port_specs: Dict[str, int]) -> Dict[str, int]:\n    ports = {}\n    socks = []\n    for name, ptype in port_specs.items():\n        try:\n            s = socket.socket(type=ptype)\n            s.bind(('', 0))\n            ports[name] = s.getsockname()[1]\n            socks.append(s)\n        except Exception as e:",
        "detail": "third-party.curl.tests.http.testenv.ports",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.testenv.ports",
        "description": "third-party.curl.tests.http.testenv.ports",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef alloc_ports(port_specs: Dict[str, int]) -> Dict[str, int]:\n    ports = {}\n    socks = []\n    for name, ptype in port_specs.items():\n        try:\n            s = socket.socket(type=ptype)\n            s.bind(('', 0))\n            ports[name] = s.getsockname()[1]\n            socks.append(s)",
        "detail": "third-party.curl.tests.http.testenv.ports",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.testenv.ws_echo_server",
        "description": "third-party.curl.tests.http.testenv.ws_echo_server",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(prog='scorecard', description=\"\"\"\n        Run a websocket echo server.\n        \"\"\")\n    parser.add_argument(\"--port\", type=int,\n                        default=9876, help=\"port to listen on\")\n    args = parser.parse_args()\n    logging.basicConfig(\n        format=\"%(asctime)s %(message)s\",\n        level=logging.DEBUG,",
        "detail": "third-party.curl.tests.http.testenv.ws_echo_server",
        "documentation": {}
    },
    {
        "label": "env",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.conftest",
        "description": "third-party.curl.tests.http.conftest",
        "peekOfCode": "def env(pytestconfig) -> Env:\n    env = Env(pytestconfig=pytestconfig)\n    level = logging.DEBUG if env.verbose > 0 else logging.INFO\n    logging.getLogger('').setLevel(level=level)\n    if not env.curl_has_protocol('http'):\n        pytest.skip(\"curl built without HTTP support\")\n    if not env.curl_has_protocol('https'):\n        pytest.skip(\"curl built without HTTPS support\")\n    if env.setup_incomplete():\n        pytest.skip(env.incomplete_reason())",
        "detail": "third-party.curl.tests.http.conftest",
        "documentation": {}
    },
    {
        "label": "log_global_env_facts",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.conftest",
        "description": "third-party.curl.tests.http.conftest",
        "peekOfCode": "def log_global_env_facts(record_testsuite_property, env):\n    record_testsuite_property(\"http-port\", env.http_port)\n@pytest.fixture(scope='package')\ndef httpd(env) -> Httpd:\n    httpd = Httpd(env=env)\n    if not httpd.exists():\n        pytest.skip(f'httpd not found: {env.httpd}')\n    httpd.clear_logs()\n    if not httpd.start():\n        pytest.fail(f'failed to start httpd: {env.httpd}')",
        "detail": "third-party.curl.tests.http.conftest",
        "documentation": {}
    },
    {
        "label": "httpd",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.conftest",
        "description": "third-party.curl.tests.http.conftest",
        "peekOfCode": "def httpd(env) -> Httpd:\n    httpd = Httpd(env=env)\n    if not httpd.exists():\n        pytest.skip(f'httpd not found: {env.httpd}')\n    httpd.clear_logs()\n    if not httpd.start():\n        pytest.fail(f'failed to start httpd: {env.httpd}')\n    yield httpd\n    httpd.stop()\n@pytest.fixture(scope='package')",
        "detail": "third-party.curl.tests.http.conftest",
        "documentation": {}
    },
    {
        "label": "nghttpx",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.conftest",
        "description": "third-party.curl.tests.http.conftest",
        "peekOfCode": "def nghttpx(env, httpd) -> Optional[Nghttpx]:\n    nghttpx = NghttpxQuic(env=env)\n    if env.have_h3():\n        nghttpx.clear_logs()\n        assert nghttpx.start()\n    yield nghttpx\n    nghttpx.stop()\n@pytest.fixture(scope='package')\ndef nghttpx_fwd(env, httpd) -> Optional[Nghttpx]:\n    nghttpx = NghttpxFwd(env=env)",
        "detail": "third-party.curl.tests.http.conftest",
        "documentation": {}
    },
    {
        "label": "nghttpx_fwd",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.conftest",
        "description": "third-party.curl.tests.http.conftest",
        "peekOfCode": "def nghttpx_fwd(env, httpd) -> Optional[Nghttpx]:\n    nghttpx = NghttpxFwd(env=env)\n    if env.have_h3():\n        nghttpx.clear_logs()\n        assert nghttpx.start()\n    yield nghttpx\n    nghttpx.stop()",
        "detail": "third-party.curl.tests.http.conftest",
        "documentation": {}
    },
    {
        "label": "ScoreCardException",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.scorecard",
        "description": "third-party.curl.tests.http.scorecard",
        "peekOfCode": "class ScoreCardException(Exception):\n    pass\nclass ScoreCard:\n    def __init__(self, env: Env,\n                 httpd: Optional[Httpd],\n                 nghttpx: Optional[Nghttpx],\n                 caddy: Optional[Caddy],\n                 verbose: int,\n                 curl_verbose: int):\n        self.verbose = verbose",
        "detail": "third-party.curl.tests.http.scorecard",
        "documentation": {}
    },
    {
        "label": "ScoreCard",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.scorecard",
        "description": "third-party.curl.tests.http.scorecard",
        "peekOfCode": "class ScoreCard:\n    def __init__(self, env: Env,\n                 httpd: Optional[Httpd],\n                 nghttpx: Optional[Nghttpx],\n                 caddy: Optional[Caddy],\n                 verbose: int,\n                 curl_verbose: int):\n        self.verbose = verbose\n        self.env = env\n        self.httpd = httpd",
        "detail": "third-party.curl.tests.http.scorecard",
        "documentation": {}
    },
    {
        "label": "parse_size",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.scorecard",
        "description": "third-party.curl.tests.http.scorecard",
        "peekOfCode": "def parse_size(s):\n    m = re.match(r'(\\d+)(mb|kb|gb)?', s, re.IGNORECASE)\n    if m is None:\n        raise Exception(f'unrecognized size: {s}')\n    size = int(m.group(1))\n    if m.group(2).lower() == 'kb':\n        size *= 1024\n    elif m.group(2).lower() == 'mb':\n        size *= 1024 * 1024\n    elif m.group(2).lower() == 'gb':",
        "detail": "third-party.curl.tests.http.scorecard",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "third-party.curl.tests.http.scorecard",
        "description": "third-party.curl.tests.http.scorecard",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(prog='scorecard', description=\"\"\"\n        Run a range of tests to give a scorecard for a HTTP protocol\n        'h3' or 'h2' implementation in curl.\n        \"\"\")\n    parser.add_argument(\"-v\", \"--verbose\", action='count', default=1,\n                        help=\"log more output on stderr\")\n    parser.add_argument(\"-j\", \"--json\", action='store_true',\n                        default=False, help=\"print json instead of text\")\n    parser.add_argument(\"-H\", \"--handshakes\", action='store_true',",
        "detail": "third-party.curl.tests.http.scorecard",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.scorecard",
        "description": "third-party.curl.tests.http.scorecard",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass ScoreCardException(Exception):\n    pass\nclass ScoreCard:\n    def __init__(self, env: Env,\n                 httpd: Optional[Httpd],\n                 nghttpx: Optional[Nghttpx],\n                 caddy: Optional[Caddy],\n                 verbose: int,\n                 curl_verbose: int):",
        "detail": "third-party.curl.tests.http.scorecard",
        "documentation": {}
    },
    {
        "label": "TestBasic",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_01_basic",
        "description": "third-party.curl.tests.http.test_01_basic",
        "peekOfCode": "class TestBasic:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n    # simple http: GET\n    def test_01_01_http_get(self, env: Env, httpd):\n        curl = CurlClient(env=env)\n        url = f'http://{env.domain1}:{env.http_port}/data.json'\n        r = curl.http_get(url=url)",
        "detail": "third-party.curl.tests.http.test_01_basic",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_01_basic",
        "description": "third-party.curl.tests.http.test_01_basic",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestBasic:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n    # simple http: GET\n    def test_01_01_http_get(self, env: Env, httpd):\n        curl = CurlClient(env=env)\n        url = f'http://{env.domain1}:{env.http_port}/data.json'",
        "detail": "third-party.curl.tests.http.test_01_basic",
        "documentation": {}
    },
    {
        "label": "TestDownload",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_02_download",
        "description": "third-party.curl.tests.http.test_02_download",
        "peekOfCode": "class TestDownload:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd):\n        indir = httpd.docs_dir",
        "detail": "third-party.curl.tests.http.test_02_download",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_02_download",
        "description": "third-party.curl.tests.http.test_02_download",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestDownload:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd):",
        "detail": "third-party.curl.tests.http.test_02_download",
        "documentation": {}
    },
    {
        "label": "TestGoAway",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_03_goaway",
        "description": "third-party.curl.tests.http.test_03_goaway",
        "peekOfCode": "class TestGoAway:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()\n    # download files sequentially with delay, reload server for GOAWAY\n    def test_03_01_h2_goaway(self, env: Env, httpd, nghttpx, repeat):\n        proto = 'h2'",
        "detail": "third-party.curl.tests.http.test_03_goaway",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_03_goaway",
        "description": "third-party.curl.tests.http.test_03_goaway",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestGoAway:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()\n    # download files sequentially with delay, reload server for GOAWAY\n    def test_03_01_h2_goaway(self, env: Env, httpd, nghttpx, repeat):",
        "detail": "third-party.curl.tests.http.test_03_goaway",
        "documentation": {}
    },
    {
        "label": "TestStuttered",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_04_stuttered",
        "description": "third-party.curl.tests.http.test_04_stuttered",
        "peekOfCode": "class TestStuttered:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()\n    # download 1 file, check that delayed response works in general\n    @pytest.mark.parametrize(\"proto\", ['http/1.1', 'h2', 'h3'])\n    def test_04_01_download_1(self, env: Env, httpd, nghttpx, repeat,",
        "detail": "third-party.curl.tests.http.test_04_stuttered",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_04_stuttered",
        "description": "third-party.curl.tests.http.test_04_stuttered",
        "peekOfCode": "log = logging.getLogger(__name__)\n@pytest.mark.skipif(condition=Env().slow_network, reason=\"not suitable for slow network tests\")\n@pytest.mark.skipif(condition=Env().ci_run, reason=\"not suitable for CI runs\")\nclass TestStuttered:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()",
        "detail": "third-party.curl.tests.http.test_04_stuttered",
        "documentation": {}
    },
    {
        "label": "TestErrors",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_05_errors",
        "description": "third-party.curl.tests.http.test_05_errors",
        "peekOfCode": "class TestErrors:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()\n    # download 1 file, check that we get CURLE_PARTIAL_FILE\n    @pytest.mark.parametrize(\"proto\", ['http/1.1', 'h2', 'h3'])\n    def test_05_01_partial_1(self, env: Env, httpd, nghttpx, repeat,",
        "detail": "third-party.curl.tests.http.test_05_errors",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_05_errors",
        "description": "third-party.curl.tests.http.test_05_errors",
        "peekOfCode": "log = logging.getLogger(__name__)\n@pytest.mark.skipif(condition=not Env.httpd_is_at_least('2.4.55'),\n                    reason=f\"httpd version too old for this: {Env.httpd_version()}\")\nclass TestErrors:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()",
        "detail": "third-party.curl.tests.http.test_05_errors",
        "documentation": {}
    },
    {
        "label": "TestEyeballs",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_06_eyeballs",
        "description": "third-party.curl.tests.http.test_06_eyeballs",
        "peekOfCode": "class TestEyeballs:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()\n    # download using only HTTP/3 on working server\n    @pytest.mark.skipif(condition=not Env.have_h3(), reason=f\"missing HTTP/3 support\")\n    def test_06_01_h3_only(self, env: Env, httpd, nghttpx, repeat):",
        "detail": "third-party.curl.tests.http.test_06_eyeballs",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_06_eyeballs",
        "description": "third-party.curl.tests.http.test_06_eyeballs",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestEyeballs:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.reload()\n    # download using only HTTP/3 on working server\n    @pytest.mark.skipif(condition=not Env.have_h3(), reason=f\"missing HTTP/3 support\")",
        "detail": "third-party.curl.tests.http.test_06_eyeballs",
        "documentation": {}
    },
    {
        "label": "TestUpload",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_07_upload",
        "description": "third-party.curl.tests.http.test_07_upload",
        "peekOfCode": "class TestUpload:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        env.make_data_file(indir=env.gen_dir, fname=\"data-63k\", fsize=63*1024)\n        env.make_data_file(indir=env.gen_dir, fname=\"data-64k\", fsize=64*1024)\n        env.make_data_file(indir=env.gen_dir, fname=\"data-100k\", fsize=100*1024)\n        env.make_data_file(indir=env.gen_dir, fname=\"data-10m\", fsize=10*1024*1024)\n        httpd.clear_extra_configs()",
        "detail": "third-party.curl.tests.http.test_07_upload",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_07_upload",
        "description": "third-party.curl.tests.http.test_07_upload",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestUpload:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        env.make_data_file(indir=env.gen_dir, fname=\"data-63k\", fsize=63*1024)\n        env.make_data_file(indir=env.gen_dir, fname=\"data-64k\", fsize=64*1024)\n        env.make_data_file(indir=env.gen_dir, fname=\"data-100k\", fsize=100*1024)\n        env.make_data_file(indir=env.gen_dir, fname=\"data-10m\", fsize=10*1024*1024)",
        "detail": "third-party.curl.tests.http.test_07_upload",
        "documentation": {}
    },
    {
        "label": "TestCaddy",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_08_caddy",
        "description": "third-party.curl.tests.http.test_08_caddy",
        "peekOfCode": "class TestCaddy:\n    @pytest.fixture(autouse=True, scope='class')\n    def caddy(self, env):\n        caddy = Caddy(env=env)\n        assert caddy.start()\n        yield caddy\n        caddy.stop()\n    def _make_docs_file(self, docs_dir: str, fname: str, fsize: int):\n        fpath = os.path.join(docs_dir, fname)\n        data1k = 1024*'x'",
        "detail": "third-party.curl.tests.http.test_08_caddy",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_08_caddy",
        "description": "third-party.curl.tests.http.test_08_caddy",
        "peekOfCode": "log = logging.getLogger(__name__)\n@pytest.mark.skipif(condition=not Env.has_caddy(), reason=f\"missing caddy\")\n@pytest.mark.skipif(condition=not Env.have_ssl_curl(), reason=f\"curl without SSL\")\nclass TestCaddy:\n    @pytest.fixture(autouse=True, scope='class')\n    def caddy(self, env):\n        caddy = Caddy(env=env)\n        assert caddy.start()\n        yield caddy\n        caddy.stop()",
        "detail": "third-party.curl.tests.http.test_08_caddy",
        "documentation": {}
    },
    {
        "label": "TestPush",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_09_push",
        "description": "third-party.curl.tests.http.test_09_push",
        "peekOfCode": "class TestPush:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd):\n        push_dir = os.path.join(httpd.docs_dir, 'push')\n        if not os.path.exists(push_dir):\n            os.makedirs(push_dir)\n        env.make_data_file(indir=push_dir, fname=\"data1\", fsize=1*1024)\n        env.make_data_file(indir=push_dir, fname=\"data2\", fsize=1*1024)\n        env.make_data_file(indir=push_dir, fname=\"data3\", fsize=1*1024)\n        httpd.set_extra_config(env.domain1, [",
        "detail": "third-party.curl.tests.http.test_09_push",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_09_push",
        "description": "third-party.curl.tests.http.test_09_push",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestPush:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd):\n        push_dir = os.path.join(httpd.docs_dir, 'push')\n        if not os.path.exists(push_dir):\n            os.makedirs(push_dir)\n        env.make_data_file(indir=push_dir, fname=\"data1\", fsize=1*1024)\n        env.make_data_file(indir=push_dir, fname=\"data2\", fsize=1*1024)\n        env.make_data_file(indir=push_dir, fname=\"data3\", fsize=1*1024)",
        "detail": "third-party.curl.tests.http.test_09_push",
        "documentation": {}
    },
    {
        "label": "TestProxy",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_10_proxy",
        "description": "third-party.curl.tests.http.test_10_proxy",
        "peekOfCode": "class TestProxy:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx_fwd):\n        push_dir = os.path.join(httpd.docs_dir, 'push')\n        if not os.path.exists(push_dir):\n            os.makedirs(push_dir)\n        if env.have_nghttpx():\n            nghttpx_fwd.start_if_needed()\n        env.make_data_file(indir=env.gen_dir, fname=\"data-100k\", fsize=100*1024)\n        env.make_data_file(indir=env.gen_dir, fname=\"data-10m\", fsize=10*1024*1024)",
        "detail": "third-party.curl.tests.http.test_10_proxy",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_10_proxy",
        "description": "third-party.curl.tests.http.test_10_proxy",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestProxy:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx_fwd):\n        push_dir = os.path.join(httpd.docs_dir, 'push')\n        if not os.path.exists(push_dir):\n            os.makedirs(push_dir)\n        if env.have_nghttpx():\n            nghttpx_fwd.start_if_needed()\n        env.make_data_file(indir=env.gen_dir, fname=\"data-100k\", fsize=100*1024)",
        "detail": "third-party.curl.tests.http.test_10_proxy",
        "documentation": {}
    },
    {
        "label": "UDSFaker",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_11_unix",
        "description": "third-party.curl.tests.http.test_11_unix",
        "peekOfCode": "class UDSFaker:\n    def __init__(self, path):\n        self._uds_path = path\n        self._done = False\n    @property\n    def path(self):\n        return self._uds_path\n    def start(self):\n        def process(self):\n            self._socket.listen(1)",
        "detail": "third-party.curl.tests.http.test_11_unix",
        "documentation": {}
    },
    {
        "label": "TestUnix",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_11_unix",
        "description": "third-party.curl.tests.http.test_11_unix",
        "peekOfCode": "class TestUnix:\n    @pytest.fixture(scope=\"class\")\n    def uds_faker(self, env: Env) -> UDSFaker:\n        uds_path = os.path.join(env.gen_dir, 'uds_11.sock')\n        faker = UDSFaker(path=uds_path)\n        faker.start()\n        yield faker\n        faker.stop()\n    # download http: via unix socket\n    def test_11_01_unix_connect_http(self, env: Env, httpd, uds_faker, repeat):",
        "detail": "third-party.curl.tests.http.test_11_unix",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_11_unix",
        "description": "third-party.curl.tests.http.test_11_unix",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass UDSFaker:\n    def __init__(self, path):\n        self._uds_path = path\n        self._done = False\n    @property\n    def path(self):\n        return self._uds_path\n    def start(self):\n        def process(self):",
        "detail": "third-party.curl.tests.http.test_11_unix",
        "documentation": {}
    },
    {
        "label": "TestReuse",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_12_reuse",
        "description": "third-party.curl.tests.http.test_12_reuse",
        "peekOfCode": "class TestReuse:\n    # check if HTTP/1.1 handles 'Connection: close' correctly\n    @pytest.mark.parametrize(\"proto\", ['http/1.1'])\n    def test_12_01_h1_conn_close(self, env: Env,\n                                 httpd, nghttpx, repeat, proto):\n        httpd.clear_extra_configs()\n        httpd.set_extra_config('base', [\n            f'MaxKeepAliveRequests 1',\n        ])\n        httpd.reload()",
        "detail": "third-party.curl.tests.http.test_12_reuse",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_12_reuse",
        "description": "third-party.curl.tests.http.test_12_reuse",
        "peekOfCode": "log = logging.getLogger(__name__)\n@pytest.mark.skipif(condition=Env.curl_uses_lib('bearssl'), reason='BearSSL too slow')\n@pytest.mark.skipif(condition=not Env.have_ssl_curl(), reason=f\"curl without SSL\")\nclass TestReuse:\n    # check if HTTP/1.1 handles 'Connection: close' correctly\n    @pytest.mark.parametrize(\"proto\", ['http/1.1'])\n    def test_12_01_h1_conn_close(self, env: Env,\n                                 httpd, nghttpx, repeat, proto):\n        httpd.clear_extra_configs()\n        httpd.set_extra_config('base', [",
        "detail": "third-party.curl.tests.http.test_12_reuse",
        "documentation": {}
    },
    {
        "label": "TestProxyAuth",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_13_proxy_auth",
        "description": "third-party.curl.tests.http.test_13_proxy_auth",
        "peekOfCode": "class TestProxyAuth:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx_fwd):\n        if env.have_nghttpx():\n            nghttpx_fwd.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.set_proxy_auth(True)\n        httpd.reload()\n        yield\n        httpd.set_proxy_auth(False)",
        "detail": "third-party.curl.tests.http.test_13_proxy_auth",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_13_proxy_auth",
        "description": "third-party.curl.tests.http.test_13_proxy_auth",
        "peekOfCode": "log = logging.getLogger(__name__)\n@pytest.mark.skipif(condition=Env.setup_incomplete(),\n                    reason=f\"missing: {Env.incomplete_reason()}\")\nclass TestProxyAuth:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx_fwd):\n        if env.have_nghttpx():\n            nghttpx_fwd.start_if_needed()\n        httpd.clear_extra_configs()\n        httpd.set_proxy_auth(True)",
        "detail": "third-party.curl.tests.http.test_13_proxy_auth",
        "documentation": {}
    },
    {
        "label": "TestAuth",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_14_auth",
        "description": "third-party.curl.tests.http.test_14_auth",
        "peekOfCode": "class TestAuth:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        env.make_data_file(indir=env.gen_dir, fname=\"data-10m\", fsize=10*1024*1024)\n        httpd.clear_extra_configs()\n        httpd.reload()\n    # download 1 file, not authenticated\n    @pytest.mark.parametrize(\"proto\", ['http/1.1', 'h2', 'h3'])",
        "detail": "third-party.curl.tests.http.test_14_auth",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_14_auth",
        "description": "third-party.curl.tests.http.test_14_auth",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestAuth:\n    @pytest.fixture(autouse=True, scope='class')\n    def _class_scope(self, env, httpd, nghttpx):\n        if env.have_h3():\n            nghttpx.start_if_needed()\n        env.make_data_file(indir=env.gen_dir, fname=\"data-10m\", fsize=10*1024*1024)\n        httpd.clear_extra_configs()\n        httpd.reload()\n    # download 1 file, not authenticated",
        "detail": "third-party.curl.tests.http.test_14_auth",
        "documentation": {}
    },
    {
        "label": "TestTracing",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_15_tracing",
        "description": "third-party.curl.tests.http.test_15_tracing",
        "peekOfCode": "class TestTracing:\n    # default verbose output\n    def test_15_01_trace_defaults(self, env: Env, httpd):\n        curl = CurlClient(env=env)\n        url = f'http://{env.domain1}:{env.http_port}/data.json'\n        r = curl.http_get(url=url, def_tracing=False, extra_args=[\n            '-v'\n        ])\n        r.check_response(http_status=200)\n        trace = r.trace_lines",
        "detail": "third-party.curl.tests.http.test_15_tracing",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_15_tracing",
        "description": "third-party.curl.tests.http.test_15_tracing",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TestTracing:\n    # default verbose output\n    def test_15_01_trace_defaults(self, env: Env, httpd):\n        curl = CurlClient(env=env)\n        url = f'http://{env.domain1}:{env.http_port}/data.json'\n        r = curl.http_get(url=url, def_tracing=False, extra_args=[\n            '-v'\n        ])\n        r.check_response(http_status=200)",
        "detail": "third-party.curl.tests.http.test_15_tracing",
        "documentation": {}
    },
    {
        "label": "TestWebsockets",
        "kind": 6,
        "importPath": "third-party.curl.tests.http.test_20_websockets",
        "description": "third-party.curl.tests.http.test_20_websockets",
        "peekOfCode": "class TestWebsockets:\n    def check_alive(self, env, timeout=5):\n        curl = CurlClient(env=env)\n        url = f'http://localhost:{env.ws_port}/'\n        end = datetime.now() + timedelta(seconds=timeout)\n        while datetime.now() < end:\n            r = curl.http_download(urls=[url])\n            if r.exit_code == 0:\n                return True\n            time.sleep(.1)",
        "detail": "third-party.curl.tests.http.test_20_websockets",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.http.test_20_websockets",
        "description": "third-party.curl.tests.http.test_20_websockets",
        "peekOfCode": "log = logging.getLogger(__name__)\n@pytest.mark.skipif(condition=not Env.curl_has_protocol('ws'),\n                    reason='curl lacks ws protocol support')\nclass TestWebsockets:\n    def check_alive(self, env, timeout=5):\n        curl = CurlClient(env=env)\n        url = f'http://localhost:{env.ws_port}/'\n        end = datetime.now() + timedelta(seconds=timeout)\n        while datetime.now() < end:\n            r = curl.http_download(urls=[url])",
        "detail": "third-party.curl.tests.http.test_20_websockets",
        "documentation": {}
    },
    {
        "label": "pytest_report_header",
        "kind": 2,
        "importPath": "third-party.curl.tests.conftest",
        "description": "third-party.curl.tests.conftest",
        "peekOfCode": "def pytest_report_header(config, startdir):\n    # Env inits its base properties only once, we can report them here\n    env = Env()\n    report = [\n        f'Testing curl {env.curl_version()}',\n        f'  httpd: {env.httpd_version()}, http:{env.http_port} https:{env.https_port}',\n        f'  httpd-proxy: {env.httpd_version()}, http:{env.proxy_port} https:{env.proxys_port}'\n    ]\n    if env.have_h3():\n        report.extend([",
        "detail": "third-party.curl.tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "third-party.curl.tests.conftest",
        "description": "third-party.curl.tests.conftest",
        "peekOfCode": "def pytest_addoption(parser):\n    parser.addoption(\"--repeat\", action=\"store\", type=int, default=1,\n                     help='Number of times to repeat each test')\ndef pytest_generate_tests(metafunc):\n    if \"repeat\" in metafunc.fixturenames:\n        count = int(metafunc.config.getoption(\"repeat\"))\n        metafunc.fixturenames.append('tmp_ct')\n        metafunc.parametrize('repeat', range(count))",
        "detail": "third-party.curl.tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_generate_tests",
        "kind": 2,
        "importPath": "third-party.curl.tests.conftest",
        "description": "third-party.curl.tests.conftest",
        "peekOfCode": "def pytest_generate_tests(metafunc):\n    if \"repeat\" in metafunc.fixturenames:\n        count = int(metafunc.config.getoption(\"repeat\"))\n        metafunc.fixturenames.append('tmp_ct')\n        metafunc.parametrize('repeat', range(count))",
        "detail": "third-party.curl.tests.conftest",
        "documentation": {}
    },
    {
        "label": "DictHandler",
        "kind": 6,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "class DictHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handler class for DICT connections.\n    \"\"\"\n    def handle(self):\n        \"\"\"\n        Simple function which responds to all queries with a 552.\n        \"\"\"\n        try:\n            # First, send a response to allow the server to continue.\n            rsp = \"220 dictserver <xnooptions> <msgid@msgid>\\n\"",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "ScriptRC",
        "kind": 6,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "class ScriptRC(object):\n    \"\"\"Enum for script return codes\"\"\"\n    SUCCESS = 0\n    FAILURE = 1\n    EXCEPTION = 2\nclass ScriptException(Exception):\n    pass\nif __name__ == '__main__':\n    # Get the options from the user.\n    options = get_options()",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "ScriptException",
        "kind": 6,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "class ScriptException(Exception):\n    pass\nif __name__ == '__main__':\n    # Get the options from the user.\n    options = get_options()\n    # Setup logging using the user options\n    setup_logging(options)\n    # Run main script.\n    try:\n        rc = dictserver(options)",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "dictserver",
        "kind": 2,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "def dictserver(options):\n    \"\"\"\n    Starts up a TCP server with a DICT handler and serves DICT requests\n    forever.\n    \"\"\"\n    if options.pidfile:\n        pid = os.getpid()\n        # see tests/server/util.c function write_pidfile\n        if os.name == \"nt\":\n            pid += 65536",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "get_options",
        "kind": 2,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "def get_options():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--port\", action=\"store\", default=9016,\n                        type=int, help=\"port to listen on\")\n    parser.add_argument(\"--host\", action=\"store\", default=HOST,\n                        help=\"host to listen on\")\n    parser.add_argument(\"--verbose\", action=\"store\", type=int, default=0,\n                        help=\"verbose output\")\n    parser.add_argument(\"--pidfile\", action=\"store\",\n                        help=\"file name for the PID\")",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "def setup_logging(options):\n    \"\"\"\n    Set up logging from the command line options\n    \"\"\"\n    root_logger = logging.getLogger()\n    add_stdout = False\n    formatter = logging.Formatter(\"%(asctime)s %(levelname)-5.5s %(message)s\")\n    # Write out to a logfile\n    if options.logfile:\n        handler = ClosingFileHandler(options.logfile)",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "log = logging.getLogger(__name__)\nHOST = \"localhost\"\n# The strings that indicate the test framework is checking our aliveness\nVERIFIED_REQ = b\"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\"\ndef dictserver(options):\n    \"\"\"\n    Starts up a TCP server with a DICT handler and serves DICT requests\n    forever.\n    \"\"\"",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "HOST = \"localhost\"\n# The strings that indicate the test framework is checking our aliveness\nVERIFIED_REQ = b\"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\"\ndef dictserver(options):\n    \"\"\"\n    Starts up a TCP server with a DICT handler and serves DICT requests\n    forever.\n    \"\"\"\n    if options.pidfile:",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "VERIFIED_REQ",
        "kind": 5,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "VERIFIED_REQ = b\"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\"\ndef dictserver(options):\n    \"\"\"\n    Starts up a TCP server with a DICT handler and serves DICT requests\n    forever.\n    \"\"\"\n    if options.pidfile:\n        pid = os.getpid()\n        # see tests/server/util.c function write_pidfile",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "VERIFIED_RSP",
        "kind": 5,
        "importPath": "third-party.curl.tests.dictserver",
        "description": "third-party.curl.tests.dictserver",
        "peekOfCode": "VERIFIED_RSP = \"WE ROOLZ: {pid}\"\ndef dictserver(options):\n    \"\"\"\n    Starts up a TCP server with a DICT handler and serves DICT requests\n    forever.\n    \"\"\"\n    if options.pidfile:\n        pid = os.getpid()\n        # see tests/server/util.c function write_pidfile\n        if os.name == \"nt\":",
        "detail": "third-party.curl.tests.dictserver",
        "documentation": {}
    },
    {
        "label": "NegotiatingTelnetHandler",
        "kind": 6,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "class NegotiatingTelnetHandler(socketserver.BaseRequestHandler):\n    \"\"\"Handler class for Telnet connections.\n    \"\"\"\n    def handle(self):\n        \"\"\"\n        Negotiates options before reading data.\n        \"\"\"\n        neg = Negotiator(self.request)\n        try:\n            # Send some initial negotiations.",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "Negotiator",
        "kind": 6,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "class Negotiator(object):\n    NO_NEG = 0\n    START_NEG = 1\n    WILL = 2\n    WONT = 3\n    DO = 4\n    DONT = 5\n    def __init__(self, tcp):\n        self.tcp = tcp\n        self.state = self.NO_NEG",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "NegBase",
        "kind": 6,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "class NegBase(object):\n    @classmethod\n    def to_val(cls, name):\n        return getattr(cls, name)\n    @classmethod\n    def from_val(cls, val):\n        for k in cls.__dict__.keys():\n            if getattr(cls, k) == val:\n                return k\n        return \"<unknown>\"",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "NegTokens",
        "kind": 6,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "class NegTokens(NegBase):\n    # The start of a negotiation sequence\n    IAC = 255\n    # Confirm willingness to negotiate\n    WILL = 251\n    # Confirm unwillingness to negotiate\n    WONT = 252\n    # Indicate willingness to negotiate\n    DO = 253\n    # Indicate unwillingness to negotiate",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "NegOptions",
        "kind": 6,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "class NegOptions(NegBase):\n    # Binary Transmission\n    BINARY = 0\n    # Suppress Go Ahead\n    SUPPRESS_GO_AHEAD = 3\n    # NAWS - width and height of client\n    NAWS = 31\n    # NEW-ENVIRON - environment variables on client\n    NEW_ENVIRON = 39\n    # Charset option",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "ScriptRC",
        "kind": 6,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "class ScriptRC(object):\n    \"\"\"Enum for script return codes\"\"\"\n    SUCCESS = 0\n    FAILURE = 1\n    EXCEPTION = 2\nclass ScriptException(Exception):\n    pass\nif __name__ == '__main__':\n    # Get the options from the user.\n    options = get_options()",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "ScriptException",
        "kind": 6,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "class ScriptException(Exception):\n    pass\nif __name__ == '__main__':\n    # Get the options from the user.\n    options = get_options()\n    # Setup logging using the user options\n    setup_logging(options)\n    # Run main script.\n    try:\n        rc = telnetserver(options)",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "telnetserver",
        "kind": 2,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "def telnetserver(options):\n    \"\"\"\n    Starts up a TCP server with a telnet handler and serves DICT requests\n    forever.\n    \"\"\"\n    if options.pidfile:\n        pid = os.getpid()\n        # see tests/server/util.c function write_pidfile\n        if os.name == \"nt\":\n            pid += 65536",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "get_options",
        "kind": 2,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "def get_options():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--port\", action=\"store\", default=9019,\n                        type=int, help=\"port to listen on\")\n    parser.add_argument(\"--verbose\", action=\"store\", type=int, default=0,\n                        help=\"verbose output\")\n    parser.add_argument(\"--pidfile\", action=\"store\",\n                        help=\"file name for the PID\")\n    parser.add_argument(\"--logfile\", action=\"store\",\n                        help=\"file name for the log\")",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "def setup_logging(options):\n    \"\"\"\n    Set up logging from the command line options\n    \"\"\"\n    root_logger = logging.getLogger()\n    add_stdout = False\n    formatter = logging.Formatter(\"%(asctime)s %(levelname)-5.5s \"\n                                  \"[{ident}] %(message)s\"\n                                  .format(ident=IDENT))\n    # Write out to a logfile",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "log = logging.getLogger(__name__)\nHOST = \"localhost\"\nIDENT = \"NTEL\"\n# The strings that indicate the test framework is checking our aliveness\nVERIFIED_REQ = \"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\"\ndef telnetserver(options):\n    \"\"\"\n    Starts up a TCP server with a telnet handler and serves DICT requests\n    forever.",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "HOST",
        "kind": 5,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "HOST = \"localhost\"\nIDENT = \"NTEL\"\n# The strings that indicate the test framework is checking our aliveness\nVERIFIED_REQ = \"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\"\ndef telnetserver(options):\n    \"\"\"\n    Starts up a TCP server with a telnet handler and serves DICT requests\n    forever.\n    \"\"\"",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "IDENT",
        "kind": 5,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "IDENT = \"NTEL\"\n# The strings that indicate the test framework is checking our aliveness\nVERIFIED_REQ = \"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\"\ndef telnetserver(options):\n    \"\"\"\n    Starts up a TCP server with a telnet handler and serves DICT requests\n    forever.\n    \"\"\"\n    if options.pidfile:",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "VERIFIED_REQ",
        "kind": 5,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "VERIFIED_REQ = \"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\"\ndef telnetserver(options):\n    \"\"\"\n    Starts up a TCP server with a telnet handler and serves DICT requests\n    forever.\n    \"\"\"\n    if options.pidfile:\n        pid = os.getpid()\n        # see tests/server/util.c function write_pidfile",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "VERIFIED_RSP",
        "kind": 5,
        "importPath": "third-party.curl.tests.negtelnetserver",
        "description": "third-party.curl.tests.negtelnetserver",
        "peekOfCode": "VERIFIED_RSP = \"WE ROOLZ: {pid}\"\ndef telnetserver(options):\n    \"\"\"\n    Starts up a TCP server with a telnet handler and serves DICT requests\n    forever.\n    \"\"\"\n    if options.pidfile:\n        pid = os.getpid()\n        # see tests/server/util.c function write_pidfile\n        if os.name == \"nt\":",
        "detail": "third-party.curl.tests.negtelnetserver",
        "documentation": {}
    },
    {
        "label": "ShutdownHandler",
        "kind": 6,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "class ShutdownHandler(threading.Thread):\n    \"\"\"Cleanly shut down the SMB server\n    This can only be done from another thread while the server is in\n    serve_forever(), so a thread is spawned here that waits for a shutdown\n    signal before doing its thing. Use in a with statement around the\n    serve_forever() call.\n    \"\"\"\n    def __init__(self, server):\n        super(ShutdownHandler, self).__init__()\n        self.server = server",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "TestSmbServer",
        "kind": 6,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "class TestSmbServer(imp_smbserver.SMBSERVER):\n    \"\"\"\n    Test server for SMB which subclasses the impacket SMBSERVER and provides\n    test functionality.\n    \"\"\"\n    def __init__(self,\n                 address,\n                 config_parser=None,\n                 test_data_directory=None):\n        imp_smbserver.SMBSERVER.__init__(self,",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "SmbException",
        "kind": 6,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "class SmbException(Exception):\n    def __init__(self, error_code, error_message):\n        super(SmbException, self).__init__(error_message)\n        self.error_code = error_code\nclass ScriptRC(object):\n    \"\"\"Enum for script return codes\"\"\"\n    SUCCESS = 0\n    FAILURE = 1\n    EXCEPTION = 2\nclass ScriptException(Exception):",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "ScriptRC",
        "kind": 6,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "class ScriptRC(object):\n    \"\"\"Enum for script return codes\"\"\"\n    SUCCESS = 0\n    FAILURE = 1\n    EXCEPTION = 2\nclass ScriptException(Exception):\n    pass\ndef get_options():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--port\", action=\"store\", default=9017,",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "ScriptException",
        "kind": 6,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "class ScriptException(Exception):\n    pass\ndef get_options():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--port\", action=\"store\", default=9017,\n                      type=int, help=\"port to listen on\")\n    parser.add_argument(\"--host\", action=\"store\", default=\"127.0.0.1\",\n                      help=\"host to listen on\")\n    parser.add_argument(\"--verbose\", action=\"store\", type=int, default=0,\n                        help=\"verbose output\")",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "smbserver",
        "kind": 2,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "def smbserver(options):\n    \"\"\"Start up a TCP SMB server that serves forever\n    \"\"\"\n    if options.pidfile:\n        pid = os.getpid()\n        # see tests/server/util.c function write_pidfile\n        if os.name == \"nt\":\n            pid += 65536\n        with open(options.pidfile, \"w\") as f:\n            f.write(str(pid))",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "get_options",
        "kind": 2,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "def get_options():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--port\", action=\"store\", default=9017,\n                      type=int, help=\"port to listen on\")\n    parser.add_argument(\"--host\", action=\"store\", default=\"127.0.0.1\",\n                      help=\"host to listen on\")\n    parser.add_argument(\"--verbose\", action=\"store\", type=int, default=0,\n                        help=\"verbose output\")\n    parser.add_argument(\"--pidfile\", action=\"store\",\n                        help=\"file name for the PID\")",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "def setup_logging(options):\n    \"\"\"\n    Set up logging from the command line options\n    \"\"\"\n    root_logger = logging.getLogger()\n    add_stdout = False\n    formatter = logging.Formatter(\"%(asctime)s %(levelname)-5.5s %(message)s\")\n    # Write out to a logfile\n    if options.logfile:\n        handler = ClosingFileHandler(options.logfile)",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "log = logging.getLogger(__name__)\nSERVER_MAGIC = \"SERVER_MAGIC\"\nTESTS_MAGIC = \"TESTS_MAGIC\"\nVERIFIED_REQ = \"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\\n\"\nclass ShutdownHandler(threading.Thread):\n    \"\"\"Cleanly shut down the SMB server\n    This can only be done from another thread while the server is in\n    serve_forever(), so a thread is spawned here that waits for a shutdown\n    signal before doing its thing. Use in a with statement around the",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "SERVER_MAGIC",
        "kind": 5,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "SERVER_MAGIC = \"SERVER_MAGIC\"\nTESTS_MAGIC = \"TESTS_MAGIC\"\nVERIFIED_REQ = \"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\\n\"\nclass ShutdownHandler(threading.Thread):\n    \"\"\"Cleanly shut down the SMB server\n    This can only be done from another thread while the server is in\n    serve_forever(), so a thread is spawned here that waits for a shutdown\n    signal before doing its thing. Use in a with statement around the\n    serve_forever() call.",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "TESTS_MAGIC",
        "kind": 5,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "TESTS_MAGIC = \"TESTS_MAGIC\"\nVERIFIED_REQ = \"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\\n\"\nclass ShutdownHandler(threading.Thread):\n    \"\"\"Cleanly shut down the SMB server\n    This can only be done from another thread while the server is in\n    serve_forever(), so a thread is spawned here that waits for a shutdown\n    signal before doing its thing. Use in a with statement around the\n    serve_forever() call.\n    \"\"\"",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "VERIFIED_REQ",
        "kind": 5,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "VERIFIED_REQ = \"verifiedserver\"\nVERIFIED_RSP = \"WE ROOLZ: {pid}\\n\"\nclass ShutdownHandler(threading.Thread):\n    \"\"\"Cleanly shut down the SMB server\n    This can only be done from another thread while the server is in\n    serve_forever(), so a thread is spawned here that waits for a shutdown\n    signal before doing its thing. Use in a with statement around the\n    serve_forever() call.\n    \"\"\"\n    def __init__(self, server):",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "VERIFIED_RSP",
        "kind": 5,
        "importPath": "third-party.curl.tests.smbserver",
        "description": "third-party.curl.tests.smbserver",
        "peekOfCode": "VERIFIED_RSP = \"WE ROOLZ: {pid}\\n\"\nclass ShutdownHandler(threading.Thread):\n    \"\"\"Cleanly shut down the SMB server\n    This can only be done from another thread while the server is in\n    serve_forever(), so a thread is spawned here that waits for a shutdown\n    signal before doing its thing. Use in a with statement around the\n    serve_forever() call.\n    \"\"\"\n    def __init__(self, server):\n        super(ShutdownHandler, self).__init__()",
        "detail": "third-party.curl.tests.smbserver",
        "documentation": {}
    },
    {
        "label": "ClosingFileHandler",
        "kind": 6,
        "importPath": "third-party.curl.tests.util",
        "description": "third-party.curl.tests.util",
        "peekOfCode": "class ClosingFileHandler(logging.StreamHandler):\n    def __init__(self, filename):\n        super(ClosingFileHandler, self).__init__()\n        self.filename = os.path.abspath(filename)\n        self.setStream(None)\n    def emit(self, record):\n        with open(self.filename, \"a\") as fp:\n            self.setStream(fp)\n            super(ClosingFileHandler, self).emit(record)\n            self.setStream(None)",
        "detail": "third-party.curl.tests.util",
        "documentation": {}
    },
    {
        "label": "TestData",
        "kind": 6,
        "importPath": "third-party.curl.tests.util",
        "description": "third-party.curl.tests.util",
        "peekOfCode": "class TestData(object):\n    def __init__(self, data_folder):\n        self.data_folder = data_folder\n    def get_test_data(self, test_number):\n        # Create the test file name\n        filename = os.path.join(self.data_folder,\n                                \"test{0}\".format(test_number))\n        log.debug(\"Parsing file %s\", filename)\n        with open(filename, \"rb\") as f:\n            contents = f.read().decode(\"utf-8\")",
        "detail": "third-party.curl.tests.util",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "third-party.curl.tests.util",
        "description": "third-party.curl.tests.util",
        "peekOfCode": "log = logging.getLogger(__name__)\nREPLY_DATA = re.compile(\"<reply>[ \\t\\n\\r]*<data[^<]*>(.*?)</data>\", re.MULTILINE | re.DOTALL)\nclass ClosingFileHandler(logging.StreamHandler):\n    def __init__(self, filename):\n        super(ClosingFileHandler, self).__init__()\n        self.filename = os.path.abspath(filename)\n        self.setStream(None)\n    def emit(self, record):\n        with open(self.filename, \"a\") as fp:\n            self.setStream(fp)",
        "detail": "third-party.curl.tests.util",
        "documentation": {}
    },
    {
        "label": "REPLY_DATA",
        "kind": 5,
        "importPath": "third-party.curl.tests.util",
        "description": "third-party.curl.tests.util",
        "peekOfCode": "REPLY_DATA = re.compile(\"<reply>[ \\t\\n\\r]*<data[^<]*>(.*?)</data>\", re.MULTILINE | re.DOTALL)\nclass ClosingFileHandler(logging.StreamHandler):\n    def __init__(self, filename):\n        super(ClosingFileHandler, self).__init__()\n        self.filename = os.path.abspath(filename)\n        self.setStream(None)\n    def emit(self, record):\n        with open(self.filename, \"a\") as fp:\n            self.setStream(fp)\n            super(ClosingFileHandler, self).emit(record)",
        "detail": "third-party.curl.tests.util",
        "documentation": {}
    },
    {
        "label": "get_platform",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def get_platform():\n    \"\"\" a name for the platform \"\"\"\n    if sys.platform.startswith('win'):\n        return 'win'\n    elif sys.platform == 'darwin':\n        return 'osx'\n    elif sys.platform.startswith('linux'):\n        return 'linux'\n    raise Exception('Unsupported platform ' + sys.platform)\nSCRIPT_PATH = os.path.dirname(os.path.abspath(__file__))",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "get_signtool",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def get_signtool():\n    \"\"\" get path to code signing tool \"\"\"\n    if PLATFORM == 'win':\n        sdk_dir = 'c:\\\\Program Files (x86)\\\\Windows Kits\\\\10'  # os.environ['WindowsSdkDir']\n        return os.path.join(sdk_dir, 'bin', 'x86', 'signtool.exe')\n    elif PLATFORM == 'osx':\n        return '/usr/bin/codesign'\n@contextmanager\ndef cd(new_dir):\n    \"\"\" Temporarily change current directory \"\"\"",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "cd",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def cd(new_dir):\n    \"\"\" Temporarily change current directory \"\"\"\n    if new_dir:\n        old_dir = os.getcwd()\n        os.chdir(new_dir)\n    yield\n    if new_dir:\n        os.chdir(old_dir)\ndef mkdir_p(path):\n    \"\"\" mkdir -p \"\"\"",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "mkdir_p",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def mkdir_p(path):\n    \"\"\" mkdir -p \"\"\"\n    if not os.path.isdir(path):\n        click.secho('Making ' + path, fg='yellow')\n        os.makedirs(path)\n@click.group(invoke_without_command=True)\n@click.pass_context\n@click.option('--clean', is_flag=True)\ndef cli(ctx, clean):\n    \"\"\" click wrapper for command line stuff \"\"\"",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def cli(ctx, clean):\n    \"\"\" click wrapper for command line stuff \"\"\"\n    if ctx.invoked_subcommand is None:\n        ctx.invoke(libs, clean=clean)\n        if IS_BUILD_MACHINE:\n            ctx.invoke(sign)\n        ctx.invoke(archive)\n@cli.command()\n@click.pass_context\ndef unity(ctx):",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "unity",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def unity(ctx):\n    \"\"\" build just dynamic libs for use in unity project \"\"\"\n    ctx.invoke(libs, clean=False, static=False, shared=True, skip_formatter=True, just_release=True)\n    BUILDS = []\n    click.echo('--- Copying libs and header into unity example')\n    UNITY_PROJECT_PATH = os.path.join(SCRIPT_PATH, 'examples', 'button-clicker', 'Assets', 'Plugins')\n    if sys.platform.startswith('win'):\n        LIBRARY_NAME = 'discord-rpc.dll'\n        BUILD_64_BASE_PATH = os.path.join(SCRIPT_PATH, 'builds', 'win64-dynamic', 'src', 'Release')\n        UNITY_64_DLL_PATH = os.path.join(UNITY_PROJECT_PATH, 'x86_64')",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "unreal",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def unreal(ctx):\n    \"\"\" build libs and copy them into the unreal project \"\"\"\n    ctx.invoke(libs, clean=False, static=False, shared=True, skip_formatter=True, just_release=True)\n    BUILDS = []\n    click.echo('--- Copying libs and header into unreal example')\n    UNREAL_PROJECT_PATH = os.path.join(SCRIPT_PATH, 'examples', 'unrealstatus', 'Plugins', 'discordrpc')\n    UNREAL_INCLUDE_PATH = os.path.join(UNREAL_PROJECT_PATH, 'Source', 'ThirdParty', 'DiscordRpcLibrary', 'Include')\n    mkdir_p(UNREAL_INCLUDE_PATH)\n    shutil.copy(os.path.join(SCRIPT_PATH, 'include', 'discord_rpc.h'), UNREAL_INCLUDE_PATH)\n    if sys.platform.startswith('win'):",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "build_lib",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def build_lib(build_name, generator, options, just_release):\n    \"\"\" Create a dir under builds, run build and install in it \"\"\"\n    build_path = os.path.join(SCRIPT_PATH, 'builds', build_name)\n    install_path = os.path.join(INSTALL_ROOT, build_name)\n    mkdir_p(build_path)\n    mkdir_p(install_path)\n    with cd(build_path):\n        initial_cmake = ['cmake', SCRIPT_PATH, '-DCMAKE_INSTALL_PREFIX=%s' % os.path.join('..', 'install', build_name)]\n        if generator:\n            initial_cmake.extend(['-G', generator])",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "archive",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def archive():\n    \"\"\" create zip of install dir \"\"\"\n    click.echo('--- Archiving')\n    archive_file_path = os.path.join(SCRIPT_PATH, 'builds', 'discord-rpc-%s.zip' % get_platform())\n    archive_file = zipfile.ZipFile(archive_file_path, 'w', zipfile.ZIP_DEFLATED)\n    archive_src_base_path = INSTALL_ROOT\n    archive_dst_base_path = 'discord-rpc'\n    with cd(archive_src_base_path):\n        for path, _, filenames in os.walk('.'):\n            for fname in filenames:",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "sign",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def sign():\n    \"\"\" Do code signing within install directory using our cert \"\"\"\n    tool = get_signtool()\n    signable_extensions = set()\n    if PLATFORM == 'win':\n        signable_extensions.add('.dll')\n        sign_command_base = [\n            tool,\n            'sign',\n            '/n',",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "libs",
        "kind": 2,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "def libs(clean, static, shared, skip_formatter, just_release):\n    \"\"\" Do all the builds for this platform \"\"\"\n    if clean:\n        shutil.rmtree('builds', ignore_errors=True)\n    mkdir_p('builds')\n    if not (static or shared):\n        static = True\n        shared = True\n    static_options = {}\n    dynamic_options = {",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "SCRIPT_PATH",
        "kind": 5,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "SCRIPT_PATH = os.path.dirname(os.path.abspath(__file__))\n# we use Buildkite which sets this env variable by default\nIS_BUILD_MACHINE = os.environ.get('CI', '') == 'true'\nPLATFORM = get_platform()\nINSTALL_ROOT = os.path.join(SCRIPT_PATH, 'builds', 'install')\ndef get_signtool():\n    \"\"\" get path to code signing tool \"\"\"\n    if PLATFORM == 'win':\n        sdk_dir = 'c:\\\\Program Files (x86)\\\\Windows Kits\\\\10'  # os.environ['WindowsSdkDir']\n        return os.path.join(sdk_dir, 'bin', 'x86', 'signtool.exe')",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "IS_BUILD_MACHINE",
        "kind": 5,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "IS_BUILD_MACHINE = os.environ.get('CI', '') == 'true'\nPLATFORM = get_platform()\nINSTALL_ROOT = os.path.join(SCRIPT_PATH, 'builds', 'install')\ndef get_signtool():\n    \"\"\" get path to code signing tool \"\"\"\n    if PLATFORM == 'win':\n        sdk_dir = 'c:\\\\Program Files (x86)\\\\Windows Kits\\\\10'  # os.environ['WindowsSdkDir']\n        return os.path.join(sdk_dir, 'bin', 'x86', 'signtool.exe')\n    elif PLATFORM == 'osx':\n        return '/usr/bin/codesign'",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "PLATFORM",
        "kind": 5,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "PLATFORM = get_platform()\nINSTALL_ROOT = os.path.join(SCRIPT_PATH, 'builds', 'install')\ndef get_signtool():\n    \"\"\" get path to code signing tool \"\"\"\n    if PLATFORM == 'win':\n        sdk_dir = 'c:\\\\Program Files (x86)\\\\Windows Kits\\\\10'  # os.environ['WindowsSdkDir']\n        return os.path.join(sdk_dir, 'bin', 'x86', 'signtool.exe')\n    elif PLATFORM == 'osx':\n        return '/usr/bin/codesign'\n@contextmanager",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "INSTALL_ROOT",
        "kind": 5,
        "importPath": "third-party.discord-rpc.build",
        "description": "third-party.discord-rpc.build",
        "peekOfCode": "INSTALL_ROOT = os.path.join(SCRIPT_PATH, 'builds', 'install')\ndef get_signtool():\n    \"\"\" get path to code signing tool \"\"\"\n    if PLATFORM == 'win':\n        sdk_dir = 'c:\\\\Program Files (x86)\\\\Windows Kits\\\\10'  # os.environ['WindowsSdkDir']\n        return os.path.join(sdk_dir, 'bin', 'x86', 'signtool.exe')\n    elif PLATFORM == 'osx':\n        return '/usr/bin/codesign'\n@contextmanager\ndef cd(new_dir):",
        "detail": "third-party.discord-rpc.build",
        "documentation": {}
    },
    {
        "label": "cmake_get_available_generators",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def cmake_get_available_generators():\n  \"\"\"Returns list of generators available in current CMake executable.\"\"\"\n  result = run_process_and_capture_output(f'{CMAKE} --help')\n  if result[0] != 0:\n    raise Exception(f'cmake --help failed, exit code: {result[0]}\\n{result[1]}')\n  help_text = result[1].splitlines()\n  generators_start_index = help_text.index('Generators') + 3\n  generators_text = help_text[generators_start_index::]\n  generators = []\n  for gen in generators_text:",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "cmake_get_generator",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def cmake_get_generator():\n  \"\"\"Returns the CMake generator from CMakeCache.txt in the current dir.\"\"\"\n  cmake_cache_file_path = os.path.join(os.getcwd(), 'CMakeCache.txt')\n  cmake_cache_text = ''\n  with open(cmake_cache_file_path, 'r') as cmake_cache_file:\n    cmake_cache_text = cmake_cache_file.read()\n  if not cmake_cache_text:\n    raise FileNotFoundError(f'{cmake_cache_file_path} missing or empty.')\n  generator = ''\n  for line in cmake_cache_text.splitlines():",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "run_process_and_capture_output",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def run_process_and_capture_output(cmd, env=None):\n  \"\"\"Runs |cmd| as a child process.\n  Returns process exit code and output. Streams process output to stdout when\n  VERBOSE is true.\n  Args:\n    cmd: String containing the command to execute.\n    env: Optional dict of environment variables.\n  Returns:\n    Tuple of exit code and output.\n  \"\"\"",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "create_output_directories",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def create_output_directories():\n  \"\"\"Creates the build output directores for the test.\"\"\"\n  pathlib.Path(DRACO_SHARED_BUILD_PATH).mkdir(parents=True, exist_ok=True)\n  pathlib.Path(DRACO_STATIC_BUILD_PATH).mkdir(parents=True, exist_ok=True)\n  pathlib.Path(TEST_SHARED_BUILD_PATH).mkdir(parents=True, exist_ok=True)\n  pathlib.Path(TEST_STATIC_BUILD_PATH).mkdir(parents=True, exist_ok=True)\ndef cleanup():\n  \"\"\"Removes the build output directories from the test.\"\"\"\n  shutil.rmtree(DRACO_SHARED_BUILD_PATH)\n  shutil.rmtree(DRACO_STATIC_BUILD_PATH)",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "cleanup",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def cleanup():\n  \"\"\"Removes the build output directories from the test.\"\"\"\n  shutil.rmtree(DRACO_SHARED_BUILD_PATH)\n  shutil.rmtree(DRACO_STATIC_BUILD_PATH)\n  shutil.rmtree(DRACO_SHARED_INSTALL_PATH)\n  shutil.rmtree(DRACO_STATIC_INSTALL_PATH)\n  shutil.rmtree(TEST_SHARED_BUILD_PATH)\n  shutil.rmtree(TEST_STATIC_BUILD_PATH)\n  shutil.rmtree(TEST_SHARED_INSTALL_PATH)\n  shutil.rmtree(TEST_STATIC_INSTALL_PATH)",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "cmake_configure",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def cmake_configure(source_path, cmake_args=None):\n  \"\"\"Configures a CMake build.\"\"\"\n  command = f'{CMAKE} {source_path}'\n  if CMAKE_GENERATOR:\n    if ' ' in CMAKE_GENERATOR:\n      command += f' -G \"{CMAKE_GENERATOR}\"'\n    else:\n      command += f' -G {CMAKE_GENERATOR}'\n  if cmake_args:\n    for arg in cmake_args:",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "cmake_build",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def cmake_build(cmake_args=None, build_args=None):\n  \"\"\"Runs a CMake build.\"\"\"\n  command = f'{CMAKE} --build .'\n  if cmake_args:\n    for arg in cmake_args:\n      command += f' {arg}'\n  if not build_args:\n    build_args = []\n  generator = cmake_get_generator()\n  if generator.endswith('Makefiles'):",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "run_install_check",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def run_install_check(install_path):\n  \"\"\"Runs the install_check program.\"\"\"\n  cmd = os.path.join(install_path, 'bin', 'install_check')\n  if VERBOSE:\n    print(f'RUN command: {cmd}')\n  result = run_process_and_capture_output(\n      cmd,\n      # On Windows, add location of draco.dll into PATH env var\n      {'PATH': DRACO_SHARED_INSTALL_BIN_PATH + os.pathsep + os.environ['PATH']},\n    )",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "build_and_install_transcoder_dependencies",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def build_and_install_transcoder_dependencies():\n  \"\"\"Builds and installs Draco dependencies for transcoder enabled builds.\"\"\"\n  orig_dir = os.getcwd()\n  # The Eigen CMake build in the release Draco has pinned is, to put it mildly,\n  # user unfriendly. Instead of wasting time trying to integrate it here, just\n  # shutil.copytree() everything in $eigen_submodule_path to\n  # $CMAKE_INSTALL_PREFIX/include/Eigen.\n  # Eigen claims to be header-only, so this should be adequate for Draco's\n  # needs here.\n  eigen_submodule_path = os.path.join(",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "build_and_install_draco",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def build_and_install_draco():\n  \"\"\"Builds Draco in shared and static configurations.\"\"\"\n  orig_dir = os.getcwd()\n  if ENABLE_TRANSCODER:\n    build_and_install_transcoder_dependencies()\n  # Build and install Draco in shared library config for the current host\n  # machine.\n  os.chdir(DRACO_SHARED_BUILD_PATH)\n  cmake_args = []\n  cmake_args.append(f'-DCMAKE_INSTALL_PREFIX={DRACO_SHARED_INSTALL_PATH}')",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "build_test_project",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def build_test_project():\n  \"\"\"Builds the test application in shared and static configurations.\"\"\"\n  orig_dir = os.getcwd()\n  # Configure the test project against draco shared and build it.\n  os.chdir(TEST_SHARED_BUILD_PATH)\n  cmake_args = []\n  cmake_args.append(f'-DCMAKE_INSTALL_PREFIX={TEST_SHARED_INSTALL_PATH}')\n  cmake_args.append(f'-DCMAKE_PREFIX_PATH={DRACO_SHARED_INSTALL_PATH}')\n  cmake_args.append(f'-DCMAKE_INSTALL_RPATH={DRACO_SHARED_INSTALL_LIB_PATH}')\n  cmake_configure(source_path=f'{TEST_SOURCES_PATH}', cmake_args=cmake_args)",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "test_draco_install",
        "kind": 2,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "def test_draco_install():\n  create_output_directories()\n  build_and_install_draco()\n  build_test_project()\n  cleanup()\nif __name__ == '__main__':\n  CMAKE_AVAILABLE_GENERATORS = cmake_get_available_generators()\n  parser = argparse.ArgumentParser()\n  parser.add_argument(\n      '-G', '--generator', help='CMake builds use the specified generator.')",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "CMAKE",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "CMAKE = shutil.which('cmake')\n# List of generators available in the current CMake executable.\nCMAKE_AVAILABLE_GENERATORS = []\n# List of variable defs to be passed through to CMake via its -D argument.\nCMAKE_DEFINES = []\n# CMake builds use the specified generator.\nCMAKE_GENERATOR = None\n# Enable the transcoder before running tests (sets DRACO_TRANSCODER_SUPPORTED\n# and builds transcoder support dependencies).\nENABLE_TRANSCODER = False",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "CMAKE_AVAILABLE_GENERATORS",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "CMAKE_AVAILABLE_GENERATORS = []\n# List of variable defs to be passed through to CMake via its -D argument.\nCMAKE_DEFINES = []\n# CMake builds use the specified generator.\nCMAKE_GENERATOR = None\n# Enable the transcoder before running tests (sets DRACO_TRANSCODER_SUPPORTED\n# and builds transcoder support dependencies).\nENABLE_TRANSCODER = False\n# The Draco tree that this script uses.\nDRACO_SOURCES_PATH = os.path.abspath(os.path.join('..', '..', '..', '..'))",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "CMAKE_DEFINES",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "CMAKE_DEFINES = []\n# CMake builds use the specified generator.\nCMAKE_GENERATOR = None\n# Enable the transcoder before running tests (sets DRACO_TRANSCODER_SUPPORTED\n# and builds transcoder support dependencies).\nENABLE_TRANSCODER = False\n# The Draco tree that this script uses.\nDRACO_SOURCES_PATH = os.path.abspath(os.path.join('..', '..', '..', '..'))\n# Path to this script and the rest of the test project files.\nTEST_SOURCES_PATH = os.path.dirname(os.path.abspath(__file__))",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "CMAKE_GENERATOR",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "CMAKE_GENERATOR = None\n# Enable the transcoder before running tests (sets DRACO_TRANSCODER_SUPPORTED\n# and builds transcoder support dependencies).\nENABLE_TRANSCODER = False\n# The Draco tree that this script uses.\nDRACO_SOURCES_PATH = os.path.abspath(os.path.join('..', '..', '..', '..'))\n# Path to this script and the rest of the test project files.\nTEST_SOURCES_PATH = os.path.dirname(os.path.abspath(__file__))\n# The Draco build directories.\nDRACO_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_shared')",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "ENABLE_TRANSCODER",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "ENABLE_TRANSCODER = False\n# The Draco tree that this script uses.\nDRACO_SOURCES_PATH = os.path.abspath(os.path.join('..', '..', '..', '..'))\n# Path to this script and the rest of the test project files.\nTEST_SOURCES_PATH = os.path.dirname(os.path.abspath(__file__))\n# The Draco build directories.\nDRACO_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_shared')\nDRACO_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_static')\n# The Draco install roots.\nDRACO_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "DRACO_SOURCES_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "DRACO_SOURCES_PATH = os.path.abspath(os.path.join('..', '..', '..', '..'))\n# Path to this script and the rest of the test project files.\nTEST_SOURCES_PATH = os.path.dirname(os.path.abspath(__file__))\n# The Draco build directories.\nDRACO_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_shared')\nDRACO_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_static')\n# The Draco install roots.\nDRACO_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_shared')\nDRACO_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "TEST_SOURCES_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "TEST_SOURCES_PATH = os.path.dirname(os.path.abspath(__file__))\n# The Draco build directories.\nDRACO_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_shared')\nDRACO_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_static')\n# The Draco install roots.\nDRACO_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_shared')\nDRACO_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_static')\nDRACO_SHARED_INSTALL_BIN_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'bin')",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "DRACO_SHARED_BUILD_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "DRACO_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_shared')\nDRACO_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_static')\n# The Draco install roots.\nDRACO_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_shared')\nDRACO_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_static')\nDRACO_SHARED_INSTALL_BIN_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'bin')\nDRACO_SHARED_INSTALL_LIB_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'lib')\n# Argument for -j when using make, or -m when using Visual Studio. Number of",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "DRACO_STATIC_BUILD_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "DRACO_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_draco_build_static')\n# The Draco install roots.\nDRACO_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_shared')\nDRACO_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_static')\nDRACO_SHARED_INSTALL_BIN_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'bin')\nDRACO_SHARED_INSTALL_LIB_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'lib')\n# Argument for -j when using make, or -m when using Visual Studio. Number of\n# build jobs.",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "DRACO_SHARED_INSTALL_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "DRACO_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_shared')\nDRACO_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_static')\nDRACO_SHARED_INSTALL_BIN_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'bin')\nDRACO_SHARED_INSTALL_LIB_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'lib')\n# Argument for -j when using make, or -m when using Visual Studio. Number of\n# build jobs.\nNUM_PROCESSES = multiprocessing.cpu_count() - 1\n# The test project build directories.",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "DRACO_STATIC_INSTALL_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "DRACO_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                         '_draco_install_static')\nDRACO_SHARED_INSTALL_BIN_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'bin')\nDRACO_SHARED_INSTALL_LIB_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'lib')\n# Argument for -j when using make, or -m when using Visual Studio. Number of\n# build jobs.\nNUM_PROCESSES = multiprocessing.cpu_count() - 1\n# The test project build directories.\nTEST_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_shared')\nTEST_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_static')",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "DRACO_SHARED_INSTALL_BIN_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "DRACO_SHARED_INSTALL_BIN_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'bin')\nDRACO_SHARED_INSTALL_LIB_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'lib')\n# Argument for -j when using make, or -m when using Visual Studio. Number of\n# build jobs.\nNUM_PROCESSES = multiprocessing.cpu_count() - 1\n# The test project build directories.\nTEST_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_shared')\nTEST_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_static')\n# The test project install directories.\nTEST_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "DRACO_SHARED_INSTALL_LIB_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "DRACO_SHARED_INSTALL_LIB_PATH = os.path.join(DRACO_SHARED_INSTALL_PATH, 'lib')\n# Argument for -j when using make, or -m when using Visual Studio. Number of\n# build jobs.\nNUM_PROCESSES = multiprocessing.cpu_count() - 1\n# The test project build directories.\nTEST_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_shared')\nTEST_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_static')\n# The test project install directories.\nTEST_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_shared')",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "NUM_PROCESSES",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "NUM_PROCESSES = multiprocessing.cpu_count() - 1\n# The test project build directories.\nTEST_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_shared')\nTEST_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_static')\n# The test project install directories.\nTEST_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_shared')\nTEST_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_static')\n# Show configuration and build output.",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "TEST_SHARED_BUILD_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "TEST_SHARED_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_shared')\nTEST_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_static')\n# The test project install directories.\nTEST_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_shared')\nTEST_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_static')\n# Show configuration and build output.\nVERBOSE = False\ndef cmake_get_available_generators():",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "TEST_STATIC_BUILD_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "TEST_STATIC_BUILD_PATH = os.path.join(TEST_SOURCES_PATH, '_test_build_static')\n# The test project install directories.\nTEST_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_shared')\nTEST_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_static')\n# Show configuration and build output.\nVERBOSE = False\ndef cmake_get_available_generators():\n  \"\"\"Returns list of generators available in current CMake executable.\"\"\"",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "TEST_SHARED_INSTALL_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "TEST_SHARED_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_shared')\nTEST_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_static')\n# Show configuration and build output.\nVERBOSE = False\ndef cmake_get_available_generators():\n  \"\"\"Returns list of generators available in current CMake executable.\"\"\"\n  result = run_process_and_capture_output(f'{CMAKE} --help')\n  if result[0] != 0:",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "TEST_STATIC_INSTALL_PATH",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "TEST_STATIC_INSTALL_PATH = os.path.join(TEST_SOURCES_PATH,\n                                        '_test_install_static')\n# Show configuration and build output.\nVERBOSE = False\ndef cmake_get_available_generators():\n  \"\"\"Returns list of generators available in current CMake executable.\"\"\"\n  result = run_process_and_capture_output(f'{CMAKE} --help')\n  if result[0] != 0:\n    raise Exception(f'cmake --help failed, exit code: {result[0]}\\n{result[1]}')\n  help_text = result[1].splitlines()",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "VERBOSE",
        "kind": 5,
        "importPath": "third-party.draco.src.draco.tools.install_test.test",
        "description": "third-party.draco.src.draco.tools.install_test.test",
        "peekOfCode": "VERBOSE = False\ndef cmake_get_available_generators():\n  \"\"\"Returns list of generators available in current CMake executable.\"\"\"\n  result = run_process_and_capture_output(f'{CMAKE} --help')\n  if result[0] != 0:\n    raise Exception(f'cmake --help failed, exit code: {result[0]}\\n{result[1]}')\n  help_text = result[1].splitlines()\n  generators_start_index = help_text.index('Generators') + 3\n  generators_text = help_text[generators_start_index::]\n  generators = []",
        "detail": "third-party.draco.src.draco.tools.install_test.test",
        "documentation": {}
    },
    {
        "label": "Pip",
        "kind": 6,
        "importPath": "third-party.fmt.doc.build",
        "description": "third-party.fmt.doc.build",
        "peekOfCode": "class Pip:\n  def __init__(self, venv_dir):\n    self.path = os.path.join(venv_dir, 'bin', 'pip')\n  def install(self, package, commit=None):\n    \"Install package using pip.\"\n    if commit:\n      package = 'git+https://github.com/{0}.git@{1}'.format(package, commit)\n    print('Installing {0}'.format(package))\n    check_call([self.path, 'install', package])\ndef create_build_env(venv_dir='virtualenv'):",
        "detail": "third-party.fmt.doc.build",
        "documentation": {}
    },
    {
        "label": "create_build_env",
        "kind": 2,
        "importPath": "third-party.fmt.doc.build",
        "description": "third-party.fmt.doc.build",
        "peekOfCode": "def create_build_env(venv_dir='virtualenv'):\n  # Create virtualenv.\n  if not os.path.exists(venv_dir):\n    check_call(['python3', '-m', 'venv', venv_dir])\n  # Install Sphinx and Breathe. Require the exact version of Sphinx which is\n  # compatible with Breathe.\n  pip = Pip(venv_dir)\n  pip.install('wheel')\n  pip.install('six')\n  # See: https://github.com/sphinx-doc/sphinx/issues/9777",
        "detail": "third-party.fmt.doc.build",
        "documentation": {}
    },
    {
        "label": "build_docs",
        "kind": 2,
        "importPath": "third-party.fmt.doc.build",
        "description": "third-party.fmt.doc.build",
        "peekOfCode": "def build_docs(version='dev', **kwargs):\n  doc_dir = kwargs.get('doc_dir', os.path.dirname(os.path.realpath(__file__)))\n  work_dir = kwargs.get('work_dir', '.')\n  include_dir = kwargs.get(\n      'include_dir', os.path.join(os.path.dirname(doc_dir), 'include', 'fmt'))\n  # Build docs.\n  cmd = ['doxygen', '-']\n  p = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=STDOUT)\n  doxyxml_dir = os.path.join(work_dir, 'doxyxml')\n  out, _ = p.communicate(input=r'''",
        "detail": "third-party.fmt.doc.build",
        "documentation": {}
    },
    {
        "label": "versions",
        "kind": 5,
        "importPath": "third-party.fmt.doc.build",
        "description": "third-party.fmt.doc.build",
        "peekOfCode": "versions = [\n  '1.0.0', '1.1.0', '2.0.0', '3.0.2', '4.0.0', '4.1.0', '5.0.0', '5.1.0',\n  '5.2.0', '5.2.1', '5.3.0', '6.0.0', '6.1.0', '6.1.1', '6.1.2', '6.2.0',\n  '6.2.1', '7.0.0', '7.0.1', '7.0.2', '7.0.3', '7.1.0', '7.1.1', '7.1.2',\n  '7.1.3', '8.0.0', '8.0.1', '8.1.0', '8.1.1', '9.0.0', '9.1.0']\nversions += ['10.0.0', '10.1.0', '10.1.1', '10.1.1', '10.2.0', '10.2.1']\nclass Pip:\n  def __init__(self, venv_dir):\n    self.path = os.path.join(venv_dir, 'bin', 'pip')\n  def install(self, package, commit=None):",
        "detail": "third-party.fmt.doc.build",
        "documentation": {}
    },
    {
        "label": "needs_sphinx",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "needs_sphinx = '1.2'\nif os.environ.get('READTHEDOCS', None) == 'True':\n  subprocess.call('doxygen')\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.ifconfig', 'breathe']\nbreathe_default_project = \"format\"\nbreathe_domain_by_extension = {\"h\" : \"cpp\"}\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "extensions = ['sphinx.ext.ifconfig', 'breathe']\nbreathe_default_project = \"format\"\nbreathe_domain_by_extension = {\"h\" : \"cpp\"}\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix of source filenames.\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "breathe_default_project",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "breathe_default_project = \"format\"\nbreathe_domain_by_extension = {\"h\" : \"cpp\"}\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix of source filenames.\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\n#master_doc = 'contents'",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "breathe_domain_by_extension",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "breathe_domain_by_extension = {\"h\" : \"cpp\"}\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix of source filenames.\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\n#master_doc = 'contents'\n# General information about the project.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "templates_path = ['_templates']\n# The suffix of source filenames.\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\n#master_doc = 'contents'\n# General information about the project.\nproject = u'fmt'\ncopyright = u'2012-present, Victor Zverovich'",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "source_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\n#master_doc = 'contents'\n# General information about the project.\nproject = u'fmt'\ncopyright = u'2012-present, Victor Zverovich'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#source_encoding",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#source_encoding = 'utf-8-sig'\n# The master toctree document.\n#master_doc = 'contents'\n# General information about the project.\nproject = u'fmt'\ncopyright = u'2012-present, Victor Zverovich'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#master_doc",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#master_doc = 'contents'\n# General information about the project.\nproject = u'fmt'\ncopyright = u'2012-present, Victor Zverovich'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\n# Version and release are passed from CMake.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "project = u'fmt'\ncopyright = u'2012-present, Victor Zverovich'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\n# Version and release are passed from CMake.\n#version = None\n# The full version, including alpha/beta/rc tags.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "copyright = u'2012-present, Victor Zverovich'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\n# Version and release are passed from CMake.\n#version = None\n# The full version, including alpha/beta/rc tags.\n#release = version",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#version",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#version = None\n# The full version, including alpha/beta/rc tags.\n#release = version\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#release",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#release = version\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#language",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['virtualenv']\n# The reST default role (used for this markup: `text`) to use for all documents.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#today",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['virtualenv']\n# The reST default role (used for this markup: `text`) to use for all documents.\ndefault_role = 'cpp:any'\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#today_fmt",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#today_fmt = '%B %d, %Y'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['virtualenv']\n# The reST default role (used for this markup: `text`) to use for all documents.\ndefault_role = 'cpp:any'\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "exclude_patterns = ['virtualenv']\n# The reST default role (used for this markup: `text`) to use for all documents.\ndefault_role = 'cpp:any'\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "default_role",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "default_role = 'cpp:any'\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#add_function_parentheses",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\nhighlight_language = 'c++'",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#add_module_names",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\nhighlight_language = 'c++'\nprimary_domain = 'cpp'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#show_authors",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#show_authors = False\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\nhighlight_language = 'c++'\nprimary_domain = 'cpp'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "pygments_style = 'sphinx'\nhighlight_language = 'c++'\nprimary_domain = 'cpp'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'basic-bootstrap'\n# Theme options are theme-specific and customize the look and feel of a theme",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "highlight_language",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "highlight_language = 'c++'\nprimary_domain = 'cpp'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'basic-bootstrap'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "primary_domain",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "primary_domain = 'cpp'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'basic-bootstrap'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#modindex_common_prefix",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'basic-bootstrap'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "html_theme = 'basic-bootstrap'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\nhtml_theme_path = ['.']\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme_options",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\nhtml_theme_path = ['.']\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "html_theme_path",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "html_theme_path = ['.']\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_title",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_short_title",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_logo",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_favicon",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "html_static_path = ['_static']\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n  '**': ['localtoc.html', 'relations.html', 'sourcelink.html', 'searchbox.html']",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_last_updated_fmt",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n  '**': ['localtoc.html', 'relations.html', 'sourcelink.html', 'searchbox.html']\n}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_smartypants",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n  '**': ['localtoc.html', 'relations.html', 'sourcelink.html', 'searchbox.html']\n}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "html_sidebars",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "html_sidebars = {\n  '**': ['localtoc.html', 'relations.html', 'sourcelink.html', 'searchbox.html']\n}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_additional_pages",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_domain_indices",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_index",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_split_index",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_sourcelink",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_sphinx",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Output file base name for HTML help builder.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_copyright",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'formatdoc'\n# -- Options for LaTeX output --------------------------------------------------",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_opensearch",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'formatdoc'\n# -- Options for LaTeX output --------------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#html_file_suffix",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#html_file_suffix = None\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'formatdoc'\n# -- Options for LaTeX output --------------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "htmlhelp_basename = 'formatdoc'\n# -- Options for LaTeX output --------------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "latex_elements",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "latex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "latex_documents = [\n  ('index', 'format.tex', u'fmt documentation',\n   u'Victor Zverovich', 'manual'),\n]\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#latex_logo",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#latex_logo = None\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#latex_use_parts",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#latex_use_parts = False\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#latex_show_pagerefs",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#latex_show_urls",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'fmt', u'fmt documentation', [u'Victor Zverovich'], 1)",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#latex_appendices",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'fmt', u'fmt documentation', [u'Victor Zverovich'], 1)\n]\n# If true, show URL addresses after external links.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#latex_domain_indices",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'fmt', u'fmt documentation', [u'Victor Zverovich'], 1)\n]\n# If true, show URL addresses after external links.\n#man_show_urls = False\n# -- Options for Texinfo output ------------------------------------------------",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "man_pages = [\n    ('index', 'fmt', u'fmt documentation', [u'Victor Zverovich'], 1)\n]\n# If true, show URL addresses after external links.\n#man_show_urls = False\n# -- Options for Texinfo output ------------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#man_show_urls",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#man_show_urls = False\n# -- Options for Texinfo output ------------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('index', 'fmt', u'fmt documentation',\n   u'Victor Zverovich', 'fmt', 'One line description of project.',\n   'Miscellaneous'),\n]",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "texinfo_documents",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "texinfo_documents = [\n  ('index', 'fmt', u'fmt documentation',\n   u'Victor Zverovich', 'fmt', 'One line description of project.',\n   'Miscellaneous'),\n]\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_appendices",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#texinfo_appendices = []\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_domain_indices",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_show_urls",
        "kind": 5,
        "importPath": "third-party.fmt.doc.conf",
        "description": "third-party.fmt.doc.conf",
        "peekOfCode": "#texinfo_show_urls = 'footnote'",
        "detail": "third-party.fmt.doc.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "third-party.fmt.support.rtd.conf",
        "description": "third-party.fmt.support.rtd.conf",
        "peekOfCode": "master_doc = 'index'\nhtml_theme = 'theme'\nhtml_theme_path = [\".\"]",
        "detail": "third-party.fmt.support.rtd.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "third-party.fmt.support.rtd.conf",
        "description": "third-party.fmt.support.rtd.conf",
        "peekOfCode": "html_theme = 'theme'\nhtml_theme_path = [\".\"]",
        "detail": "third-party.fmt.support.rtd.conf",
        "documentation": {}
    },
    {
        "label": "html_theme_path",
        "kind": 5,
        "importPath": "third-party.fmt.support.rtd.conf",
        "description": "third-party.fmt.support.rtd.conf",
        "peekOfCode": "html_theme_path = [\".\"]",
        "detail": "third-party.fmt.support.rtd.conf",
        "documentation": {}
    },
    {
        "label": "rmtree_if_exists",
        "kind": 2,
        "importPath": "third-party.fmt.support.build-docs",
        "description": "third-party.fmt.support.build-docs",
        "peekOfCode": "def rmtree_if_exists(dir):\n    try:\n        shutil.rmtree(dir)\n    except OSError as e:\n        if e.errno == errno.ENOENT:\n            pass\n# Build the docs.\nfmt_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\nsys.path.insert(0, os.path.join(fmt_dir, 'doc'))\nimport build",
        "detail": "third-party.fmt.support.build-docs",
        "documentation": {}
    },
    {
        "label": "fmt_dir",
        "kind": 5,
        "importPath": "third-party.fmt.support.build-docs",
        "description": "third-party.fmt.support.build-docs",
        "peekOfCode": "fmt_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\nsys.path.insert(0, os.path.join(fmt_dir, 'doc'))\nimport build\nbuild.create_build_env()\nhtml_dir = build.build_docs()\nrepo = 'fmtlib.github.io'\nbranch = os.environ['GITHUB_REF']\nis_ci = 'CI' in os.environ\nif is_ci and branch != 'refs/heads/master':\n    print('Branch: ' + branch)",
        "detail": "third-party.fmt.support.build-docs",
        "documentation": {}
    },
    {
        "label": "html_dir",
        "kind": 5,
        "importPath": "third-party.fmt.support.build-docs",
        "description": "third-party.fmt.support.build-docs",
        "peekOfCode": "html_dir = build.build_docs()\nrepo = 'fmtlib.github.io'\nbranch = os.environ['GITHUB_REF']\nis_ci = 'CI' in os.environ\nif is_ci and branch != 'refs/heads/master':\n    print('Branch: ' + branch)\n    exit(0) # Ignore non-master branches\nif is_ci and 'KEY' not in os.environ:\n    # Don't update the repo if building in CI from an account that doesn't have\n    # push access.",
        "detail": "third-party.fmt.support.build-docs",
        "documentation": {}
    },
    {
        "label": "repo",
        "kind": 5,
        "importPath": "third-party.fmt.support.build-docs",
        "description": "third-party.fmt.support.build-docs",
        "peekOfCode": "repo = 'fmtlib.github.io'\nbranch = os.environ['GITHUB_REF']\nis_ci = 'CI' in os.environ\nif is_ci and branch != 'refs/heads/master':\n    print('Branch: ' + branch)\n    exit(0) # Ignore non-master branches\nif is_ci and 'KEY' not in os.environ:\n    # Don't update the repo if building in CI from an account that doesn't have\n    # push access.\n    print('Skipping update of ' + repo)",
        "detail": "third-party.fmt.support.build-docs",
        "documentation": {}
    },
    {
        "label": "branch",
        "kind": 5,
        "importPath": "third-party.fmt.support.build-docs",
        "description": "third-party.fmt.support.build-docs",
        "peekOfCode": "branch = os.environ['GITHUB_REF']\nis_ci = 'CI' in os.environ\nif is_ci and branch != 'refs/heads/master':\n    print('Branch: ' + branch)\n    exit(0) # Ignore non-master branches\nif is_ci and 'KEY' not in os.environ:\n    # Don't update the repo if building in CI from an account that doesn't have\n    # push access.\n    print('Skipping update of ' + repo)\n    exit(0)",
        "detail": "third-party.fmt.support.build-docs",
        "documentation": {}
    },
    {
        "label": "is_ci",
        "kind": 5,
        "importPath": "third-party.fmt.support.build-docs",
        "description": "third-party.fmt.support.build-docs",
        "peekOfCode": "is_ci = 'CI' in os.environ\nif is_ci and branch != 'refs/heads/master':\n    print('Branch: ' + branch)\n    exit(0) # Ignore non-master branches\nif is_ci and 'KEY' not in os.environ:\n    # Don't update the repo if building in CI from an account that doesn't have\n    # push access.\n    print('Skipping update of ' + repo)\n    exit(0)\n# Clone the fmtlib.github.io repo.",
        "detail": "third-party.fmt.support.build-docs",
        "documentation": {}
    },
    {
        "label": "git_url",
        "kind": 5,
        "importPath": "third-party.fmt.support.build-docs",
        "description": "third-party.fmt.support.build-docs",
        "peekOfCode": "git_url = 'https://github.com/' if is_ci else 'git@github.com:'\ncheck_call(['git', 'clone', git_url + 'fmtlib/{}.git'.format(repo)])\n# Copy docs to the repo.\ntarget_dir = os.path.join(repo, 'dev')\nrmtree_if_exists(target_dir)\nshutil.copytree(html_dir, target_dir, ignore=shutil.ignore_patterns('.*'))\nif is_ci:\n    check_call(['git', 'config', '--global', 'user.name', 'fmtbot'])\n    check_call(['git', 'config', '--global', 'user.email', 'viz@fmt.dev'])\n# Push docs to GitHub pages.",
        "detail": "third-party.fmt.support.build-docs",
        "documentation": {}
    },
    {
        "label": "target_dir",
        "kind": 5,
        "importPath": "third-party.fmt.support.build-docs",
        "description": "third-party.fmt.support.build-docs",
        "peekOfCode": "target_dir = os.path.join(repo, 'dev')\nrmtree_if_exists(target_dir)\nshutil.copytree(html_dir, target_dir, ignore=shutil.ignore_patterns('.*'))\nif is_ci:\n    check_call(['git', 'config', '--global', 'user.name', 'fmtbot'])\n    check_call(['git', 'config', '--global', 'user.email', 'viz@fmt.dev'])\n# Push docs to GitHub pages.\ncheck_call(['git', 'add', '--all'], cwd=repo)\nif call(['git', 'diff-index', '--quiet', 'HEAD'], cwd=repo):\n    check_call(['git', 'commit', '-m', 'Update documentation'], cwd=repo)",
        "detail": "third-party.fmt.support.build-docs",
        "documentation": {}
    },
    {
        "label": "fp",
        "kind": 6,
        "importPath": "third-party.fmt.support.compute-powers",
        "description": "third-party.fmt.support.compute-powers",
        "peekOfCode": "class fp:\n    pass\npowers = []\nfor i, exp in enumerate(range(min_exponent, max_exponent + 1, step)):\n    result = fp()\n    n = 10 ** exp if exp >= 0 else 2 ** exp_offset / 10 ** -exp\n    k = significand_size + 1\n    # Convert to binary and round.\n    binary = '{:b}'.format(n)\n    result.f = (int('{:0<{}}'.format(binary[:k], k), 2) + 1) / 2",
        "detail": "third-party.fmt.support.compute-powers",
        "documentation": {}
    },
    {
        "label": "min_exponent",
        "kind": 5,
        "importPath": "third-party.fmt.support.compute-powers",
        "description": "third-party.fmt.support.compute-powers",
        "peekOfCode": "min_exponent = -348\nmax_exponent = 340\nstep = 8\nsignificand_size = 64\nexp_offset = 2000\nclass fp:\n    pass\npowers = []\nfor i, exp in enumerate(range(min_exponent, max_exponent + 1, step)):\n    result = fp()",
        "detail": "third-party.fmt.support.compute-powers",
        "documentation": {}
    },
    {
        "label": "max_exponent",
        "kind": 5,
        "importPath": "third-party.fmt.support.compute-powers",
        "description": "third-party.fmt.support.compute-powers",
        "peekOfCode": "max_exponent = 340\nstep = 8\nsignificand_size = 64\nexp_offset = 2000\nclass fp:\n    pass\npowers = []\nfor i, exp in enumerate(range(min_exponent, max_exponent + 1, step)):\n    result = fp()\n    n = 10 ** exp if exp >= 0 else 2 ** exp_offset / 10 ** -exp",
        "detail": "third-party.fmt.support.compute-powers",
        "documentation": {}
    },
    {
        "label": "step",
        "kind": 5,
        "importPath": "third-party.fmt.support.compute-powers",
        "description": "third-party.fmt.support.compute-powers",
        "peekOfCode": "step = 8\nsignificand_size = 64\nexp_offset = 2000\nclass fp:\n    pass\npowers = []\nfor i, exp in enumerate(range(min_exponent, max_exponent + 1, step)):\n    result = fp()\n    n = 10 ** exp if exp >= 0 else 2 ** exp_offset / 10 ** -exp\n    k = significand_size + 1",
        "detail": "third-party.fmt.support.compute-powers",
        "documentation": {}
    },
    {
        "label": "significand_size",
        "kind": 5,
        "importPath": "third-party.fmt.support.compute-powers",
        "description": "third-party.fmt.support.compute-powers",
        "peekOfCode": "significand_size = 64\nexp_offset = 2000\nclass fp:\n    pass\npowers = []\nfor i, exp in enumerate(range(min_exponent, max_exponent + 1, step)):\n    result = fp()\n    n = 10 ** exp if exp >= 0 else 2 ** exp_offset / 10 ** -exp\n    k = significand_size + 1\n    # Convert to binary and round.",
        "detail": "third-party.fmt.support.compute-powers",
        "documentation": {}
    },
    {
        "label": "exp_offset",
        "kind": 5,
        "importPath": "third-party.fmt.support.compute-powers",
        "description": "third-party.fmt.support.compute-powers",
        "peekOfCode": "exp_offset = 2000\nclass fp:\n    pass\npowers = []\nfor i, exp in enumerate(range(min_exponent, max_exponent + 1, step)):\n    result = fp()\n    n = 10 ** exp if exp >= 0 else 2 ** exp_offset / 10 ** -exp\n    k = significand_size + 1\n    # Convert to binary and round.\n    binary = '{:b}'.format(n)",
        "detail": "third-party.fmt.support.compute-powers",
        "documentation": {}
    },
    {
        "label": "powers",
        "kind": 5,
        "importPath": "third-party.fmt.support.compute-powers",
        "description": "third-party.fmt.support.compute-powers",
        "peekOfCode": "powers = []\nfor i, exp in enumerate(range(min_exponent, max_exponent + 1, step)):\n    result = fp()\n    n = 10 ** exp if exp >= 0 else 2 ** exp_offset / 10 ** -exp\n    k = significand_size + 1\n    # Convert to binary and round.\n    binary = '{:b}'.format(n)\n    result.f = (int('{:0<{}}'.format(binary[:k], k), 2) + 1) / 2\n    result.e = len(binary) - (exp_offset if exp < 0 else 0) - significand_size\n    powers.append(result)",
        "detail": "third-party.fmt.support.compute-powers",
        "documentation": {}
    },
    {
        "label": "DocoptLanguageError",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class DocoptLanguageError(Exception):\n    \"\"\"Error in construction of usage-message by developer.\"\"\"\nclass DocoptExit(SystemExit):\n    \"\"\"Exit in case user invoked program with incorrect arguments.\"\"\"\n    usage = ''\n    def __init__(self, message=''):\n        SystemExit.__init__(self, (message + '\\n' + self.usage).strip())\nclass Pattern(object):\n    def __eq__(self, other):\n        return repr(self) == repr(other)",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "DocoptExit",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class DocoptExit(SystemExit):\n    \"\"\"Exit in case user invoked program with incorrect arguments.\"\"\"\n    usage = ''\n    def __init__(self, message=''):\n        SystemExit.__init__(self, (message + '\\n' + self.usage).strip())\nclass Pattern(object):\n    def __eq__(self, other):\n        return repr(self) == repr(other)\n    def __hash__(self):\n        return hash(repr(self))",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class Pattern(object):\n    def __eq__(self, other):\n        return repr(self) == repr(other)\n    def __hash__(self):\n        return hash(repr(self))\n    def fix(self):\n        self.fix_identities()\n        self.fix_repeating_arguments()\n        return self\n    def fix_identities(self, uniq=None):",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "LeafPattern",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class LeafPattern(Pattern):\n    \"\"\"Leaf/terminal node of a pattern tree.\"\"\"\n    def __init__(self, name, value=None):\n        self.name, self.value = name, value\n    def __repr__(self):\n        return '%s(%r, %r)' % (self.__class__.__name__, self.name, self.value)\n    def flat(self, *types):\n        return [self] if not types or type(self) in types else []\n    def match(self, left, collected=None):\n        collected = [] if collected is None else collected",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "BranchPattern",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class BranchPattern(Pattern):\n    \"\"\"Branch/inner node of a pattern tree.\"\"\"\n    def __init__(self, *children):\n        self.children = list(children)\n    def __repr__(self):\n        return '%s(%s)' % (self.__class__.__name__,\n                           ', '.join(repr(a) for a in self.children))\n    def flat(self, *types):\n        if type(self) in types:\n            return [self]",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Argument",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class Argument(LeafPattern):\n    def single_match(self, left):\n        for n, pattern in enumerate(left):\n            if type(pattern) is Argument:\n                return n, Argument(self.name, pattern.value)\n        return None, None\n    @classmethod\n    def parse(class_, source):\n        name = re.findall('(<\\S*?>)', source)[0]\n        value = re.findall('\\[default: (.*)\\]', source, flags=re.I)",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Command",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class Command(Argument):\n    def __init__(self, name, value=False):\n        self.name, self.value = name, value\n    def single_match(self, left):\n        for n, pattern in enumerate(left):\n            if type(pattern) is Argument:\n                if pattern.value == self.name:\n                    return n, Command(self.name, True)\n                else:\n                    break",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Option",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class Option(LeafPattern):\n    def __init__(self, short=None, long=None, argcount=0, value=False):\n        assert argcount in (0, 1)\n        self.short, self.long, self.argcount = short, long, argcount\n        self.value = None if value is False and argcount else value\n    @classmethod\n    def parse(class_, option_description):\n        short, long, argcount, value = None, None, 0, False\n        options, _, description = option_description.strip().partition('  ')\n        options = options.replace(',', ' ').replace('=', ' ')",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Required",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class Required(BranchPattern):\n    def match(self, left, collected=None):\n        collected = [] if collected is None else collected\n        l = left\n        c = collected\n        for pattern in self.children:\n            matched, l, c = pattern.match(l, c)\n            if not matched:\n                return False, left, collected\n        return True, l, c",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Optional",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class Optional(BranchPattern):\n    def match(self, left, collected=None):\n        collected = [] if collected is None else collected\n        for pattern in self.children:\n            m, left, collected = pattern.match(left, collected)\n        return True, left, collected\nclass OptionsShortcut(Optional):\n    \"\"\"Marker/placeholder for [options] shortcut.\"\"\"\nclass OneOrMore(BranchPattern):\n    def match(self, left, collected=None):",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "OptionsShortcut",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class OptionsShortcut(Optional):\n    \"\"\"Marker/placeholder for [options] shortcut.\"\"\"\nclass OneOrMore(BranchPattern):\n    def match(self, left, collected=None):\n        assert len(self.children) == 1\n        collected = [] if collected is None else collected\n        l = left\n        c = collected\n        l_ = None\n        matched = True",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "OneOrMore",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class OneOrMore(BranchPattern):\n    def match(self, left, collected=None):\n        assert len(self.children) == 1\n        collected = [] if collected is None else collected\n        l = left\n        c = collected\n        l_ = None\n        matched = True\n        times = 0\n        while matched:",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Either",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class Either(BranchPattern):\n    def match(self, left, collected=None):\n        collected = [] if collected is None else collected\n        outcomes = []\n        for pattern in self.children:\n            matched, _, _ = outcome = pattern.match(left, collected)\n            if matched:\n                outcomes.append(outcome)\n        if outcomes:\n            return min(outcomes, key=lambda outcome: len(outcome[1]))",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Tokens",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class Tokens(list):\n    def __init__(self, source, error=DocoptExit):\n        self += source.split() if hasattr(source, 'split') else source\n        self.error = error\n    @staticmethod\n    def from_pattern(source):\n        source = re.sub(r'([\\[\\]\\(\\)\\|]|\\.\\.\\.)', r' \\1 ', source)\n        source = [s for s in re.split('\\s+|(\\S*<.*?>)', source) if s]\n        return Tokens(source, error=DocoptLanguageError)\n    def move(self):",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Dict",
        "kind": 6,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "class Dict(dict):\n    def __repr__(self):\n        return '{%s}' % ',\\n '.join('%r: %r' % i for i in sorted(self.items()))\ndef docopt(doc, argv=None, help=True, version=None, options_first=False):\n    \"\"\"Parse `argv` based on command-line interface described in `doc`.\n    `docopt` creates your command-line interface based on its\n    description that you pass as `doc`. Such description can contain\n    --options, <positional-argument>, commands, which could be\n    [optional], (required), (mutually | exclusive) or repeated...\n    Parameters",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "transform",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def transform(pattern):\n    \"\"\"Expand pattern into an (almost) equivalent one, but with single Either.\n    Example: ((-a | -b) (-c | -d)) => (-a -c | -a -d | -b -c | -b -d)\n    Quirks: [-a] => (-a), (-a...) => (-a -a)\n    \"\"\"\n    result = []\n    groups = [[pattern]]\n    while groups:\n        children = groups.pop(0)\n        parents = [Required, Optional, OptionsShortcut, Either, OneOrMore]",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "parse_long",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def parse_long(tokens, options):\n    \"\"\"long ::= '--' chars [ ( ' ' | '=' ) chars ] ;\"\"\"\n    long, eq, value = tokens.move().partition('=')\n    assert long.startswith('--')\n    value = None if eq == value == '' else value\n    similar = [o for o in options if o.long == long]\n    if tokens.error is DocoptExit and similar == []:  # if no exact match\n        similar = [o for o in options if o.long and o.long.startswith(long)]\n    if len(similar) > 1:  # might be simply specified ambiguously 2+ times?\n        raise tokens.error('%s is not a unique prefix: %s?' %",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "parse_shorts",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def parse_shorts(tokens, options):\n    \"\"\"shorts ::= '-' ( chars )* [ [ ' ' ] chars ] ;\"\"\"\n    token = tokens.move()\n    assert token.startswith('-') and not token.startswith('--')\n    left = token.lstrip('-')\n    parsed = []\n    while left != '':\n        short, left = '-' + left[0], left[1:]\n        similar = [o for o in options if o.short == short]\n        if len(similar) > 1:",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "parse_pattern",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def parse_pattern(source, options):\n    tokens = Tokens.from_pattern(source)\n    result = parse_expr(tokens, options)\n    if tokens.current() is not None:\n        raise tokens.error('unexpected ending: %r' % ' '.join(tokens))\n    return Required(*result)\ndef parse_expr(tokens, options):\n    \"\"\"expr ::= seq ( '|' seq )* ;\"\"\"\n    seq = parse_seq(tokens, options)\n    if tokens.current() != '|':",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "parse_expr",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def parse_expr(tokens, options):\n    \"\"\"expr ::= seq ( '|' seq )* ;\"\"\"\n    seq = parse_seq(tokens, options)\n    if tokens.current() != '|':\n        return seq\n    result = [Required(*seq)] if len(seq) > 1 else seq\n    while tokens.current() == '|':\n        tokens.move()\n        seq = parse_seq(tokens, options)\n        result += [Required(*seq)] if len(seq) > 1 else seq",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "parse_seq",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def parse_seq(tokens, options):\n    \"\"\"seq ::= ( atom [ '...' ] )* ;\"\"\"\n    result = []\n    while tokens.current() not in [None, ']', ')', '|']:\n        atom = parse_atom(tokens, options)\n        if tokens.current() == '...':\n            atom = [OneOrMore(*atom)]\n            tokens.move()\n        result += atom\n    return result",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "parse_atom",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def parse_atom(tokens, options):\n    \"\"\"atom ::= '(' expr ')' | '[' expr ']' | 'options'\n             | long | shorts | argument | command ;\n    \"\"\"\n    token = tokens.current()\n    result = []\n    if token in '([':\n        tokens.move()\n        matching, pattern = {'(': [')', Required], '[': [']', Optional]}[token]\n        result = pattern(*parse_expr(tokens, options))",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "parse_argv",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def parse_argv(tokens, options, options_first=False):\n    \"\"\"Parse command-line argument vector.\n    If options_first:\n        argv ::= [ long | shorts ]* [ argument ]* [ '--' [ argument ]* ] ;\n    else:\n        argv ::= [ long | shorts | argument ]* [ '--' [ argument ]* ] ;\n    \"\"\"\n    parsed = []\n    while tokens.current() is not None:\n        if tokens.current() == '--':",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "parse_defaults",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def parse_defaults(doc):\n    defaults = []\n    for s in parse_section('options:', doc):\n        # FIXME corner case \"bla: options: --foo\"\n        _, _, s = s.partition(':')  # get rid of \"options:\"\n        split = re.split('\\n[ \\t]*(-\\S+?)', '\\n' + s)[1:]\n        split = [s1 + s2 for s1, s2 in zip(split[::2], split[1::2])]\n        options = [Option.parse(s) for s in split if s.startswith('-')]\n        defaults += options\n    return defaults",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "parse_section",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def parse_section(name, source):\n    pattern = re.compile('^([^\\n]*' + name + '[^\\n]*\\n?(?:[ \\t].*?(?:\\n|$))*)',\n                         re.IGNORECASE | re.MULTILINE)\n    return [s.strip() for s in pattern.findall(source)]\ndef formal_usage(section):\n    _, _, section = section.partition(':')  # drop \"usage:\"\n    pu = section.split()\n    return '( ' + ' '.join(') | (' if s == pu[0] else s for s in pu[1:]) + ' )'\ndef extras(help, version, options, doc):\n    if help and any((o.name in ('-h', '--help')) and o.value for o in options):",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "formal_usage",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def formal_usage(section):\n    _, _, section = section.partition(':')  # drop \"usage:\"\n    pu = section.split()\n    return '( ' + ' '.join(') | (' if s == pu[0] else s for s in pu[1:]) + ' )'\ndef extras(help, version, options, doc):\n    if help and any((o.name in ('-h', '--help')) and o.value for o in options):\n        print(doc.strip(\"\\n\"))\n        sys.exit()\n    if version and any(o.name == '--version' and o.value for o in options):\n        print(version)",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "extras",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def extras(help, version, options, doc):\n    if help and any((o.name in ('-h', '--help')) and o.value for o in options):\n        print(doc.strip(\"\\n\"))\n        sys.exit()\n    if version and any(o.name == '--version' and o.value for o in options):\n        print(version)\n        sys.exit()\nclass Dict(dict):\n    def __repr__(self):\n        return '{%s}' % ',\\n '.join('%r: %r' % i for i in sorted(self.items()))",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "docopt",
        "kind": 2,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "def docopt(doc, argv=None, help=True, version=None, options_first=False):\n    \"\"\"Parse `argv` based on command-line interface described in `doc`.\n    `docopt` creates your command-line interface based on its\n    description that you pass as `doc`. Such description can contain\n    --options, <positional-argument>, commands, which could be\n    [optional], (required), (mutually | exclusive) or repeated...\n    Parameters\n    ----------\n    doc : str\n        Description of your command-line interface.",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "__all__ = ['docopt']\n__version__ = '0.6.1'\nclass DocoptLanguageError(Exception):\n    \"\"\"Error in construction of usage-message by developer.\"\"\"\nclass DocoptExit(SystemExit):\n    \"\"\"Exit in case user invoked program with incorrect arguments.\"\"\"\n    usage = ''\n    def __init__(self, message=''):\n        SystemExit.__init__(self, (message + '\\n' + self.usage).strip())\nclass Pattern(object):",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "third-party.fmt.support.docopt",
        "description": "third-party.fmt.support.docopt",
        "peekOfCode": "__version__ = '0.6.1'\nclass DocoptLanguageError(Exception):\n    \"\"\"Error in construction of usage-message by developer.\"\"\"\nclass DocoptExit(SystemExit):\n    \"\"\"Exit in case user invoked program with incorrect arguments.\"\"\"\n    usage = ''\n    def __init__(self, message=''):\n        SystemExit.__init__(self, (message + '\\n' + self.usage).strip())\nclass Pattern(object):",
        "detail": "third-party.fmt.support.docopt",
        "documentation": {}
    },
    {
        "label": "Git",
        "kind": 6,
        "importPath": "third-party.fmt.support.manage",
        "description": "third-party.fmt.support.manage",
        "peekOfCode": "class Git:\n    def __init__(self, dir):\n        self.dir = dir\n    def call(self, method, args, **kwargs):\n        return check_call(['git', method] + list(args), **kwargs)\n    def add(self, *args):\n        return self.call('add', args, cwd=self.dir)\n    def checkout(self, *args):\n        return self.call('checkout', args, cwd=self.dir)\n    def clean(self, *args):",
        "detail": "third-party.fmt.support.manage",
        "documentation": {}
    },
    {
        "label": "Runner",
        "kind": 6,
        "importPath": "third-party.fmt.support.manage",
        "description": "third-party.fmt.support.manage",
        "peekOfCode": "class Runner:\n    def __init__(self, cwd):\n        self.cwd = cwd\n    def __call__(self, *args, **kwargs):\n        kwargs['cwd'] = kwargs.get('cwd', self.cwd)\n        check_call(args, **kwargs)\ndef create_build_env():\n    \"\"\"Create a build environment.\"\"\"\n    class Env:\n        pass",
        "detail": "third-party.fmt.support.manage",
        "documentation": {}
    },
    {
        "label": "clean_checkout",
        "kind": 2,
        "importPath": "third-party.fmt.support.manage",
        "description": "third-party.fmt.support.manage",
        "peekOfCode": "def clean_checkout(repo, branch):\n    repo.clean('-f', '-d')\n    repo.reset('--hard')\n    repo.checkout(branch)\nclass Runner:\n    def __init__(self, cwd):\n        self.cwd = cwd\n    def __call__(self, *args, **kwargs):\n        kwargs['cwd'] = kwargs.get('cwd', self.cwd)\n        check_call(args, **kwargs)",
        "detail": "third-party.fmt.support.manage",
        "documentation": {}
    },
    {
        "label": "create_build_env",
        "kind": 2,
        "importPath": "third-party.fmt.support.manage",
        "description": "third-party.fmt.support.manage",
        "peekOfCode": "def create_build_env():\n    \"\"\"Create a build environment.\"\"\"\n    class Env:\n        pass\n    env = Env()\n    # Import the documentation build module.\n    env.fmt_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    sys.path.insert(0, os.path.join(env.fmt_dir, 'doc'))\n    import build\n    env.build_dir = 'build'",
        "detail": "third-party.fmt.support.manage",
        "documentation": {}
    },
    {
        "label": "rewrite",
        "kind": 2,
        "importPath": "third-party.fmt.support.manage",
        "description": "third-party.fmt.support.manage",
        "peekOfCode": "def rewrite(filename):\n    class Buffer:\n        pass\n    buffer = Buffer()\n    if not os.path.exists(filename):\n        buffer.data = ''\n        yield buffer\n        return\n    with open(filename) as f:\n        buffer.data = f.read()",
        "detail": "third-party.fmt.support.manage",
        "documentation": {}
    },
    {
        "label": "update_site",
        "kind": 2,
        "importPath": "third-party.fmt.support.manage",
        "description": "third-party.fmt.support.manage",
        "peekOfCode": "def update_site(env):\n    env.fmt_repo.update(fmt_repo_url)\n    doc_repo = Git(os.path.join(env.build_dir, 'fmtlib.github.io'))\n    doc_repo.update('git@github.com:fmtlib/fmtlib.github.io')\n    for version in env.versions:\n        clean_checkout(env.fmt_repo, version)\n        target_doc_dir = os.path.join(env.fmt_repo.dir, 'doc')\n        # Remove the old theme.\n        for entry in os.listdir(target_doc_dir):\n            path = os.path.join(target_doc_dir, entry)",
        "detail": "third-party.fmt.support.manage",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 2,
        "importPath": "third-party.fmt.support.manage",
        "description": "third-party.fmt.support.manage",
        "peekOfCode": "def release(args):\n    env = create_build_env()\n    fmt_repo = env.fmt_repo\n    branch = args.get('<branch>')\n    if branch is None:\n        branch = 'master'\n    if not fmt_repo.update('-b', branch, fmt_repo_url):\n        clean_checkout(fmt_repo, branch)\n    # Update the date in the changelog and extract the version and the first\n    # section content.",
        "detail": "third-party.fmt.support.manage",
        "documentation": {}
    },
    {
        "label": "fmt_repo_url",
        "kind": 5,
        "importPath": "third-party.fmt.support.manage",
        "description": "third-party.fmt.support.manage",
        "peekOfCode": "fmt_repo_url = 'git@github.com:fmtlib/fmt'\ndef update_site(env):\n    env.fmt_repo.update(fmt_repo_url)\n    doc_repo = Git(os.path.join(env.build_dir, 'fmtlib.github.io'))\n    doc_repo.update('git@github.com:fmtlib/fmtlib.github.io')\n    for version in env.versions:\n        clean_checkout(env.fmt_repo, version)\n        target_doc_dir = os.path.join(env.fmt_repo.dir, 'doc')\n        # Remove the old theme.\n        for entry in os.listdir(target_doc_dir):",
        "detail": "third-party.fmt.support.manage",
        "documentation": {}
    },
    {
        "label": "to_ranges",
        "kind": 2,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "def to_ranges(iter):\n    current = None\n    for i in iter:\n        if current is None or i != current[1] or i in (0x10000, 0x20000):\n            if current is not None:\n                yield tuple(current)\n            current = [i, i + 1]\n        else:\n            current[1] += 1\n    if current is not None:",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "get_escaped",
        "kind": 2,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "def get_escaped(codepoints):\n    for c in codepoints:\n        if (c.class_ or \"Cn\") in \"Cc Cf Cs Co Cn Zl Zp Zs\".split() and c.value != ord(' '):\n            yield c.value\ndef get_file(f):\n    try:\n        return open(os.path.basename(f))\n    except FileNotFoundError:\n        subprocess.run([\"curl\", \"-O\", f], check=True)\n        return open(os.path.basename(f))",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "get_file",
        "kind": 2,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "def get_file(f):\n    try:\n        return open(os.path.basename(f))\n    except FileNotFoundError:\n        subprocess.run([\"curl\", \"-O\", f], check=True)\n        return open(os.path.basename(f))\nCodepoint = namedtuple('Codepoint', 'value class_')\ndef get_codepoints(f):\n    r = csv.reader(f, delimiter=\";\")\n    prev_codepoint = 0",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "get_codepoints",
        "kind": 2,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "def get_codepoints(f):\n    r = csv.reader(f, delimiter=\";\")\n    prev_codepoint = 0\n    class_first = None\n    for row in r:\n        codepoint = int(row[0], 16)\n        name = row[1]\n        class_ = row[2]\n        if class_first is not None:\n            if not name.endswith(\"Last>\"):",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "compress_singletons",
        "kind": 2,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "def compress_singletons(singletons):\n    uppers = [] # (upper, # items in lowers)\n    lowers = []\n    for i in singletons:\n        upper = i >> 8\n        lower = i & 0xff\n        if len(uppers) == 0 or uppers[-1][0] != upper:\n            uppers.append((upper, 1))\n        else:\n            upper, count = uppers[-1]",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "compress_normal",
        "kind": 2,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "def compress_normal(normal):\n    # lengths 0x00..0x7f are encoded as 00, 01, ..., 7e, 7f\n    # lengths 0x80..0x7fff are encoded as 80 80, 80 81, ..., ff fe, ff ff\n    compressed = [] # [truelen, (truelenaux), falselen, (falselenaux)]\n    prev_start = 0\n    for start, count in normal:\n        truelen = start - prev_start\n        falselen = count\n        prev_start = start + count\n        assert truelen < 0x8000 and falselen < 0x8000",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "print_singletons",
        "kind": 2,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "def print_singletons(uppers, lowers, uppersname, lowersname):\n    print(\"  static constexpr singleton {}[] = {{\".format(uppersname))\n    for u, c in uppers:\n        print(\"    {{{:#04x}, {}}},\".format(u, c))\n    print(\"  };\")\n    print(\"  static constexpr unsigned char {}[] = {{\".format(lowersname))\n    for i in range(0, len(lowers), 8):\n        print(\"    {}\".format(\" \".join(\"{:#04x},\".format(l) for l in lowers[i:i+8])))\n    print(\"  };\")\ndef print_normal(normal, normalname):",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "print_normal",
        "kind": 2,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "def print_normal(normal, normalname):\n    print(\"  static constexpr unsigned char {}[] = {{\".format(normalname))\n    for v in normal:\n        print(\"    {}\".format(\" \".join(\"{:#04x},\".format(i) for i in v)))\n    print(\"  };\")\ndef main():\n    file = get_file(\"https://www.unicode.org/Public/UNIDATA/UnicodeData.txt\")\n    codepoints = get_codepoints(file)\n    CUTOFF=0x10000\n    singletons0 = []",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "def main():\n    file = get_file(\"https://www.unicode.org/Public/UNIDATA/UnicodeData.txt\")\n    codepoints = get_codepoints(file)\n    CUTOFF=0x10000\n    singletons0 = []\n    singletons1 = []\n    normal0 = []\n    normal1 = []\n    extra = []\n    for a, b in to_ranges(get_escaped(codepoints)):",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "Codepoint",
        "kind": 5,
        "importPath": "third-party.fmt.support.printable",
        "description": "third-party.fmt.support.printable",
        "peekOfCode": "Codepoint = namedtuple('Codepoint', 'value class_')\ndef get_codepoints(f):\n    r = csv.reader(f, delimiter=\";\")\n    prev_codepoint = 0\n    class_first = None\n    for row in r:\n        codepoint = int(row[0], 16)\n        name = row[1]\n        class_ = row[2]\n        if class_first is not None:",
        "detail": "third-party.fmt.support.printable",
        "documentation": {}
    },
    {
        "label": "GMockLeakTest",
        "kind": 6,
        "importPath": "third-party.googletest.googlemock.test.gmock_leak_test",
        "description": "third-party.googletest.googlemock.test.gmock_leak_test",
        "peekOfCode": "class GMockLeakTest(gmock_test_utils.TestCase):\n  def testCatchesLeakedMockByDefault(self):\n    self.assertNotEqual(\n        0,\n        gmock_test_utils.Subprocess(TEST_WITH_EXPECT_CALL,\n                                    env=environ).exit_code)\n    self.assertNotEqual(\n        0,\n        gmock_test_utils.Subprocess(TEST_WITH_ON_CALL,\n                                    env=environ).exit_code)",
        "detail": "third-party.googletest.googlemock.test.gmock_leak_test",
        "documentation": {}
    },
    {
        "label": "PROGRAM_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_leak_test",
        "description": "third-party.googletest.googlemock.test.gmock_leak_test",
        "peekOfCode": "PROGRAM_PATH = gmock_test_utils.GetTestExecutablePath('gmock_leak_test_')\nTEST_WITH_EXPECT_CALL = [PROGRAM_PATH, '--gtest_filter=*ExpectCall*']\nTEST_WITH_ON_CALL = [PROGRAM_PATH, '--gtest_filter=*OnCall*']\nTEST_MULTIPLE_LEAKS = [PROGRAM_PATH, '--gtest_filter=*MultipleLeaked*']\nenviron = gmock_test_utils.environ\nSetEnvVar = gmock_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating",
        "detail": "third-party.googletest.googlemock.test.gmock_leak_test",
        "documentation": {}
    },
    {
        "label": "TEST_WITH_EXPECT_CALL",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_leak_test",
        "description": "third-party.googletest.googlemock.test.gmock_leak_test",
        "peekOfCode": "TEST_WITH_EXPECT_CALL = [PROGRAM_PATH, '--gtest_filter=*ExpectCall*']\nTEST_WITH_ON_CALL = [PROGRAM_PATH, '--gtest_filter=*OnCall*']\nTEST_MULTIPLE_LEAKS = [PROGRAM_PATH, '--gtest_filter=*MultipleLeaked*']\nenviron = gmock_test_utils.environ\nSetEnvVar = gmock_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.",
        "detail": "third-party.googletest.googlemock.test.gmock_leak_test",
        "documentation": {}
    },
    {
        "label": "TEST_WITH_ON_CALL",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_leak_test",
        "description": "third-party.googletest.googlemock.test.gmock_leak_test",
        "peekOfCode": "TEST_WITH_ON_CALL = [PROGRAM_PATH, '--gtest_filter=*OnCall*']\nTEST_MULTIPLE_LEAKS = [PROGRAM_PATH, '--gtest_filter=*MultipleLeaked*']\nenviron = gmock_test_utils.environ\nSetEnvVar = gmock_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gmock_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)",
        "detail": "third-party.googletest.googlemock.test.gmock_leak_test",
        "documentation": {}
    },
    {
        "label": "TEST_MULTIPLE_LEAKS",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_leak_test",
        "description": "third-party.googletest.googlemock.test.gmock_leak_test",
        "peekOfCode": "TEST_MULTIPLE_LEAKS = [PROGRAM_PATH, '--gtest_filter=*MultipleLeaked*']\nenviron = gmock_test_utils.environ\nSetEnvVar = gmock_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gmock_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)\nclass GMockLeakTest(gmock_test_utils.TestCase):",
        "detail": "third-party.googletest.googlemock.test.gmock_leak_test",
        "documentation": {}
    },
    {
        "label": "environ",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_leak_test",
        "description": "third-party.googletest.googlemock.test.gmock_leak_test",
        "peekOfCode": "environ = gmock_test_utils.environ\nSetEnvVar = gmock_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gmock_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)\nclass GMockLeakTest(gmock_test_utils.TestCase):\n  def testCatchesLeakedMockByDefault(self):",
        "detail": "third-party.googletest.googlemock.test.gmock_leak_test",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_leak_test",
        "description": "third-party.googletest.googlemock.test.gmock_leak_test",
        "peekOfCode": "SetEnvVar = gmock_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gmock_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)\nclass GMockLeakTest(gmock_test_utils.TestCase):\n  def testCatchesLeakedMockByDefault(self):\n    self.assertNotEqual(",
        "detail": "third-party.googletest.googlemock.test.gmock_leak_test",
        "documentation": {}
    },
    {
        "label": "GMockOutputTest",
        "kind": 6,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "class GMockOutputTest(gmock_test_utils.TestCase):\n  def testOutput(self):\n    (output, leaky_tests) = GetNormalizedCommandOutputAndLeakyTests(COMMAND)\n    golden_file = open(GOLDEN_PATH, 'rb')\n    golden = golden_file.read().decode('utf-8')\n    golden_file.close()\n    # The normalized output should match the golden file.\n    self.assertEquals(golden, output)\n    # The raw output should contain 2 leaked mock object errors for\n    # test GMockOutputTest.CatchesLeakedMocks.",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "ToUnixLineEnding",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def ToUnixLineEnding(s):\n  \"\"\"Changes all Windows/Mac line endings in s to UNIX line endings.\"\"\"\n  return s.replace('\\r\\n', '\\n').replace('\\r', '\\n')\ndef RemoveReportHeaderAndFooter(output):\n  \"\"\"Removes Google Test result report's header and footer from the output.\"\"\"\n  output = re.sub(r'.*gtest_main.*\\n', '', output)\n  output = re.sub(r'\\[.*\\d+ tests.*\\n', '', output)\n  output = re.sub(r'\\[.* test environment .*\\n', '', output)\n  output = re.sub(r'\\[=+\\] \\d+ tests .* ran.*', '', output)\n  output = re.sub(r'.* FAILED TESTS\\n', '', output)",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "RemoveReportHeaderAndFooter",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def RemoveReportHeaderAndFooter(output):\n  \"\"\"Removes Google Test result report's header and footer from the output.\"\"\"\n  output = re.sub(r'.*gtest_main.*\\n', '', output)\n  output = re.sub(r'\\[.*\\d+ tests.*\\n', '', output)\n  output = re.sub(r'\\[.* test environment .*\\n', '', output)\n  output = re.sub(r'\\[=+\\] \\d+ tests .* ran.*', '', output)\n  output = re.sub(r'.* FAILED TESTS\\n', '', output)\n  return output\ndef RemoveLocations(output):\n  \"\"\"Removes all file location info from a Google Test program's output.",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "RemoveLocations",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def RemoveLocations(output):\n  \"\"\"Removes all file location info from a Google Test program's output.\n  Args:\n       output:  the output of a Google Test program.\n  Returns:\n       output with all file location info (in the form of\n       'DIRECTORY/FILE_NAME:LINE_NUMBER: 'or\n       'DIRECTORY\\\\FILE_NAME(LINE_NUMBER): ') replaced by\n       'FILE:#: '.\n  \"\"\"",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "NormalizeErrorMarker",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def NormalizeErrorMarker(output):\n  \"\"\"Normalizes the error marker, which is different on Windows vs on Linux.\"\"\"\n  return re.sub(r' error: ', ' Failure\\n', output)\ndef RemoveMemoryAddresses(output):\n  \"\"\"Removes memory addresses from the test output.\"\"\"\n  return re.sub(r'@\\w+', '@0x#', output)\ndef RemoveTestNamesOfLeakedMocks(output):\n  \"\"\"Removes the test names of leaked mock objects from the test output.\"\"\"\n  return re.sub(r'\\(used in test .+\\) ', '', output)\ndef GetLeakyTests(output):",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "RemoveMemoryAddresses",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def RemoveMemoryAddresses(output):\n  \"\"\"Removes memory addresses from the test output.\"\"\"\n  return re.sub(r'@\\w+', '@0x#', output)\ndef RemoveTestNamesOfLeakedMocks(output):\n  \"\"\"Removes the test names of leaked mock objects from the test output.\"\"\"\n  return re.sub(r'\\(used in test .+\\) ', '', output)\ndef GetLeakyTests(output):\n  \"\"\"Returns a list of test names that leak mock objects.\"\"\"\n  # findall() returns a list of all matches of the regex in output.\n  # For example, if '(used in test FooTest.Bar)' is in output, the",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "RemoveTestNamesOfLeakedMocks",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def RemoveTestNamesOfLeakedMocks(output):\n  \"\"\"Removes the test names of leaked mock objects from the test output.\"\"\"\n  return re.sub(r'\\(used in test .+\\) ', '', output)\ndef GetLeakyTests(output):\n  \"\"\"Returns a list of test names that leak mock objects.\"\"\"\n  # findall() returns a list of all matches of the regex in output.\n  # For example, if '(used in test FooTest.Bar)' is in output, the\n  # list will contain 'FooTest.Bar'.\n  return re.findall(r'\\(used in test (.+)\\)', output)\ndef GetNormalizedOutputAndLeakyTests(output):",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "GetLeakyTests",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def GetLeakyTests(output):\n  \"\"\"Returns a list of test names that leak mock objects.\"\"\"\n  # findall() returns a list of all matches of the regex in output.\n  # For example, if '(used in test FooTest.Bar)' is in output, the\n  # list will contain 'FooTest.Bar'.\n  return re.findall(r'\\(used in test (.+)\\)', output)\ndef GetNormalizedOutputAndLeakyTests(output):\n  \"\"\"Normalizes the output of gmock_output_test_.\n  Args:\n    output: The test output.",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "GetNormalizedOutputAndLeakyTests",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def GetNormalizedOutputAndLeakyTests(output):\n  \"\"\"Normalizes the output of gmock_output_test_.\n  Args:\n    output: The test output.\n  Returns:\n    A tuple (the normalized test output, the list of test names that have\n    leaked mocks).\n  \"\"\"\n  output = ToUnixLineEnding(output)\n  output = RemoveReportHeaderAndFooter(output)",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "GetShellCommandOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def GetShellCommandOutput(cmd):\n  \"\"\"Runs a command in a sub-process, and returns its STDOUT in a string.\"\"\"\n  return gmock_test_utils.Subprocess(cmd, capture_stderr=False).output\ndef GetNormalizedCommandOutputAndLeakyTests(cmd):\n  \"\"\"Runs a command and returns its normalized output and a list of leaky tests.\n  Args:\n    cmd:  the shell command.\n  \"\"\"\n  # Disables exception pop-ups on Windows.\n  os.environ['GTEST_CATCH_EXCEPTIONS'] = '1'",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "GetNormalizedCommandOutputAndLeakyTests",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "def GetNormalizedCommandOutputAndLeakyTests(cmd):\n  \"\"\"Runs a command and returns its normalized output and a list of leaky tests.\n  Args:\n    cmd:  the shell command.\n  \"\"\"\n  # Disables exception pop-ups on Windows.\n  os.environ['GTEST_CATCH_EXCEPTIONS'] = '1'\n  return GetNormalizedOutputAndLeakyTests(GetShellCommandOutput(cmd))\nclass GMockOutputTest(gmock_test_utils.TestCase):\n  def testOutput(self):",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "GENGOLDEN_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "GENGOLDEN_FLAG = '--gengolden'\nPROGRAM_PATH = gmock_test_utils.GetTestExecutablePath('gmock_output_test_')\nCOMMAND = [PROGRAM_PATH, '--gtest_stack_trace_depth=0', '--gtest_print_time=0']\nGOLDEN_NAME = 'gmock_output_test_golden.txt'\nGOLDEN_PATH = os.path.join(gmock_test_utils.GetSourceDir(), GOLDEN_NAME)\ndef ToUnixLineEnding(s):\n  \"\"\"Changes all Windows/Mac line endings in s to UNIX line endings.\"\"\"\n  return s.replace('\\r\\n', '\\n').replace('\\r', '\\n')\ndef RemoveReportHeaderAndFooter(output):\n  \"\"\"Removes Google Test result report's header and footer from the output.\"\"\"",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "PROGRAM_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "PROGRAM_PATH = gmock_test_utils.GetTestExecutablePath('gmock_output_test_')\nCOMMAND = [PROGRAM_PATH, '--gtest_stack_trace_depth=0', '--gtest_print_time=0']\nGOLDEN_NAME = 'gmock_output_test_golden.txt'\nGOLDEN_PATH = os.path.join(gmock_test_utils.GetSourceDir(), GOLDEN_NAME)\ndef ToUnixLineEnding(s):\n  \"\"\"Changes all Windows/Mac line endings in s to UNIX line endings.\"\"\"\n  return s.replace('\\r\\n', '\\n').replace('\\r', '\\n')\ndef RemoveReportHeaderAndFooter(output):\n  \"\"\"Removes Google Test result report's header and footer from the output.\"\"\"\n  output = re.sub(r'.*gtest_main.*\\n', '', output)",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "COMMAND = [PROGRAM_PATH, '--gtest_stack_trace_depth=0', '--gtest_print_time=0']\nGOLDEN_NAME = 'gmock_output_test_golden.txt'\nGOLDEN_PATH = os.path.join(gmock_test_utils.GetSourceDir(), GOLDEN_NAME)\ndef ToUnixLineEnding(s):\n  \"\"\"Changes all Windows/Mac line endings in s to UNIX line endings.\"\"\"\n  return s.replace('\\r\\n', '\\n').replace('\\r', '\\n')\ndef RemoveReportHeaderAndFooter(output):\n  \"\"\"Removes Google Test result report's header and footer from the output.\"\"\"\n  output = re.sub(r'.*gtest_main.*\\n', '', output)\n  output = re.sub(r'\\[.*\\d+ tests.*\\n', '', output)",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "GOLDEN_NAME",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "GOLDEN_NAME = 'gmock_output_test_golden.txt'\nGOLDEN_PATH = os.path.join(gmock_test_utils.GetSourceDir(), GOLDEN_NAME)\ndef ToUnixLineEnding(s):\n  \"\"\"Changes all Windows/Mac line endings in s to UNIX line endings.\"\"\"\n  return s.replace('\\r\\n', '\\n').replace('\\r', '\\n')\ndef RemoveReportHeaderAndFooter(output):\n  \"\"\"Removes Google Test result report's header and footer from the output.\"\"\"\n  output = re.sub(r'.*gtest_main.*\\n', '', output)\n  output = re.sub(r'\\[.*\\d+ tests.*\\n', '', output)\n  output = re.sub(r'\\[.* test environment .*\\n', '', output)",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "GOLDEN_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_output_test",
        "description": "third-party.googletest.googlemock.test.gmock_output_test",
        "peekOfCode": "GOLDEN_PATH = os.path.join(gmock_test_utils.GetSourceDir(), GOLDEN_NAME)\ndef ToUnixLineEnding(s):\n  \"\"\"Changes all Windows/Mac line endings in s to UNIX line endings.\"\"\"\n  return s.replace('\\r\\n', '\\n').replace('\\r', '\\n')\ndef RemoveReportHeaderAndFooter(output):\n  \"\"\"Removes Google Test result report's header and footer from the output.\"\"\"\n  output = re.sub(r'.*gtest_main.*\\n', '', output)\n  output = re.sub(r'\\[.*\\d+ tests.*\\n', '', output)\n  output = re.sub(r'\\[.* test environment .*\\n', '', output)\n  output = re.sub(r'\\[=+\\] \\d+ tests .* ran.*', '', output)",
        "detail": "third-party.googletest.googlemock.test.gmock_output_test",
        "documentation": {}
    },
    {
        "label": "GetSourceDir",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_test_utils",
        "description": "third-party.googletest.googlemock.test.gmock_test_utils",
        "peekOfCode": "def GetSourceDir():\n  \"\"\"Returns the absolute path of the directory where the .py files are.\"\"\"\n  return gtest_test_utils.GetSourceDir()\ndef GetTestExecutablePath(executable_name):\n  \"\"\"Returns the absolute path of the test binary given its name.\n  The function will print a message and abort the program if the resulting file\n  doesn't exist.\n  Args:\n    executable_name: name of the test binary that the test script runs.\n  Returns:",
        "detail": "third-party.googletest.googlemock.test.gmock_test_utils",
        "documentation": {}
    },
    {
        "label": "GetTestExecutablePath",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_test_utils",
        "description": "third-party.googletest.googlemock.test.gmock_test_utils",
        "peekOfCode": "def GetTestExecutablePath(executable_name):\n  \"\"\"Returns the absolute path of the test binary given its name.\n  The function will print a message and abort the program if the resulting file\n  doesn't exist.\n  Args:\n    executable_name: name of the test binary that the test script runs.\n  Returns:\n    The absolute path of the test binary.\n  \"\"\"\n  return gtest_test_utils.GetTestExecutablePath(executable_name)",
        "detail": "third-party.googletest.googlemock.test.gmock_test_utils",
        "documentation": {}
    },
    {
        "label": "GetExitStatus",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_test_utils",
        "description": "third-party.googletest.googlemock.test.gmock_test_utils",
        "peekOfCode": "def GetExitStatus(exit_code):\n  \"\"\"Returns the argument to exit(), or -1 if exit() wasn't called.\n  Args:\n    exit_code: the result value of os.system(command).\n  \"\"\"\n  if os.name == 'nt':\n    # On Windows, os.WEXITSTATUS() doesn't work and os.system() returns\n    # the argument to exit() directly.\n    return exit_code\n  else:",
        "detail": "third-party.googletest.googlemock.test.gmock_test_utils",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": "third-party.googletest.googlemock.test.gmock_test_utils",
        "description": "third-party.googletest.googlemock.test.gmock_test_utils",
        "peekOfCode": "def Main():\n  \"\"\"Runs the unit test.\"\"\"\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googlemock.test.gmock_test_utils",
        "documentation": {}
    },
    {
        "label": "Subprocess",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_test_utils",
        "description": "third-party.googletest.googlemock.test.gmock_test_utils",
        "peekOfCode": "Subprocess = gtest_test_utils.Subprocess\nTestCase = gtest_test_utils.TestCase\nenviron = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\nPREMATURE_EXIT_FILE_ENV_VAR = gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR\n# pylint: enable-msg=C6409\ndef Main():\n  \"\"\"Runs the unit test.\"\"\"\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googlemock.test.gmock_test_utils",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_test_utils",
        "description": "third-party.googletest.googlemock.test.gmock_test_utils",
        "peekOfCode": "TestCase = gtest_test_utils.TestCase\nenviron = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\nPREMATURE_EXIT_FILE_ENV_VAR = gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR\n# pylint: enable-msg=C6409\ndef Main():\n  \"\"\"Runs the unit test.\"\"\"\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googlemock.test.gmock_test_utils",
        "documentation": {}
    },
    {
        "label": "environ",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_test_utils",
        "description": "third-party.googletest.googlemock.test.gmock_test_utils",
        "peekOfCode": "environ = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\nPREMATURE_EXIT_FILE_ENV_VAR = gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR\n# pylint: enable-msg=C6409\ndef Main():\n  \"\"\"Runs the unit test.\"\"\"\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googlemock.test.gmock_test_utils",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_test_utils",
        "description": "third-party.googletest.googlemock.test.gmock_test_utils",
        "peekOfCode": "SetEnvVar = gtest_test_utils.SetEnvVar\nPREMATURE_EXIT_FILE_ENV_VAR = gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR\n# pylint: enable-msg=C6409\ndef Main():\n  \"\"\"Runs the unit test.\"\"\"\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googlemock.test.gmock_test_utils",
        "documentation": {}
    },
    {
        "label": "PREMATURE_EXIT_FILE_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googlemock.test.gmock_test_utils",
        "description": "third-party.googletest.googlemock.test.gmock_test_utils",
        "peekOfCode": "PREMATURE_EXIT_FILE_ENV_VAR = gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR\n# pylint: enable-msg=C6409\ndef Main():\n  \"\"\"Runs the unit test.\"\"\"\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googlemock.test.gmock_test_utils",
        "documentation": {}
    },
    {
        "label": "GTestBreakOnFailureUnitTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "class GTestBreakOnFailureUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests using the GTEST_BREAK_ON_FAILURE environment variable or\n  the --gtest_break_on_failure flag to turn assertion failures into\n  segmentation faults.\n  \"\"\"\n  def RunAndVerify(self, env_var_value, flag_value, expect_seg_fault):\n    \"\"\"Runs googletest-break-on-failure-unittest_ and verifies that it does\n    (or does not) have a seg-fault.\n    Args:\n      env_var_value:    value of the GTEST_BREAK_ON_FAILURE environment",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "Run",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "def Run(command):\n  \"\"\"Runs a command; returns 1 if it was killed by a signal, or 0 otherwise.\"\"\"\n  p = gtest_test_utils.Subprocess(command, env=environ)\n  if p.terminated_by_signal:\n    return 1\n  else:\n    return 0\n# The tests.\nclass GTestBreakOnFailureUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests using the GTEST_BREAK_ON_FAILURE environment variable or",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "IS_WINDOWS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "IS_WINDOWS = os.name == 'nt'\n# The environment variable for enabling/disabling the break-on-failure mode.\nBREAK_ON_FAILURE_ENV_VAR = 'GTEST_BREAK_ON_FAILURE'\n# The command line flag for enabling/disabling the break-on-failure mode.\nBREAK_ON_FAILURE_FLAG = 'gtest_break_on_failure'\n# The environment variable for enabling/disabling the throw-on-failure mode.\nTHROW_ON_FAILURE_ENV_VAR = 'GTEST_THROW_ON_FAILURE'\n# The environment variable for enabling/disabling the catch-exceptions mode.\nCATCH_EXCEPTIONS_ENV_VAR = 'GTEST_CATCH_EXCEPTIONS'\n# Path to the googletest-break-on-failure-unittest_ program.",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "BREAK_ON_FAILURE_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "BREAK_ON_FAILURE_ENV_VAR = 'GTEST_BREAK_ON_FAILURE'\n# The command line flag for enabling/disabling the break-on-failure mode.\nBREAK_ON_FAILURE_FLAG = 'gtest_break_on_failure'\n# The environment variable for enabling/disabling the throw-on-failure mode.\nTHROW_ON_FAILURE_ENV_VAR = 'GTEST_THROW_ON_FAILURE'\n# The environment variable for enabling/disabling the catch-exceptions mode.\nCATCH_EXCEPTIONS_ENV_VAR = 'GTEST_CATCH_EXCEPTIONS'\n# Path to the googletest-break-on-failure-unittest_ program.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-break-on-failure-unittest_')",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "BREAK_ON_FAILURE_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "BREAK_ON_FAILURE_FLAG = 'gtest_break_on_failure'\n# The environment variable for enabling/disabling the throw-on-failure mode.\nTHROW_ON_FAILURE_ENV_VAR = 'GTEST_THROW_ON_FAILURE'\n# The environment variable for enabling/disabling the catch-exceptions mode.\nCATCH_EXCEPTIONS_ENV_VAR = 'GTEST_CATCH_EXCEPTIONS'\n# Path to the googletest-break-on-failure-unittest_ program.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-break-on-failure-unittest_')\nenviron = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "THROW_ON_FAILURE_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "THROW_ON_FAILURE_ENV_VAR = 'GTEST_THROW_ON_FAILURE'\n# The environment variable for enabling/disabling the catch-exceptions mode.\nCATCH_EXCEPTIONS_ENV_VAR = 'GTEST_CATCH_EXCEPTIONS'\n# Path to the googletest-break-on-failure-unittest_ program.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-break-on-failure-unittest_')\nenviron = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "CATCH_EXCEPTIONS_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "CATCH_EXCEPTIONS_ENV_VAR = 'GTEST_CATCH_EXCEPTIONS'\n# Path to the googletest-break-on-failure-unittest_ program.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-break-on-failure-unittest_')\nenviron = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "EXE_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "EXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-break-on-failure-unittest_')\nenviron = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "environ",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "environ = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)\ndef Run(command):\n  \"\"\"Runs a command; returns 1 if it was killed by a signal, or 0 otherwise.\"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "description": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "peekOfCode": "SetEnvVar = gtest_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)\ndef Run(command):\n  \"\"\"Runs a command; returns 1 if it was killed by a signal, or 0 otherwise.\"\"\"\n  p = gtest_test_utils.Subprocess(command, env=environ)",
        "detail": "third-party.googletest.googletest.test.googletest-break-on-failure-unittest",
        "documentation": {}
    },
    {
        "label": "CatchCxxExceptionsTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "class CatchCxxExceptionsTest(gtest_test_utils.TestCase):\n  \"\"\"Tests C++ exception-catching behavior.\n     Tests in this test case verify that:\n     * C++ exceptions are caught and logged as C++ (not SEH) exceptions\n     * Exception thrown affect the remainder of the test work flow in the\n       expected manner.\n  \"\"\"\n  def testCatchesCxxExceptionsInFixtureConstructor(self):\n    self.assertTrue(\n        'C++ exception with description '",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "FLAG_PREFIX",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "FLAG_PREFIX = '--gtest_'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nNO_CATCH_EXCEPTIONS_FLAG = FLAG_PREFIX + 'catch_exceptions=0'\nFILTER_FLAG = FLAG_PREFIX + 'filter'\n# Path to the googletest-catch-exceptions-ex-test_ binary, compiled with\n# exceptions enabled.\nEX_EXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-catch-exceptions-ex-test_')\n# Path to the googletest-catch-exceptions-test_ binary, compiled with\n# exceptions disabled.",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "LIST_TESTS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "LIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nNO_CATCH_EXCEPTIONS_FLAG = FLAG_PREFIX + 'catch_exceptions=0'\nFILTER_FLAG = FLAG_PREFIX + 'filter'\n# Path to the googletest-catch-exceptions-ex-test_ binary, compiled with\n# exceptions enabled.\nEX_EXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-catch-exceptions-ex-test_')\n# Path to the googletest-catch-exceptions-test_ binary, compiled with\n# exceptions disabled.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath(",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "NO_CATCH_EXCEPTIONS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "NO_CATCH_EXCEPTIONS_FLAG = FLAG_PREFIX + 'catch_exceptions=0'\nFILTER_FLAG = FLAG_PREFIX + 'filter'\n# Path to the googletest-catch-exceptions-ex-test_ binary, compiled with\n# exceptions enabled.\nEX_EXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-catch-exceptions-ex-test_')\n# Path to the googletest-catch-exceptions-test_ binary, compiled with\n# exceptions disabled.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-catch-exceptions-no-ex-test_')",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "FILTER_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "FILTER_FLAG = FLAG_PREFIX + 'filter'\n# Path to the googletest-catch-exceptions-ex-test_ binary, compiled with\n# exceptions enabled.\nEX_EXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-catch-exceptions-ex-test_')\n# Path to the googletest-catch-exceptions-test_ binary, compiled with\n# exceptions disabled.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-catch-exceptions-no-ex-test_')\nenviron = gtest_test_utils.environ",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "EX_EXE_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "EX_EXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-catch-exceptions-ex-test_')\n# Path to the googletest-catch-exceptions-test_ binary, compiled with\n# exceptions disabled.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-catch-exceptions-no-ex-test_')\nenviron = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "EXE_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "EXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-catch-exceptions-no-ex-test_')\nenviron = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "environ",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "environ = gtest_test_utils.environ\nSetEnvVar = gtest_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)\nTEST_LIST = gtest_test_utils.Subprocess(\n    [EXE_PATH, LIST_TESTS_FLAG], env=environ).output",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "SetEnvVar = gtest_test_utils.SetEnvVar\n# Tests in this file run a Google-Test-based test program and expect it\n# to terminate prematurely.  Therefore they are incompatible with\n# the premature-exit-file protocol by design.  Unset the\n# premature-exit filepath to prevent Google Test from creating\n# the file.\nSetEnvVar(gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)\nTEST_LIST = gtest_test_utils.Subprocess(\n    [EXE_PATH, LIST_TESTS_FLAG], env=environ).output\nSUPPORTS_SEH_EXCEPTIONS = 'ThrowsSehException' in TEST_LIST",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "TEST_LIST",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "TEST_LIST = gtest_test_utils.Subprocess(\n    [EXE_PATH, LIST_TESTS_FLAG], env=environ).output\nSUPPORTS_SEH_EXCEPTIONS = 'ThrowsSehException' in TEST_LIST\nif SUPPORTS_SEH_EXCEPTIONS:\n  BINARY_OUTPUT = gtest_test_utils.Subprocess([EXE_PATH], env=environ).output\nEX_BINARY_OUTPUT = gtest_test_utils.Subprocess(\n    [EX_EXE_PATH], env=environ).output\n# The tests.\nif SUPPORTS_SEH_EXCEPTIONS:\n  # pylint:disable-msg=C6302",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_SEH_EXCEPTIONS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "SUPPORTS_SEH_EXCEPTIONS = 'ThrowsSehException' in TEST_LIST\nif SUPPORTS_SEH_EXCEPTIONS:\n  BINARY_OUTPUT = gtest_test_utils.Subprocess([EXE_PATH], env=environ).output\nEX_BINARY_OUTPUT = gtest_test_utils.Subprocess(\n    [EX_EXE_PATH], env=environ).output\n# The tests.\nif SUPPORTS_SEH_EXCEPTIONS:\n  # pylint:disable-msg=C6302\n  class CatchSehExceptionsTest(gtest_test_utils.TestCase):\n    \"\"\"Tests exception-catching behavior.\"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "EX_BINARY_OUTPUT",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "description": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "peekOfCode": "EX_BINARY_OUTPUT = gtest_test_utils.Subprocess(\n    [EX_EXE_PATH], env=environ).output\n# The tests.\nif SUPPORTS_SEH_EXCEPTIONS:\n  # pylint:disable-msg=C6302\n  class CatchSehExceptionsTest(gtest_test_utils.TestCase):\n    \"\"\"Tests exception-catching behavior.\"\"\"\n    def TestSehExceptions(self, test_output):\n      self.assert_('SEH exception with code 0x2a thrown '\n                   'in the test fixture\\'s constructor'",
        "detail": "third-party.googletest.googletest.test.googletest-catch-exceptions-test",
        "documentation": {}
    },
    {
        "label": "GTestColorTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-color-test",
        "description": "third-party.googletest.googletest.test.googletest-color-test",
        "peekOfCode": "class GTestColorTest(gtest_test_utils.TestCase):\n  def testNoEnvVarNoFlag(self):\n    \"\"\"Tests the case when there's neither GTEST_COLOR nor --gtest_color.\"\"\"\n    if not IS_WINDOWS:\n      self.assert_(not UsesColor('dumb', None, None))\n      self.assert_(not UsesColor('emacs', None, None))\n      self.assert_(not UsesColor('xterm-mono', None, None))\n      self.assert_(not UsesColor('unknown', None, None))\n      self.assert_(not UsesColor(None, None, None))\n    self.assert_(UsesColor('linux', None, None))",
        "detail": "third-party.googletest.googletest.test.googletest-color-test",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-color-test",
        "description": "third-party.googletest.googletest.test.googletest-color-test",
        "peekOfCode": "def SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    os.environ[env_var] = value\n  elif env_var in os.environ:\n    del os.environ[env_var]\ndef UsesColor(term, color_env_var, color_flag):\n  \"\"\"Runs googletest-color-test_ and returns its exit code.\"\"\"\n  SetEnvVar('TERM', term)\n  SetEnvVar(COLOR_ENV_VAR, color_env_var)",
        "detail": "third-party.googletest.googletest.test.googletest-color-test",
        "documentation": {}
    },
    {
        "label": "UsesColor",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-color-test",
        "description": "third-party.googletest.googletest.test.googletest-color-test",
        "peekOfCode": "def UsesColor(term, color_env_var, color_flag):\n  \"\"\"Runs googletest-color-test_ and returns its exit code.\"\"\"\n  SetEnvVar('TERM', term)\n  SetEnvVar(COLOR_ENV_VAR, color_env_var)\n  if color_flag is None:\n    args = []\n  else:\n    args = ['--%s=%s' % (COLOR_FLAG, color_flag)]\n  p = gtest_test_utils.Subprocess([COMMAND] + args)\n  return not p.exited or p.exit_code",
        "detail": "third-party.googletest.googletest.test.googletest-color-test",
        "documentation": {}
    },
    {
        "label": "IS_WINDOWS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-color-test",
        "description": "third-party.googletest.googletest.test.googletest-color-test",
        "peekOfCode": "IS_WINDOWS = os.name == 'nt'\nCOLOR_ENV_VAR = 'GTEST_COLOR'\nCOLOR_FLAG = 'gtest_color'\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-color-test_')\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    os.environ[env_var] = value\n  elif env_var in os.environ:\n    del os.environ[env_var]",
        "detail": "third-party.googletest.googletest.test.googletest-color-test",
        "documentation": {}
    },
    {
        "label": "COLOR_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-color-test",
        "description": "third-party.googletest.googletest.test.googletest-color-test",
        "peekOfCode": "COLOR_ENV_VAR = 'GTEST_COLOR'\nCOLOR_FLAG = 'gtest_color'\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-color-test_')\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    os.environ[env_var] = value\n  elif env_var in os.environ:\n    del os.environ[env_var]\ndef UsesColor(term, color_env_var, color_flag):",
        "detail": "third-party.googletest.googletest.test.googletest-color-test",
        "documentation": {}
    },
    {
        "label": "COLOR_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-color-test",
        "description": "third-party.googletest.googletest.test.googletest-color-test",
        "peekOfCode": "COLOR_FLAG = 'gtest_color'\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-color-test_')\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    os.environ[env_var] = value\n  elif env_var in os.environ:\n    del os.environ[env_var]\ndef UsesColor(term, color_env_var, color_flag):\n  \"\"\"Runs googletest-color-test_ and returns its exit code.\"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-color-test",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-color-test",
        "description": "third-party.googletest.googletest.test.googletest-color-test",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath('googletest-color-test_')\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    os.environ[env_var] = value\n  elif env_var in os.environ:\n    del os.environ[env_var]\ndef UsesColor(term, color_env_var, color_flag):\n  \"\"\"Runs googletest-color-test_ and returns its exit code.\"\"\"\n  SetEnvVar('TERM', term)",
        "detail": "third-party.googletest.googletest.test.googletest-color-test",
        "documentation": {}
    },
    {
        "label": "GTestEnvVarTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-env-var-test",
        "description": "third-party.googletest.googletest.test.googletest-env-var-test",
        "peekOfCode": "class GTestEnvVarTest(gtest_test_utils.TestCase):\n  def testEnvVarAffectsFlag(self):\n    \"\"\"Tests that environment variable should affect the corresponding flag.\"\"\"\n    TestFlag('break_on_failure', '1', '0')\n    TestFlag('color', 'yes', 'auto')\n    SetEnvVar('TESTBRIDGE_TEST_RUNNER_FAIL_FAST', None)  # For 'fail_fast' test\n    TestFlag('fail_fast', '1', '0')\n    TestFlag('filter', 'FooTest.Bar', '*')\n    SetEnvVar('XML_OUTPUT_FILE', None)  # For 'output' test\n    TestFlag('output', 'xml:tmp/foo.xml', '')",
        "detail": "third-party.googletest.googletest.test.googletest-env-var-test",
        "documentation": {}
    },
    {
        "label": "AssertEq",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-env-var-test",
        "description": "third-party.googletest.googletest.test.googletest-env-var-test",
        "peekOfCode": "def AssertEq(expected, actual):\n  if expected != actual:\n    print('Expected: %s' % (expected,))\n    print('  Actual: %s' % (actual,))\n    raise AssertionError\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:",
        "detail": "third-party.googletest.googletest.test.googletest-env-var-test",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-env-var-test",
        "description": "third-party.googletest.googletest.test.googletest-env-var-test",
        "peekOfCode": "def SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]\ndef GetFlag(flag):\n  \"\"\"Runs googletest-env-var-test_ and returns its output.\"\"\"\n  args = [COMMAND]\n  if flag is not None:",
        "detail": "third-party.googletest.googletest.test.googletest-env-var-test",
        "documentation": {}
    },
    {
        "label": "GetFlag",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-env-var-test",
        "description": "third-party.googletest.googletest.test.googletest-env-var-test",
        "peekOfCode": "def GetFlag(flag):\n  \"\"\"Runs googletest-env-var-test_ and returns its output.\"\"\"\n  args = [COMMAND]\n  if flag is not None:\n    args += [flag]\n  return gtest_test_utils.Subprocess(args, env=environ).output\ndef TestFlag(flag, test_val, default_val):\n  \"\"\"Verifies that the given flag is affected by the corresponding env var.\"\"\"\n  env_var = 'GTEST_' + flag.upper()\n  SetEnvVar(env_var, test_val)",
        "detail": "third-party.googletest.googletest.test.googletest-env-var-test",
        "documentation": {}
    },
    {
        "label": "TestFlag",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-env-var-test",
        "description": "third-party.googletest.googletest.test.googletest-env-var-test",
        "peekOfCode": "def TestFlag(flag, test_val, default_val):\n  \"\"\"Verifies that the given flag is affected by the corresponding env var.\"\"\"\n  env_var = 'GTEST_' + flag.upper()\n  SetEnvVar(env_var, test_val)\n  AssertEq(test_val, GetFlag(flag))\n  SetEnvVar(env_var, None)\n  AssertEq(default_val, GetFlag(flag))\nclass GTestEnvVarTest(gtest_test_utils.TestCase):\n  def testEnvVarAffectsFlag(self):\n    \"\"\"Tests that environment variable should affect the corresponding flag.\"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-env-var-test",
        "documentation": {}
    },
    {
        "label": "IS_WINDOWS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-env-var-test",
        "description": "third-party.googletest.googletest.test.googletest-env-var-test",
        "peekOfCode": "IS_WINDOWS = os.name == 'nt'\nIS_LINUX = os.name == 'posix' and os.uname()[0] == 'Linux'\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-env-var-test_')\nenviron = os.environ.copy()\ndef AssertEq(expected, actual):\n  if expected != actual:\n    print('Expected: %s' % (expected,))\n    print('  Actual: %s' % (actual,))\n    raise AssertionError\ndef SetEnvVar(env_var, value):",
        "detail": "third-party.googletest.googletest.test.googletest-env-var-test",
        "documentation": {}
    },
    {
        "label": "IS_LINUX",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-env-var-test",
        "description": "third-party.googletest.googletest.test.googletest-env-var-test",
        "peekOfCode": "IS_LINUX = os.name == 'posix' and os.uname()[0] == 'Linux'\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-env-var-test_')\nenviron = os.environ.copy()\ndef AssertEq(expected, actual):\n  if expected != actual:\n    print('Expected: %s' % (expected,))\n    print('  Actual: %s' % (actual,))\n    raise AssertionError\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-env-var-test",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-env-var-test",
        "description": "third-party.googletest.googletest.test.googletest-env-var-test",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath('googletest-env-var-test_')\nenviron = os.environ.copy()\ndef AssertEq(expected, actual):\n  if expected != actual:\n    print('Expected: %s' % (expected,))\n    print('  Actual: %s' % (actual,))\n    raise AssertionError\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:",
        "detail": "third-party.googletest.googletest.test.googletest-env-var-test",
        "documentation": {}
    },
    {
        "label": "environ",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-env-var-test",
        "description": "third-party.googletest.googletest.test.googletest-env-var-test",
        "peekOfCode": "environ = os.environ.copy()\ndef AssertEq(expected, actual):\n  if expected != actual:\n    print('Expected: %s' % (expected,))\n    print('  Actual: %s' % (actual,))\n    raise AssertionError\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value",
        "detail": "third-party.googletest.googletest.test.googletest-env-var-test",
        "documentation": {}
    },
    {
        "label": "GTestFailFastUnitTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "class GTestFailFastUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests the env variable or the command line flag for fail_fast.\"\"\"\n  def testDefaultBehavior(self):\n    \"\"\"Tests the behavior of not specifying the fail_fast.\"\"\"\n    txt, _ = RunAndReturnOutput()\n    self.assertIn('22 FAILED TEST', txt)\n  def testGoogletestFlag(self):\n    txt, _ = RunAndReturnOutput(test_suite='HasSimpleTest', fail_fast=True)\n    self.assertIn('1 FAILED TEST', txt)\n    self.assertIn('[  SKIPPED ] 3 tests', txt)",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "def SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]\ndef RunAndReturnOutput(test_suite=None, fail_fast=None, run_disabled=False):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  args = []\n  xml_path = os.path.join(gtest_test_utils.GetTempDir(),",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "RunAndReturnOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "def RunAndReturnOutput(test_suite=None, fail_fast=None, run_disabled=False):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  args = []\n  xml_path = os.path.join(gtest_test_utils.GetTempDir(),\n                          '.GTestFailFastUnitTest.xml')\n  args += ['--gtest_output=xml:' + xml_path]\n  if fail_fast is not None:\n    if isinstance(fail_fast, str):\n      args += ['--%s=%s' % (FAIL_FAST_FLAG, fail_fast)]\n    elif fail_fast:",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "BAZEL_FAIL_FAST_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "BAZEL_FAIL_FAST_ENV_VAR = 'TESTBRIDGE_TEST_RUNNER_FAIL_FAST'\n# The environment variable for specifying fail fast.\nFAIL_FAST_ENV_VAR = 'GTEST_FAIL_FAST'\n# The command line flag for specifying fail fast.\nFAIL_FAST_FLAG = 'gtest_fail_fast'\n# The command line flag to run disabled tests.\nRUN_DISABLED_FLAG = 'gtest_also_run_disabled_tests'\n# The command line flag for specifying a filter.\nFILTER_FLAG = 'gtest_filter'\n# Command to run the googletest-failfast-unittest_ program.",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "FAIL_FAST_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "FAIL_FAST_ENV_VAR = 'GTEST_FAIL_FAST'\n# The command line flag for specifying fail fast.\nFAIL_FAST_FLAG = 'gtest_fail_fast'\n# The command line flag to run disabled tests.\nRUN_DISABLED_FLAG = 'gtest_also_run_disabled_tests'\n# The command line flag for specifying a filter.\nFILTER_FLAG = 'gtest_filter'\n# Command to run the googletest-failfast-unittest_ program.\nCOMMAND = gtest_test_utils.GetTestExecutablePath(\n    'googletest-failfast-unittest_')",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "FAIL_FAST_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "FAIL_FAST_FLAG = 'gtest_fail_fast'\n# The command line flag to run disabled tests.\nRUN_DISABLED_FLAG = 'gtest_also_run_disabled_tests'\n# The command line flag for specifying a filter.\nFILTER_FLAG = 'gtest_filter'\n# Command to run the googletest-failfast-unittest_ program.\nCOMMAND = gtest_test_utils.GetTestExecutablePath(\n    'googletest-failfast-unittest_')\n# The command line flag to tell Google Test to output the list of tests it\n# will run.",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "RUN_DISABLED_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "RUN_DISABLED_FLAG = 'gtest_also_run_disabled_tests'\n# The command line flag for specifying a filter.\nFILTER_FLAG = 'gtest_filter'\n# Command to run the googletest-failfast-unittest_ program.\nCOMMAND = gtest_test_utils.GetTestExecutablePath(\n    'googletest-failfast-unittest_')\n# The command line flag to tell Google Test to output the list of tests it\n# will run.\nLIST_TESTS_FLAG = '--gtest_list_tests'\n# Indicates whether Google Test supports death tests.",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "FILTER_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "FILTER_FLAG = 'gtest_filter'\n# Command to run the googletest-failfast-unittest_ program.\nCOMMAND = gtest_test_utils.GetTestExecutablePath(\n    'googletest-failfast-unittest_')\n# The command line flag to tell Google Test to output the list of tests it\n# will run.\nLIST_TESTS_FLAG = '--gtest_list_tests'\n# Indicates whether Google Test supports death tests.\nSUPPORTS_DEATH_TESTS = 'HasDeathTest' in gtest_test_utils.Subprocess(\n    [COMMAND, LIST_TESTS_FLAG]).output",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath(\n    'googletest-failfast-unittest_')\n# The command line flag to tell Google Test to output the list of tests it\n# will run.\nLIST_TESTS_FLAG = '--gtest_list_tests'\n# Indicates whether Google Test supports death tests.\nSUPPORTS_DEATH_TESTS = 'HasDeathTest' in gtest_test_utils.Subprocess(\n    [COMMAND, LIST_TESTS_FLAG]).output\n# Utilities.\nenviron = os.environ.copy()",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "LIST_TESTS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "LIST_TESTS_FLAG = '--gtest_list_tests'\n# Indicates whether Google Test supports death tests.\nSUPPORTS_DEATH_TESTS = 'HasDeathTest' in gtest_test_utils.Subprocess(\n    [COMMAND, LIST_TESTS_FLAG]).output\n# Utilities.\nenviron = os.environ.copy()\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_DEATH_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "SUPPORTS_DEATH_TESTS = 'HasDeathTest' in gtest_test_utils.Subprocess(\n    [COMMAND, LIST_TESTS_FLAG]).output\n# Utilities.\nenviron = os.environ.copy()\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "environ",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "description": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "peekOfCode": "environ = os.environ.copy()\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]\ndef RunAndReturnOutput(test_suite=None, fail_fast=None, run_disabled=False):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  args = []",
        "detail": "third-party.googletest.googletest.test.googletest-failfast-unittest",
        "documentation": {}
    },
    {
        "label": "GTestFilterUnitTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "class GTestFilterUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests the env variable or the command line flag to filter tests.\"\"\"\n  # Utilities.\n  def AssertSetEqual(self, lhs, rhs):\n    \"\"\"Asserts that two sets are equal.\"\"\"\n    for elem in lhs:\n      self.assert_(elem in rhs, '%s in %s' % (elem, rhs))\n    for elem in rhs:\n      self.assert_(elem in lhs, '%s in %s' % (elem, lhs))\n  def AssertPartitionIsValid(self, set_var, list_of_sets):",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "def SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]\ndef RunAndReturnOutput(args = None):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  return gtest_test_utils.Subprocess([COMMAND] + (args or []),\n                                     env=environ).output",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "RunAndReturnOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "def RunAndReturnOutput(args = None):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  return gtest_test_utils.Subprocess([COMMAND] + (args or []),\n                                     env=environ).output\ndef RunAndExtractTestList(args = None):\n  \"\"\"Runs the test program and returns its exit code and a list of tests run.\"\"\"\n  p = gtest_test_utils.Subprocess([COMMAND] + (args or []), env=environ)\n  tests_run = []\n  test_case = ''\n  test = ''",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "RunAndExtractTestList",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "def RunAndExtractTestList(args = None):\n  \"\"\"Runs the test program and returns its exit code and a list of tests run.\"\"\"\n  p = gtest_test_utils.Subprocess([COMMAND] + (args or []), env=environ)\n  tests_run = []\n  test_case = ''\n  test = ''\n  for line in p.output.split('\\n'):\n    match = TEST_CASE_REGEX.match(line)\n    if match is not None:\n      test_case = match.group(1)",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "InvokeWithModifiedEnv",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "def InvokeWithModifiedEnv(extra_env, function, *args, **kwargs):\n  \"\"\"Runs the given function and arguments in a modified environment.\"\"\"\n  try:\n    original_env = environ.copy()\n    environ.update(extra_env)\n    return function(*args, **kwargs)\n  finally:\n    environ.clear()\n    environ.update(original_env)\ndef RunWithSharding(total_shards, shard_index, command):",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "RunWithSharding",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "def RunWithSharding(total_shards, shard_index, command):\n  \"\"\"Runs a test program shard and returns exit code and a list of tests run.\"\"\"\n  extra_env = {SHARD_INDEX_ENV_VAR: str(shard_index),\n               TOTAL_SHARDS_ENV_VAR: str(total_shards)}\n  return InvokeWithModifiedEnv(extra_env, RunAndExtractTestList, command)\n# The unit test.\nclass GTestFilterUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests the env variable or the command line flag to filter tests.\"\"\"\n  # Utilities.\n  def AssertSetEqual(self, lhs, rhs):",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "CAN_PASS_EMPTY_ENV",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "CAN_PASS_EMPTY_ENV = False\nif sys.executable:\n  os.environ['EMPTY_VAR'] = ''\n  child = gtest_test_utils.Subprocess(\n      [sys.executable, '-c', 'import os; print(\\'EMPTY_VAR\\' in os.environ)'])\n  CAN_PASS_EMPTY_ENV = eval(child.output)\n# Check if this platform can unset environment variables in child processes.\n# We set an env variable to a non-empty string, unset it, and invoke\n# a python script in a subprocess to print whether the variable\n# is NO LONGER in os.environ.",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "CAN_UNSET_ENV",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "CAN_UNSET_ENV = False\nif sys.executable:\n  os.environ['UNSET_VAR'] = 'X'\n  del os.environ['UNSET_VAR']\n  child = gtest_test_utils.Subprocess(\n      [sys.executable, '-c', 'import os; print(\\'UNSET_VAR\\' not in os.environ)'\n      ])\n  CAN_UNSET_ENV = eval(child.output)\n# Checks if we should test with an empty filter. This doesn't\n# make sense on platforms that cannot pass empty env variables (Win32)",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "CAN_TEST_EMPTY_FILTER",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "CAN_TEST_EMPTY_FILTER = (CAN_PASS_EMPTY_ENV and CAN_UNSET_ENV)\n# The environment variable for specifying the test filters.\nFILTER_ENV_VAR = 'GTEST_FILTER'\n# The environment variables for test sharding.\nTOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\n# The command line flag for specifying the test filters.\nFILTER_FLAG = 'gtest_filter'\n# The command line flag for including disabled tests.",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "FILTER_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "FILTER_ENV_VAR = 'GTEST_FILTER'\n# The environment variables for test sharding.\nTOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\n# The command line flag for specifying the test filters.\nFILTER_FLAG = 'gtest_filter'\n# The command line flag for including disabled tests.\nALSO_RUN_DISABLED_TESTS_FLAG = 'gtest_also_run_disabled_tests'\n# Command to run the googletest-filter-unittest_ program.",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "TOTAL_SHARDS_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "TOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\n# The command line flag for specifying the test filters.\nFILTER_FLAG = 'gtest_filter'\n# The command line flag for including disabled tests.\nALSO_RUN_DISABLED_TESTS_FLAG = 'gtest_also_run_disabled_tests'\n# Command to run the googletest-filter-unittest_ program.\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-filter-unittest_')\n# Regex for determining whether parameterized tests are enabled in the binary.",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "SHARD_INDEX_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "SHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\n# The command line flag for specifying the test filters.\nFILTER_FLAG = 'gtest_filter'\n# The command line flag for including disabled tests.\nALSO_RUN_DISABLED_TESTS_FLAG = 'gtest_also_run_disabled_tests'\n# Command to run the googletest-filter-unittest_ program.\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-filter-unittest_')\n# Regex for determining whether parameterized tests are enabled in the binary.\nPARAM_TEST_REGEX = re.compile(r'/ParamTest')",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "SHARD_STATUS_FILE_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "SHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\n# The command line flag for specifying the test filters.\nFILTER_FLAG = 'gtest_filter'\n# The command line flag for including disabled tests.\nALSO_RUN_DISABLED_TESTS_FLAG = 'gtest_also_run_disabled_tests'\n# Command to run the googletest-filter-unittest_ program.\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-filter-unittest_')\n# Regex for determining whether parameterized tests are enabled in the binary.\nPARAM_TEST_REGEX = re.compile(r'/ParamTest')\n# Regex for parsing test case names from Google Test's output.",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "FILTER_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "FILTER_FLAG = 'gtest_filter'\n# The command line flag for including disabled tests.\nALSO_RUN_DISABLED_TESTS_FLAG = 'gtest_also_run_disabled_tests'\n# Command to run the googletest-filter-unittest_ program.\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-filter-unittest_')\n# Regex for determining whether parameterized tests are enabled in the binary.\nPARAM_TEST_REGEX = re.compile(r'/ParamTest')\n# Regex for parsing test case names from Google Test's output.\nTEST_CASE_REGEX = re.compile(r'^\\[\\-+\\] \\d+ tests? from (\\w+(/\\w+)?)')\n# Regex for parsing test names from Google Test's output.",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "ALSO_RUN_DISABLED_TESTS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "ALSO_RUN_DISABLED_TESTS_FLAG = 'gtest_also_run_disabled_tests'\n# Command to run the googletest-filter-unittest_ program.\nCOMMAND = gtest_test_utils.GetTestExecutablePath('googletest-filter-unittest_')\n# Regex for determining whether parameterized tests are enabled in the binary.\nPARAM_TEST_REGEX = re.compile(r'/ParamTest')\n# Regex for parsing test case names from Google Test's output.\nTEST_CASE_REGEX = re.compile(r'^\\[\\-+\\] \\d+ tests? from (\\w+(/\\w+)?)')\n# Regex for parsing test names from Google Test's output.\nTEST_REGEX = re.compile(r'^\\[\\s*RUN\\s*\\].*\\.(\\w+(/\\w+)?)')\n# The command line flag to tell Google Test to output the list of tests it",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath('googletest-filter-unittest_')\n# Regex for determining whether parameterized tests are enabled in the binary.\nPARAM_TEST_REGEX = re.compile(r'/ParamTest')\n# Regex for parsing test case names from Google Test's output.\nTEST_CASE_REGEX = re.compile(r'^\\[\\-+\\] \\d+ tests? from (\\w+(/\\w+)?)')\n# Regex for parsing test names from Google Test's output.\nTEST_REGEX = re.compile(r'^\\[\\s*RUN\\s*\\].*\\.(\\w+(/\\w+)?)')\n# The command line flag to tell Google Test to output the list of tests it\n# will run.\nLIST_TESTS_FLAG = '--gtest_list_tests'",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "PARAM_TEST_REGEX",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "PARAM_TEST_REGEX = re.compile(r'/ParamTest')\n# Regex for parsing test case names from Google Test's output.\nTEST_CASE_REGEX = re.compile(r'^\\[\\-+\\] \\d+ tests? from (\\w+(/\\w+)?)')\n# Regex for parsing test names from Google Test's output.\nTEST_REGEX = re.compile(r'^\\[\\s*RUN\\s*\\].*\\.(\\w+(/\\w+)?)')\n# The command line flag to tell Google Test to output the list of tests it\n# will run.\nLIST_TESTS_FLAG = '--gtest_list_tests'\n# Indicates whether Google Test supports death tests.\nSUPPORTS_DEATH_TESTS = 'HasDeathTest' in gtest_test_utils.Subprocess(",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "TEST_CASE_REGEX",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "TEST_CASE_REGEX = re.compile(r'^\\[\\-+\\] \\d+ tests? from (\\w+(/\\w+)?)')\n# Regex for parsing test names from Google Test's output.\nTEST_REGEX = re.compile(r'^\\[\\s*RUN\\s*\\].*\\.(\\w+(/\\w+)?)')\n# The command line flag to tell Google Test to output the list of tests it\n# will run.\nLIST_TESTS_FLAG = '--gtest_list_tests'\n# Indicates whether Google Test supports death tests.\nSUPPORTS_DEATH_TESTS = 'HasDeathTest' in gtest_test_utils.Subprocess(\n    [COMMAND, LIST_TESTS_FLAG]).output\n# Full names of all tests in googletest-filter-unittests_.",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "TEST_REGEX",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "TEST_REGEX = re.compile(r'^\\[\\s*RUN\\s*\\].*\\.(\\w+(/\\w+)?)')\n# The command line flag to tell Google Test to output the list of tests it\n# will run.\nLIST_TESTS_FLAG = '--gtest_list_tests'\n# Indicates whether Google Test supports death tests.\nSUPPORTS_DEATH_TESTS = 'HasDeathTest' in gtest_test_utils.Subprocess(\n    [COMMAND, LIST_TESTS_FLAG]).output\n# Full names of all tests in googletest-filter-unittests_.\nPARAM_TESTS = [\n    'SeqP/ParamTest.TestX/0',",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "LIST_TESTS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "LIST_TESTS_FLAG = '--gtest_list_tests'\n# Indicates whether Google Test supports death tests.\nSUPPORTS_DEATH_TESTS = 'HasDeathTest' in gtest_test_utils.Subprocess(\n    [COMMAND, LIST_TESTS_FLAG]).output\n# Full names of all tests in googletest-filter-unittests_.\nPARAM_TESTS = [\n    'SeqP/ParamTest.TestX/0',\n    'SeqP/ParamTest.TestX/1',\n    'SeqP/ParamTest.TestY/0',\n    'SeqP/ParamTest.TestY/1',",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_DEATH_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "SUPPORTS_DEATH_TESTS = 'HasDeathTest' in gtest_test_utils.Subprocess(\n    [COMMAND, LIST_TESTS_FLAG]).output\n# Full names of all tests in googletest-filter-unittests_.\nPARAM_TESTS = [\n    'SeqP/ParamTest.TestX/0',\n    'SeqP/ParamTest.TestX/1',\n    'SeqP/ParamTest.TestY/0',\n    'SeqP/ParamTest.TestY/1',\n    'SeqQ/ParamTest.TestX/0',\n    'SeqQ/ParamTest.TestX/1',",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "PARAM_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "PARAM_TESTS = [\n    'SeqP/ParamTest.TestX/0',\n    'SeqP/ParamTest.TestX/1',\n    'SeqP/ParamTest.TestY/0',\n    'SeqP/ParamTest.TestY/1',\n    'SeqQ/ParamTest.TestX/0',\n    'SeqQ/ParamTest.TestX/1',\n    'SeqQ/ParamTest.TestY/0',\n    'SeqQ/ParamTest.TestY/1',\n    ]",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "DISABLED_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "DISABLED_TESTS = [\n    'BarTest.DISABLED_TestFour',\n    'BarTest.DISABLED_TestFive',\n    'BazTest.DISABLED_TestC',\n    'DISABLED_FoobarTest.Test1',\n    'DISABLED_FoobarTest.DISABLED_Test2',\n    'DISABLED_FoobarbazTest.TestA',\n    ]\nif SUPPORTS_DEATH_TESTS:\n  DEATH_TESTS = [",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "ACTIVE_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "ACTIVE_TESTS = [\n    'FooTest.Abc',\n    'FooTest.Xyz',\n    'BarTest.TestOne',\n    'BarTest.TestTwo',\n    'BarTest.TestThree',\n    'BazTest.TestOne',\n    'BazTest.TestA',\n    'BazTest.TestB',\n    ] + DEATH_TESTS + PARAM_TESTS",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "param_tests_present",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "param_tests_present = None\n# Utilities.\nenviron = os.environ.copy()\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]\ndef RunAndReturnOutput(args = None):",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "environ",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "description": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "peekOfCode": "environ = os.environ.copy()\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets the env variable to 'value'; unsets it when 'value' is None.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]\ndef RunAndReturnOutput(args = None):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  return gtest_test_utils.Subprocess([COMMAND] + (args or []),",
        "detail": "third-party.googletest.googletest.test.googletest-filter-unittest",
        "documentation": {}
    },
    {
        "label": "GTestGlobalEnvironmentUnitTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-global-environment-unittest",
        "description": "third-party.googletest.googletest.test.googletest-global-environment-unittest",
        "peekOfCode": "class GTestGlobalEnvironmentUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests global test environment failures.\"\"\"\n  def testEnvironmentSetUpFails(self):\n    \"\"\"Tests the behavior of not specifying the fail_fast.\"\"\"\n    # Run the test.\n    txt = RunAndReturnOutput()\n    # We should see the text of the global environment setup error.\n    self.assertIn('Canned environment setup error', txt)\n    # Our test should have been skipped due to the error, and not treated as a\n    # pass.",
        "detail": "third-party.googletest.googletest.test.googletest-global-environment-unittest",
        "documentation": {}
    },
    {
        "label": "RunAndReturnOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-global-environment-unittest",
        "description": "third-party.googletest.googletest.test.googletest-global-environment-unittest",
        "peekOfCode": "def RunAndReturnOutput(args=None):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  return gtest_test_utils.Subprocess([\n      gtest_test_utils.GetTestExecutablePath(\n          'googletest-global-environment-unittest_')\n  ] + (args or [])).output\nclass GTestGlobalEnvironmentUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests global test environment failures.\"\"\"\n  def testEnvironmentSetUpFails(self):\n    \"\"\"Tests the behavior of not specifying the fail_fast.\"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-global-environment-unittest",
        "documentation": {}
    },
    {
        "label": "GTestJsonOutFilesTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "description": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "peekOfCode": "class GTestJsonOutFilesTest(gtest_test_utils.TestCase):\n  \"\"\"Unit test for Google Test's JSON output functionality.\"\"\"\n  def setUp(self):\n    # We want the trailing '/' that the last \"\" provides in os.path.join, for\n    # telling Google Test to create an output directory instead of a single file\n    # for xml output.\n    self.output_dir_ = os.path.join(gtest_test_utils.GetTempDir(),\n                                    GTEST_OUTPUT_SUBDIR, '')\n    self.DeleteFilesAndDir()\n  def tearDown(self):",
        "detail": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_SUBDIR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "description": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "peekOfCode": "GTEST_OUTPUT_SUBDIR = 'json_outfiles'\nGTEST_OUTPUT_1_TEST = 'gtest_xml_outfile1_test_'\nGTEST_OUTPUT_2_TEST = 'gtest_xml_outfile2_test_'\nEXPECTED_1 = {\n    u'tests':\n        1,\n    u'failures':\n        0,\n    u'disabled':\n        0,",
        "detail": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_1_TEST",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "description": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "peekOfCode": "GTEST_OUTPUT_1_TEST = 'gtest_xml_outfile1_test_'\nGTEST_OUTPUT_2_TEST = 'gtest_xml_outfile2_test_'\nEXPECTED_1 = {\n    u'tests':\n        1,\n    u'failures':\n        0,\n    u'disabled':\n        0,\n    u'errors':",
        "detail": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_2_TEST",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "description": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "peekOfCode": "GTEST_OUTPUT_2_TEST = 'gtest_xml_outfile2_test_'\nEXPECTED_1 = {\n    u'tests':\n        1,\n    u'failures':\n        0,\n    u'disabled':\n        0,\n    u'errors':\n        0,",
        "detail": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "documentation": {}
    },
    {
        "label": "EXPECTED_1",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "description": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "peekOfCode": "EXPECTED_1 = {\n    u'tests':\n        1,\n    u'failures':\n        0,\n    u'disabled':\n        0,\n    u'errors':\n        0,\n    u'time':",
        "detail": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "documentation": {}
    },
    {
        "label": "EXPECTED_2",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "description": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "peekOfCode": "EXPECTED_2 = {\n    u'tests':\n        1,\n    u'failures':\n        0,\n    u'disabled':\n        0,\n    u'errors':\n        0,\n    u'time':",
        "detail": "third-party.googletest.googletest.test.googletest-json-outfiles-test",
        "documentation": {}
    },
    {
        "label": "GTestJsonOutputUnitTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "class GTestJsonOutputUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Unit test for Google Test's JSON output functionality.\n  \"\"\"\n  # This test currently breaks on platforms that do not support typed and\n  # type-parameterized tests, so we don't run it under them.\n  if SUPPORTS_TYPED_TESTS:\n    def testNonEmptyJsonOutput(self):\n      \"\"\"Verifies JSON output for a Google Test binary with non-empty output.\n      Runs a test program that generates a non-empty JSON output, and\n      tests that the JSON output is expected.",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_FILTER_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "GTEST_FILTER_FLAG = '--gtest_filter'\nGTEST_LIST_TESTS_FLAG = '--gtest_list_tests'\nGTEST_OUTPUT_FLAG = '--gtest_output'\nGTEST_DEFAULT_OUTPUT_FILE = 'test_detail.json'\nGTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_LIST_TESTS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "GTEST_LIST_TESTS_FLAG = '--gtest_list_tests'\nGTEST_OUTPUT_FLAG = '--gtest_output'\nGTEST_DEFAULT_OUTPUT_FILE = 'test_detail.json'\nGTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "GTEST_OUTPUT_FLAG = '--gtest_output'\nGTEST_DEFAULT_OUTPUT_FILE = 'test_detail.json'\nGTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_DEFAULT_OUTPUT_FILE",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "GTEST_DEFAULT_OUTPUT_FILE = 'test_detail.json'\nGTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''\nEXPECTED_NON_EMPTY = {",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_PROGRAM_NAME",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "GTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''\nEXPECTED_NON_EMPTY = {\n    u'tests':",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "NO_STACKTRACE_SUPPORT_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "NO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''\nEXPECTED_NON_EMPTY = {\n    u'tests':\n        26,\n    u'failures':",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_STACK_TRACES",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "SUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''\nEXPECTED_NON_EMPTY = {\n    u'tests':\n        26,\n    u'failures':\n        5,",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_NON_EMPTY",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "EXPECTED_NON_EMPTY = {\n    u'tests':\n        26,\n    u'failures':\n        5,\n    u'disabled':\n        2,\n    u'errors':\n        0,\n    u'timestamp':",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_FILTERED",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "EXPECTED_FILTERED = {\n    u'tests':\n        1,\n    u'failures':\n        0,\n    u'disabled':\n        0,\n    u'errors':\n        0,\n    u'time':",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_NO_TEST",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "EXPECTED_NO_TEST = {\n    u'tests':\n        0,\n    u'failures':\n        0,\n    u'disabled':\n        0,\n    u'errors':\n        0,\n    u'time':",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_PROGRAM_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "GTEST_PROGRAM_PATH = gtest_test_utils.GetTestExecutablePath(GTEST_PROGRAM_NAME)\nSUPPORTS_TYPED_TESTS = 'TypedTest' in gtest_test_utils.Subprocess(\n    [GTEST_PROGRAM_PATH, GTEST_LIST_TESTS_FLAG], capture_stderr=False).output\nclass GTestJsonOutputUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Unit test for Google Test's JSON output functionality.\n  \"\"\"\n  # This test currently breaks on platforms that do not support typed and\n  # type-parameterized tests, so we don't run it under them.\n  if SUPPORTS_TYPED_TESTS:\n    def testNonEmptyJsonOutput(self):",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_TYPED_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "description": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "peekOfCode": "SUPPORTS_TYPED_TESTS = 'TypedTest' in gtest_test_utils.Subprocess(\n    [GTEST_PROGRAM_PATH, GTEST_LIST_TESTS_FLAG], capture_stderr=False).output\nclass GTestJsonOutputUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Unit test for Google Test's JSON output functionality.\n  \"\"\"\n  # This test currently breaks on platforms that do not support typed and\n  # type-parameterized tests, so we don't run it under them.\n  if SUPPORTS_TYPED_TESTS:\n    def testNonEmptyJsonOutput(self):\n      \"\"\"Verifies JSON output for a Google Test binary with non-empty output.",
        "detail": "third-party.googletest.googletest.test.googletest-json-output-unittest",
        "documentation": {}
    },
    {
        "label": "GTestListTestsUnitTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "description": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "peekOfCode": "class GTestListTestsUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests using the --gtest_list_tests flag to list all tests.\"\"\"\n  def RunAndVerify(self, flag_value, expected_output_re, other_flag):\n    \"\"\"Runs googletest-list-tests-unittest_ and verifies that it prints\n    the correct tests.\n    Args:\n      flag_value:         value of the --gtest_list_tests flag;\n                          None if the flag should not be present.\n      expected_output_re: regular expression that matches the expected\n                          output after running command;",
        "detail": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "documentation": {}
    },
    {
        "label": "Run",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "description": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "peekOfCode": "def Run(args):\n  \"\"\"Runs googletest-list-tests-unittest_ and returns the list of tests printed.\"\"\"\n  return gtest_test_utils.Subprocess([EXE_PATH] + args,\n                                     capture_stderr=False).output\n# The unit test.\nclass GTestListTestsUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests using the --gtest_list_tests flag to list all tests.\"\"\"\n  def RunAndVerify(self, flag_value, expected_output_re, other_flag):\n    \"\"\"Runs googletest-list-tests-unittest_ and verifies that it prints\n    the correct tests.",
        "detail": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "documentation": {}
    },
    {
        "label": "LIST_TESTS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "description": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "peekOfCode": "LIST_TESTS_FLAG = 'gtest_list_tests'\n# Path to the googletest-list-tests-unittest_ program.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath('googletest-list-tests-unittest_')\n# The expected output when running googletest-list-tests-unittest_ with\n# --gtest_list_tests\nEXPECTED_OUTPUT_NO_FILTER_RE = re.compile(r\"\"\"FooDeathTest\\.\n  Test1\nFoo\\.\n  Bar1\n  Bar2",
        "detail": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "documentation": {}
    },
    {
        "label": "EXE_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "description": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "peekOfCode": "EXE_PATH = gtest_test_utils.GetTestExecutablePath('googletest-list-tests-unittest_')\n# The expected output when running googletest-list-tests-unittest_ with\n# --gtest_list_tests\nEXPECTED_OUTPUT_NO_FILTER_RE = re.compile(r\"\"\"FooDeathTest\\.\n  Test1\nFoo\\.\n  Bar1\n  Bar2\n  DISABLED_Bar3\nAbc\\.",
        "detail": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_OUTPUT_NO_FILTER_RE",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "description": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "peekOfCode": "EXPECTED_OUTPUT_NO_FILTER_RE = re.compile(r\"\"\"FooDeathTest\\.\n  Test1\nFoo\\.\n  Bar1\n  Bar2\n  DISABLED_Bar3\nAbc\\.\n  Xyz\n  Def\nFooBar\\.",
        "detail": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_OUTPUT_FILTER_FOO_RE",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "description": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "peekOfCode": "EXPECTED_OUTPUT_FILTER_FOO_RE = re.compile(r\"\"\"FooDeathTest\\.\n  Test1\nFoo\\.\n  Bar1\n  Bar2\n  DISABLED_Bar3\nFooBar\\.\n  Baz\nFooTest\\.\n  Test1",
        "detail": "third-party.googletest.googletest.test.googletest-list-tests-unittest",
        "documentation": {}
    },
    {
        "label": "GTestOutputTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "class GTestOutputTest(gtest_test_utils.TestCase):\n  def RemoveUnsupportedTests(self, test_output):\n    if not SUPPORTS_DEATH_TESTS:\n      test_output = RemoveMatchingTests(test_output, 'DeathTest')\n    if not SUPPORTS_TYPED_TESTS:\n      test_output = RemoveMatchingTests(test_output, 'TypedTest')\n      test_output = RemoveMatchingTests(test_output, 'TypedDeathTest')\n      test_output = RemoveMatchingTests(test_output, 'TypeParamDeathTest')\n    if not SUPPORTS_THREADS:\n      test_output = RemoveMatchingTests(test_output,",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "ToUnixLineEnding",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def ToUnixLineEnding(s):\n  \"\"\"Changes all Windows/Mac line endings in s to UNIX line endings.\"\"\"\n  return s.replace('\\r\\n', '\\n').replace('\\r', '\\n')\ndef RemoveLocations(test_output):\n  \"\"\"Removes all file location info from a Google Test program's output.\n  Args:\n       test_output:  the output of a Google Test program.\n  Returns:\n       output with all file location info (in the form of\n       'DIRECTORY/FILE_NAME:LINE_NUMBER: 'or",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "RemoveLocations",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def RemoveLocations(test_output):\n  \"\"\"Removes all file location info from a Google Test program's output.\n  Args:\n       test_output:  the output of a Google Test program.\n  Returns:\n       output with all file location info (in the form of\n       'DIRECTORY/FILE_NAME:LINE_NUMBER: 'or\n       'DIRECTORY\\\\FILE_NAME(LINE_NUMBER): ') replaced by\n       'FILE_NAME:#: '.\n  \"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "RemoveStackTraceDetails",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def RemoveStackTraceDetails(output):\n  \"\"\"Removes all stack traces from a Google Test program's output.\"\"\"\n  # *? means \"find the shortest string that matches\".\n  return re.sub(r'Stack trace:(.|\\n)*?\\n\\n',\n                'Stack trace: (omitted)\\n\\n', output)\ndef RemoveStackTraces(output):\n  \"\"\"Removes all traces of stack traces from a Google Test program's output.\"\"\"\n  # *? means \"find the shortest string that matches\".\n  return re.sub(r'Stack trace:(.|\\n)*?\\n\\n', '', output)\ndef RemoveTime(output):",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "RemoveStackTraces",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def RemoveStackTraces(output):\n  \"\"\"Removes all traces of stack traces from a Google Test program's output.\"\"\"\n  # *? means \"find the shortest string that matches\".\n  return re.sub(r'Stack trace:(.|\\n)*?\\n\\n', '', output)\ndef RemoveTime(output):\n  \"\"\"Removes all time information from a Google Test program's output.\"\"\"\n  return re.sub(r'\\(\\d+ ms', '(? ms', output)\ndef RemoveTypeInfoDetails(test_output):\n  \"\"\"Removes compiler-specific type info from Google Test program's output.\n  Args:",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "RemoveTime",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def RemoveTime(output):\n  \"\"\"Removes all time information from a Google Test program's output.\"\"\"\n  return re.sub(r'\\(\\d+ ms', '(? ms', output)\ndef RemoveTypeInfoDetails(test_output):\n  \"\"\"Removes compiler-specific type info from Google Test program's output.\n  Args:\n       test_output:  the output of a Google Test program.\n  Returns:\n       output with type information normalized to canonical form.\n  \"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "RemoveTypeInfoDetails",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def RemoveTypeInfoDetails(test_output):\n  \"\"\"Removes compiler-specific type info from Google Test program's output.\n  Args:\n       test_output:  the output of a Google Test program.\n  Returns:\n       output with type information normalized to canonical form.\n  \"\"\"\n  # some compilers output the name of type 'unsigned int' as 'unsigned'\n  return re.sub(r'unsigned int', 'unsigned', test_output)\ndef NormalizeToCurrentPlatform(test_output):",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "NormalizeToCurrentPlatform",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def NormalizeToCurrentPlatform(test_output):\n  \"\"\"Normalizes platform specific output details for easier comparison.\"\"\"\n  if IS_WINDOWS:\n    # Removes the color information that is not present on Windows.\n    test_output = re.sub('\\x1b\\\\[(0;3\\d)?m', '', test_output)\n    # Changes failure message headers into the Windows format.\n    test_output = re.sub(r': Failure\\n', r': error: ', test_output)\n    # Changes file(line_number) to file:line_number.\n    test_output = re.sub(r'((\\w|\\.)+)\\((\\d+)\\):', r'\\1:\\3:', test_output)\n  return test_output",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "RemoveTestCounts",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def RemoveTestCounts(output):\n  \"\"\"Removes test counts from a Google Test program's output.\"\"\"\n  output = re.sub(r'\\d+ tests?, listed below',\n                  '? tests, listed below', output)\n  output = re.sub(r'\\d+ FAILED TESTS',\n                  '? FAILED TESTS', output)\n  output = re.sub(r'\\d+ tests? from \\d+ test cases?',\n                  '? tests from ? test cases', output)\n  output = re.sub(r'\\d+ tests? from ([a-zA-Z_])',\n                  r'? tests from \\1', output)",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "RemoveMatchingTests",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def RemoveMatchingTests(test_output, pattern):\n  \"\"\"Removes output of specified tests from a Google Test program's output.\n  This function strips not only the beginning and the end of a test but also\n  all output in between.\n  Args:\n    test_output:       A string containing the test output.\n    pattern:           A regex string that matches names of test cases or\n                       tests to remove.\n  Returns:\n    Contents of test_output with tests whose names match pattern removed.",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "NormalizeOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def NormalizeOutput(output):\n  \"\"\"Normalizes output (the output of googletest-output-test_.exe).\"\"\"\n  output = ToUnixLineEnding(output)\n  output = RemoveLocations(output)\n  output = RemoveStackTraceDetails(output)\n  output = RemoveTime(output)\n  return output\ndef GetShellCommandOutput(env_cmd):\n  \"\"\"Runs a command in a sub-process, and returns its output in a string.\n  Args:",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "GetShellCommandOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def GetShellCommandOutput(env_cmd):\n  \"\"\"Runs a command in a sub-process, and returns its output in a string.\n  Args:\n    env_cmd: The shell command. A 2-tuple where element 0 is a dict of extra\n             environment variables to set, and element 1 is a string with\n             the command and any flags.\n  Returns:\n    A string with the command's combined standard and diagnostic output.\n  \"\"\"\n  # Spawns cmd in a sub-process, and gets its standard I/O file objects.",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "GetCommandOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def GetCommandOutput(env_cmd):\n  \"\"\"Runs a command and returns its output with all file location\n  info stripped off.\n  Args:\n    env_cmd:  The shell command. A 2-tuple where element 0 is a dict of extra\n              environment variables to set, and element 1 is a string with\n              the command and any flags.\n  \"\"\"\n  # Disables exception pop-ups on Windows.\n  environ, cmdline = env_cmd",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "GetOutputOfAllCommands",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "def GetOutputOfAllCommands():\n  \"\"\"Returns concatenated output from several representative commands.\"\"\"\n  return (GetCommandOutput(COMMAND_WITH_COLOR) +\n          GetCommandOutput(COMMAND_WITH_TIME) +\n          GetCommandOutput(COMMAND_WITH_DISABLED) +\n          GetCommandOutput(COMMAND_WITH_SHARDING))\ntest_list = GetShellCommandOutput(COMMAND_LIST_TESTS)\nSUPPORTS_DEATH_TESTS = 'DeathTest' in test_list\nSUPPORTS_TYPED_TESTS = 'TypedTest' in test_list\nSUPPORTS_THREADS = 'ExpectFailureWithThreadsTest' in test_list",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "GENGOLDEN_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "GENGOLDEN_FLAG = '--gengolden'\nCATCH_EXCEPTIONS_ENV_VAR_NAME = 'GTEST_CATCH_EXCEPTIONS'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\nIS_LINUX = os.name == 'posix' and os.uname()[0] == 'Linux'\nIS_WINDOWS = os.name == 'nt'\nGOLDEN_NAME = 'googletest-output-test-golden-lin.txt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('googletest-output-test_')\n# At least one command we exercise must not have the\n# 'internal_skip_environment_and_ad_hoc_tests' argument.",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "CATCH_EXCEPTIONS_ENV_VAR_NAME",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "CATCH_EXCEPTIONS_ENV_VAR_NAME = 'GTEST_CATCH_EXCEPTIONS'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\nIS_LINUX = os.name == 'posix' and os.uname()[0] == 'Linux'\nIS_WINDOWS = os.name == 'nt'\nGOLDEN_NAME = 'googletest-output-test-golden-lin.txt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('googletest-output-test_')\n# At least one command we exercise must not have the\n# 'internal_skip_environment_and_ad_hoc_tests' argument.\nCOMMAND_LIST_TESTS = ({}, [PROGRAM_PATH, '--gtest_list_tests'])",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "NO_STACKTRACE_SUPPORT_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "NO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\nIS_LINUX = os.name == 'posix' and os.uname()[0] == 'Linux'\nIS_WINDOWS = os.name == 'nt'\nGOLDEN_NAME = 'googletest-output-test-golden-lin.txt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('googletest-output-test_')\n# At least one command we exercise must not have the\n# 'internal_skip_environment_and_ad_hoc_tests' argument.\nCOMMAND_LIST_TESTS = ({}, [PROGRAM_PATH, '--gtest_list_tests'])\nCOMMAND_WITH_COLOR = ({}, [PROGRAM_PATH, '--gtest_color=yes'])\nCOMMAND_WITH_TIME = ({}, [PROGRAM_PATH,",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "IS_LINUX",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "IS_LINUX = os.name == 'posix' and os.uname()[0] == 'Linux'\nIS_WINDOWS = os.name == 'nt'\nGOLDEN_NAME = 'googletest-output-test-golden-lin.txt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('googletest-output-test_')\n# At least one command we exercise must not have the\n# 'internal_skip_environment_and_ad_hoc_tests' argument.\nCOMMAND_LIST_TESTS = ({}, [PROGRAM_PATH, '--gtest_list_tests'])\nCOMMAND_WITH_COLOR = ({}, [PROGRAM_PATH, '--gtest_color=yes'])\nCOMMAND_WITH_TIME = ({}, [PROGRAM_PATH,\n                          '--gtest_print_time',",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "IS_WINDOWS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "IS_WINDOWS = os.name == 'nt'\nGOLDEN_NAME = 'googletest-output-test-golden-lin.txt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('googletest-output-test_')\n# At least one command we exercise must not have the\n# 'internal_skip_environment_and_ad_hoc_tests' argument.\nCOMMAND_LIST_TESTS = ({}, [PROGRAM_PATH, '--gtest_list_tests'])\nCOMMAND_WITH_COLOR = ({}, [PROGRAM_PATH, '--gtest_color=yes'])\nCOMMAND_WITH_TIME = ({}, [PROGRAM_PATH,\n                          '--gtest_print_time',\n                          'internal_skip_environment_and_ad_hoc_tests',",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "GOLDEN_NAME",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "GOLDEN_NAME = 'googletest-output-test-golden-lin.txt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('googletest-output-test_')\n# At least one command we exercise must not have the\n# 'internal_skip_environment_and_ad_hoc_tests' argument.\nCOMMAND_LIST_TESTS = ({}, [PROGRAM_PATH, '--gtest_list_tests'])\nCOMMAND_WITH_COLOR = ({}, [PROGRAM_PATH, '--gtest_color=yes'])\nCOMMAND_WITH_TIME = ({}, [PROGRAM_PATH,\n                          '--gtest_print_time',\n                          'internal_skip_environment_and_ad_hoc_tests',\n                          '--gtest_filter=FatalFailureTest.*:LoggingTest.*'])",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "PROGRAM_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "PROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('googletest-output-test_')\n# At least one command we exercise must not have the\n# 'internal_skip_environment_and_ad_hoc_tests' argument.\nCOMMAND_LIST_TESTS = ({}, [PROGRAM_PATH, '--gtest_list_tests'])\nCOMMAND_WITH_COLOR = ({}, [PROGRAM_PATH, '--gtest_color=yes'])\nCOMMAND_WITH_TIME = ({}, [PROGRAM_PATH,\n                          '--gtest_print_time',\n                          'internal_skip_environment_and_ad_hoc_tests',\n                          '--gtest_filter=FatalFailureTest.*:LoggingTest.*'])\nCOMMAND_WITH_DISABLED = (",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "COMMAND_LIST_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "COMMAND_LIST_TESTS = ({}, [PROGRAM_PATH, '--gtest_list_tests'])\nCOMMAND_WITH_COLOR = ({}, [PROGRAM_PATH, '--gtest_color=yes'])\nCOMMAND_WITH_TIME = ({}, [PROGRAM_PATH,\n                          '--gtest_print_time',\n                          'internal_skip_environment_and_ad_hoc_tests',\n                          '--gtest_filter=FatalFailureTest.*:LoggingTest.*'])\nCOMMAND_WITH_DISABLED = (\n    {}, [PROGRAM_PATH,\n         '--gtest_also_run_disabled_tests',\n         'internal_skip_environment_and_ad_hoc_tests',",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "COMMAND_WITH_COLOR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "COMMAND_WITH_COLOR = ({}, [PROGRAM_PATH, '--gtest_color=yes'])\nCOMMAND_WITH_TIME = ({}, [PROGRAM_PATH,\n                          '--gtest_print_time',\n                          'internal_skip_environment_and_ad_hoc_tests',\n                          '--gtest_filter=FatalFailureTest.*:LoggingTest.*'])\nCOMMAND_WITH_DISABLED = (\n    {}, [PROGRAM_PATH,\n         '--gtest_also_run_disabled_tests',\n         'internal_skip_environment_and_ad_hoc_tests',\n         '--gtest_filter=*DISABLED_*'])",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "COMMAND_WITH_TIME",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "COMMAND_WITH_TIME = ({}, [PROGRAM_PATH,\n                          '--gtest_print_time',\n                          'internal_skip_environment_and_ad_hoc_tests',\n                          '--gtest_filter=FatalFailureTest.*:LoggingTest.*'])\nCOMMAND_WITH_DISABLED = (\n    {}, [PROGRAM_PATH,\n         '--gtest_also_run_disabled_tests',\n         'internal_skip_environment_and_ad_hoc_tests',\n         '--gtest_filter=*DISABLED_*'])\nCOMMAND_WITH_SHARDING = (",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "COMMAND_WITH_DISABLED",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "COMMAND_WITH_DISABLED = (\n    {}, [PROGRAM_PATH,\n         '--gtest_also_run_disabled_tests',\n         'internal_skip_environment_and_ad_hoc_tests',\n         '--gtest_filter=*DISABLED_*'])\nCOMMAND_WITH_SHARDING = (\n    {'GTEST_SHARD_INDEX': '1', 'GTEST_TOTAL_SHARDS': '2'},\n    [PROGRAM_PATH,\n     'internal_skip_environment_and_ad_hoc_tests',\n     '--gtest_filter=PassingTest.*'])",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "COMMAND_WITH_SHARDING",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "COMMAND_WITH_SHARDING = (\n    {'GTEST_SHARD_INDEX': '1', 'GTEST_TOTAL_SHARDS': '2'},\n    [PROGRAM_PATH,\n     'internal_skip_environment_and_ad_hoc_tests',\n     '--gtest_filter=PassingTest.*'])\nGOLDEN_PATH = os.path.join(gtest_test_utils.GetSourceDir(), GOLDEN_NAME)\ndef ToUnixLineEnding(s):\n  \"\"\"Changes all Windows/Mac line endings in s to UNIX line endings.\"\"\"\n  return s.replace('\\r\\n', '\\n').replace('\\r', '\\n')\ndef RemoveLocations(test_output):",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "GOLDEN_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "GOLDEN_PATH = os.path.join(gtest_test_utils.GetSourceDir(), GOLDEN_NAME)\ndef ToUnixLineEnding(s):\n  \"\"\"Changes all Windows/Mac line endings in s to UNIX line endings.\"\"\"\n  return s.replace('\\r\\n', '\\n').replace('\\r', '\\n')\ndef RemoveLocations(test_output):\n  \"\"\"Removes all file location info from a Google Test program's output.\n  Args:\n       test_output:  the output of a Google Test program.\n  Returns:\n       output with all file location info (in the form of",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "test_list",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "test_list = GetShellCommandOutput(COMMAND_LIST_TESTS)\nSUPPORTS_DEATH_TESTS = 'DeathTest' in test_list\nSUPPORTS_TYPED_TESTS = 'TypedTest' in test_list\nSUPPORTS_THREADS = 'ExpectFailureWithThreadsTest' in test_list\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nCAN_GENERATE_GOLDEN_FILE = (SUPPORTS_DEATH_TESTS and\n                            SUPPORTS_TYPED_TESTS and\n                            SUPPORTS_THREADS and\n                            SUPPORTS_STACK_TRACES)\nclass GTestOutputTest(gtest_test_utils.TestCase):",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_DEATH_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "SUPPORTS_DEATH_TESTS = 'DeathTest' in test_list\nSUPPORTS_TYPED_TESTS = 'TypedTest' in test_list\nSUPPORTS_THREADS = 'ExpectFailureWithThreadsTest' in test_list\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nCAN_GENERATE_GOLDEN_FILE = (SUPPORTS_DEATH_TESTS and\n                            SUPPORTS_TYPED_TESTS and\n                            SUPPORTS_THREADS and\n                            SUPPORTS_STACK_TRACES)\nclass GTestOutputTest(gtest_test_utils.TestCase):\n  def RemoveUnsupportedTests(self, test_output):",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_TYPED_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "SUPPORTS_TYPED_TESTS = 'TypedTest' in test_list\nSUPPORTS_THREADS = 'ExpectFailureWithThreadsTest' in test_list\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nCAN_GENERATE_GOLDEN_FILE = (SUPPORTS_DEATH_TESTS and\n                            SUPPORTS_TYPED_TESTS and\n                            SUPPORTS_THREADS and\n                            SUPPORTS_STACK_TRACES)\nclass GTestOutputTest(gtest_test_utils.TestCase):\n  def RemoveUnsupportedTests(self, test_output):\n    if not SUPPORTS_DEATH_TESTS:",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_THREADS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "SUPPORTS_THREADS = 'ExpectFailureWithThreadsTest' in test_list\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nCAN_GENERATE_GOLDEN_FILE = (SUPPORTS_DEATH_TESTS and\n                            SUPPORTS_TYPED_TESTS and\n                            SUPPORTS_THREADS and\n                            SUPPORTS_STACK_TRACES)\nclass GTestOutputTest(gtest_test_utils.TestCase):\n  def RemoveUnsupportedTests(self, test_output):\n    if not SUPPORTS_DEATH_TESTS:\n      test_output = RemoveMatchingTests(test_output, 'DeathTest')",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_STACK_TRACES",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "SUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nCAN_GENERATE_GOLDEN_FILE = (SUPPORTS_DEATH_TESTS and\n                            SUPPORTS_TYPED_TESTS and\n                            SUPPORTS_THREADS and\n                            SUPPORTS_STACK_TRACES)\nclass GTestOutputTest(gtest_test_utils.TestCase):\n  def RemoveUnsupportedTests(self, test_output):\n    if not SUPPORTS_DEATH_TESTS:\n      test_output = RemoveMatchingTests(test_output, 'DeathTest')\n    if not SUPPORTS_TYPED_TESTS:",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "CAN_GENERATE_GOLDEN_FILE",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-output-test",
        "description": "third-party.googletest.googletest.test.googletest-output-test",
        "peekOfCode": "CAN_GENERATE_GOLDEN_FILE = (SUPPORTS_DEATH_TESTS and\n                            SUPPORTS_TYPED_TESTS and\n                            SUPPORTS_THREADS and\n                            SUPPORTS_STACK_TRACES)\nclass GTestOutputTest(gtest_test_utils.TestCase):\n  def RemoveUnsupportedTests(self, test_output):\n    if not SUPPORTS_DEATH_TESTS:\n      test_output = RemoveMatchingTests(test_output, 'DeathTest')\n    if not SUPPORTS_TYPED_TESTS:\n      test_output = RemoveMatchingTests(test_output, 'TypedTest')",
        "detail": "third-party.googletest.googletest.test.googletest-output-test",
        "documentation": {}
    },
    {
        "label": "GTestParamTestInvalidName1Test",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "peekOfCode": "class GTestParamTestInvalidName1Test(gtest_test_utils.TestCase):\n  def testExitCodeAndOutput(self):\n    TestExitCodeAndOutput(COMMAND)\nif __name__ == '__main__':\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "documentation": {}
    },
    {
        "label": "Assert",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "peekOfCode": "def Assert(condition):\n  if not condition:\n    raise AssertionError\ndef TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  err = ('Parameterized test name \\'\"InvalidWithQuotes\"\\' is invalid')\n  p = gtest_test_utils.Subprocess(command)\n  Assert(p.terminated_by_signal)\n  # Verify the output message contains appropriate output\n  Assert(err in p.output)",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "documentation": {}
    },
    {
        "label": "TestExitCodeAndOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "peekOfCode": "def TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  err = ('Parameterized test name \\'\"InvalidWithQuotes\"\\' is invalid')\n  p = gtest_test_utils.Subprocess(command)\n  Assert(p.terminated_by_signal)\n  # Verify the output message contains appropriate output\n  Assert(err in p.output)\nclass GTestParamTestInvalidName1Test(gtest_test_utils.TestCase):\n  def testExitCodeAndOutput(self):\n    TestExitCodeAndOutput(COMMAND)",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "documentation": {}
    },
    {
        "label": "binary_name",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "peekOfCode": "binary_name = 'googletest-param-test-invalid-name1-test_'\nCOMMAND = gtest_test_utils.GetTestExecutablePath(binary_name)\ndef Assert(condition):\n  if not condition:\n    raise AssertionError\ndef TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  err = ('Parameterized test name \\'\"InvalidWithQuotes\"\\' is invalid')\n  p = gtest_test_utils.Subprocess(command)\n  Assert(p.terminated_by_signal)",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath(binary_name)\ndef Assert(condition):\n  if not condition:\n    raise AssertionError\ndef TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  err = ('Parameterized test name \\'\"InvalidWithQuotes\"\\' is invalid')\n  p = gtest_test_utils.Subprocess(command)\n  Assert(p.terminated_by_signal)\n  # Verify the output message contains appropriate output",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name1-test",
        "documentation": {}
    },
    {
        "label": "GTestParamTestInvalidName2Test",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "peekOfCode": "class GTestParamTestInvalidName2Test(gtest_test_utils.TestCase):\n  def testExitCodeAndOutput(self):\n    TestExitCodeAndOutput(COMMAND)\nif __name__ == '__main__':\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "documentation": {}
    },
    {
        "label": "Assert",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "peekOfCode": "def Assert(condition):\n  if not condition:\n    raise AssertionError\ndef TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  err = ('Duplicate parameterized test name \\'a\\'')\n  p = gtest_test_utils.Subprocess(command)\n  Assert(p.terminated_by_signal)\n  # Check for appropriate output\n  Assert(err in p.output)",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "documentation": {}
    },
    {
        "label": "TestExitCodeAndOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "peekOfCode": "def TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  err = ('Duplicate parameterized test name \\'a\\'')\n  p = gtest_test_utils.Subprocess(command)\n  Assert(p.terminated_by_signal)\n  # Check for appropriate output\n  Assert(err in p.output)\nclass GTestParamTestInvalidName2Test(gtest_test_utils.TestCase):\n  def testExitCodeAndOutput(self):\n    TestExitCodeAndOutput(COMMAND)",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "documentation": {}
    },
    {
        "label": "binary_name",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "peekOfCode": "binary_name = 'googletest-param-test-invalid-name2-test_'\nCOMMAND = gtest_test_utils.GetTestExecutablePath(binary_name)\ndef Assert(condition):\n  if not condition:\n    raise AssertionError\ndef TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  err = ('Duplicate parameterized test name \\'a\\'')\n  p = gtest_test_utils.Subprocess(command)\n  Assert(p.terminated_by_signal)",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "description": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath(binary_name)\ndef Assert(condition):\n  if not condition:\n    raise AssertionError\ndef TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  err = ('Duplicate parameterized test name \\'a\\'')\n  p = gtest_test_utils.Subprocess(command)\n  Assert(p.terminated_by_signal)\n  # Check for appropriate output",
        "detail": "third-party.googletest.googletest.test.googletest-param-test-invalid-name2-test",
        "documentation": {}
    },
    {
        "label": "GTestSetUpTestSuiteTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-setuptestsuite-test",
        "description": "third-party.googletest.googletest.test.googletest-setuptestsuite-test",
        "peekOfCode": "class GTestSetUpTestSuiteTest(gtest_test_utils.TestCase):\n  def testSetupErrorAndTearDownError(self):\n    p = gtest_test_utils.Subprocess(COMMAND)\n    self.assertNotEqual(p.exit_code, 0, msg=p.output)\n    self.assertIn(\n        '[  FAILED  ] SetupFailTest: SetUpTestSuite or TearDownTestSuite\\n'\n        '[  FAILED  ] TearDownFailTest: SetUpTestSuite or TearDownTestSuite\\n'\n        '\\n'\n        ' 2 FAILED TEST SUITES\\n',\n        p.output)",
        "detail": "third-party.googletest.googletest.test.googletest-setuptestsuite-test",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-setuptestsuite-test",
        "description": "third-party.googletest.googletest.test.googletest-setuptestsuite-test",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath(\n    'googletest-setuptestsuite-test_')\nclass GTestSetUpTestSuiteTest(gtest_test_utils.TestCase):\n  def testSetupErrorAndTearDownError(self):\n    p = gtest_test_utils.Subprocess(COMMAND)\n    self.assertNotEqual(p.exit_code, 0, msg=p.output)\n    self.assertIn(\n        '[  FAILED  ] SetupFailTest: SetUpTestSuite or TearDownTestSuite\\n'\n        '[  FAILED  ] TearDownFailTest: SetUpTestSuite or TearDownTestSuite\\n'\n        '\\n'",
        "detail": "third-party.googletest.googletest.test.googletest-setuptestsuite-test",
        "documentation": {}
    },
    {
        "label": "GTestShuffleUnitTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "class GTestShuffleUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Tests test shuffling.\"\"\"\n  def setUp(self):\n    CalculateTestLists()\n  def testShufflePreservesNumberOfTests(self):\n    self.assertEqual(len(ALL_TESTS), len(SHUFFLED_ALL_TESTS))\n    self.assertEqual(len(ACTIVE_TESTS), len(SHUFFLED_ACTIVE_TESTS))\n    self.assertEqual(len(FILTERED_TESTS), len(SHUFFLED_FILTERED_TESTS))\n    self.assertEqual(len(SHARDED_TESTS), len(SHUFFLED_SHARDED_TESTS))\n  def testShuffleChangesTestOrder(self):",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "AlsoRunDisabledTestsFlag",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "def AlsoRunDisabledTestsFlag():\n  return '--gtest_also_run_disabled_tests'\ndef FilterFlag(test_filter):\n  return '--gtest_filter=%s' % (test_filter,)\ndef RepeatFlag(n):\n  return '--gtest_repeat=%s' % (n,)\ndef ShuffleFlag():\n  return '--gtest_shuffle'\ndef RandomSeedFlag(n):\n  return '--gtest_random_seed=%s' % (n,)",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "FilterFlag",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "def FilterFlag(test_filter):\n  return '--gtest_filter=%s' % (test_filter,)\ndef RepeatFlag(n):\n  return '--gtest_repeat=%s' % (n,)\ndef ShuffleFlag():\n  return '--gtest_shuffle'\ndef RandomSeedFlag(n):\n  return '--gtest_random_seed=%s' % (n,)\ndef RunAndReturnOutput(extra_env, args):\n  \"\"\"Runs the test program and returns its output.\"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "RepeatFlag",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "def RepeatFlag(n):\n  return '--gtest_repeat=%s' % (n,)\ndef ShuffleFlag():\n  return '--gtest_shuffle'\ndef RandomSeedFlag(n):\n  return '--gtest_random_seed=%s' % (n,)\ndef RunAndReturnOutput(extra_env, args):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  environ_copy = os.environ.copy()\n  environ_copy.update(extra_env)",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "ShuffleFlag",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "def ShuffleFlag():\n  return '--gtest_shuffle'\ndef RandomSeedFlag(n):\n  return '--gtest_random_seed=%s' % (n,)\ndef RunAndReturnOutput(extra_env, args):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  environ_copy = os.environ.copy()\n  environ_copy.update(extra_env)\n  return gtest_test_utils.Subprocess([COMMAND] + args, env=environ_copy).output\ndef GetTestsForAllIterations(extra_env, args):",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "RandomSeedFlag",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "def RandomSeedFlag(n):\n  return '--gtest_random_seed=%s' % (n,)\ndef RunAndReturnOutput(extra_env, args):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  environ_copy = os.environ.copy()\n  environ_copy.update(extra_env)\n  return gtest_test_utils.Subprocess([COMMAND] + args, env=environ_copy).output\ndef GetTestsForAllIterations(extra_env, args):\n  \"\"\"Runs the test program and returns a list of test lists.\n  Args:",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "RunAndReturnOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "def RunAndReturnOutput(extra_env, args):\n  \"\"\"Runs the test program and returns its output.\"\"\"\n  environ_copy = os.environ.copy()\n  environ_copy.update(extra_env)\n  return gtest_test_utils.Subprocess([COMMAND] + args, env=environ_copy).output\ndef GetTestsForAllIterations(extra_env, args):\n  \"\"\"Runs the test program and returns a list of test lists.\n  Args:\n    extra_env: a map from environment variables to their values\n    args: command line flags to pass to googletest-shuffle-test_",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "GetTestsForAllIterations",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "def GetTestsForAllIterations(extra_env, args):\n  \"\"\"Runs the test program and returns a list of test lists.\n  Args:\n    extra_env: a map from environment variables to their values\n    args: command line flags to pass to googletest-shuffle-test_\n  Returns:\n    A list where the i-th element is the list of tests run in the i-th\n    test iteration.\n  \"\"\"\n  test_iterations = []",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "GetTestCases",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "def GetTestCases(tests):\n  \"\"\"Returns a list of test cases in the given full test names.\n  Args:\n    tests: a list of full test names\n  Returns:\n    A list of test cases from 'tests', in their original order.\n    Consecutive duplicates are removed.\n  \"\"\"\n  test_cases = []\n  for test in tests:",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "CalculateTestLists",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "def CalculateTestLists():\n  \"\"\"Calculates the list of tests run under different flags.\"\"\"\n  if not ALL_TESTS:\n    ALL_TESTS.extend(\n        GetTestsForAllIterations({}, [AlsoRunDisabledTestsFlag()])[0])\n  if not ACTIVE_TESTS:\n    ACTIVE_TESTS.extend(GetTestsForAllIterations({}, [])[0])\n  if not FILTERED_TESTS:\n    FILTERED_TESTS.extend(\n        GetTestsForAllIterations({}, [FilterFlag(TEST_FILTER)])[0])",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath('googletest-shuffle-test_')\n# The environment variables for test sharding.\nTOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nTEST_FILTER = 'A*.A:A*.B:C*'\nALL_TESTS = []\nACTIVE_TESTS = []\nFILTERED_TESTS = []\nSHARDED_TESTS = []\nSHUFFLED_ALL_TESTS = []",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "TOTAL_SHARDS_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "TOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nTEST_FILTER = 'A*.A:A*.B:C*'\nALL_TESTS = []\nACTIVE_TESTS = []\nFILTERED_TESTS = []\nSHARDED_TESTS = []\nSHUFFLED_ALL_TESTS = []\nSHUFFLED_ACTIVE_TESTS = []\nSHUFFLED_FILTERED_TESTS = []",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "SHARD_INDEX_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "SHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nTEST_FILTER = 'A*.A:A*.B:C*'\nALL_TESTS = []\nACTIVE_TESTS = []\nFILTERED_TESTS = []\nSHARDED_TESTS = []\nSHUFFLED_ALL_TESTS = []\nSHUFFLED_ACTIVE_TESTS = []\nSHUFFLED_FILTERED_TESTS = []\nSHUFFLED_SHARDED_TESTS = []",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "TEST_FILTER",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "TEST_FILTER = 'A*.A:A*.B:C*'\nALL_TESTS = []\nACTIVE_TESTS = []\nFILTERED_TESTS = []\nSHARDED_TESTS = []\nSHUFFLED_ALL_TESTS = []\nSHUFFLED_ACTIVE_TESTS = []\nSHUFFLED_FILTERED_TESTS = []\nSHUFFLED_SHARDED_TESTS = []\ndef AlsoRunDisabledTestsFlag():",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "ALL_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "ALL_TESTS = []\nACTIVE_TESTS = []\nFILTERED_TESTS = []\nSHARDED_TESTS = []\nSHUFFLED_ALL_TESTS = []\nSHUFFLED_ACTIVE_TESTS = []\nSHUFFLED_FILTERED_TESTS = []\nSHUFFLED_SHARDED_TESTS = []\ndef AlsoRunDisabledTestsFlag():\n  return '--gtest_also_run_disabled_tests'",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "ACTIVE_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "ACTIVE_TESTS = []\nFILTERED_TESTS = []\nSHARDED_TESTS = []\nSHUFFLED_ALL_TESTS = []\nSHUFFLED_ACTIVE_TESTS = []\nSHUFFLED_FILTERED_TESTS = []\nSHUFFLED_SHARDED_TESTS = []\ndef AlsoRunDisabledTestsFlag():\n  return '--gtest_also_run_disabled_tests'\ndef FilterFlag(test_filter):",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "FILTERED_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "FILTERED_TESTS = []\nSHARDED_TESTS = []\nSHUFFLED_ALL_TESTS = []\nSHUFFLED_ACTIVE_TESTS = []\nSHUFFLED_FILTERED_TESTS = []\nSHUFFLED_SHARDED_TESTS = []\ndef AlsoRunDisabledTestsFlag():\n  return '--gtest_also_run_disabled_tests'\ndef FilterFlag(test_filter):\n  return '--gtest_filter=%s' % (test_filter,)",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "SHARDED_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "SHARDED_TESTS = []\nSHUFFLED_ALL_TESTS = []\nSHUFFLED_ACTIVE_TESTS = []\nSHUFFLED_FILTERED_TESTS = []\nSHUFFLED_SHARDED_TESTS = []\ndef AlsoRunDisabledTestsFlag():\n  return '--gtest_also_run_disabled_tests'\ndef FilterFlag(test_filter):\n  return '--gtest_filter=%s' % (test_filter,)\ndef RepeatFlag(n):",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "SHUFFLED_ALL_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "SHUFFLED_ALL_TESTS = []\nSHUFFLED_ACTIVE_TESTS = []\nSHUFFLED_FILTERED_TESTS = []\nSHUFFLED_SHARDED_TESTS = []\ndef AlsoRunDisabledTestsFlag():\n  return '--gtest_also_run_disabled_tests'\ndef FilterFlag(test_filter):\n  return '--gtest_filter=%s' % (test_filter,)\ndef RepeatFlag(n):\n  return '--gtest_repeat=%s' % (n,)",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "SHUFFLED_ACTIVE_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "SHUFFLED_ACTIVE_TESTS = []\nSHUFFLED_FILTERED_TESTS = []\nSHUFFLED_SHARDED_TESTS = []\ndef AlsoRunDisabledTestsFlag():\n  return '--gtest_also_run_disabled_tests'\ndef FilterFlag(test_filter):\n  return '--gtest_filter=%s' % (test_filter,)\ndef RepeatFlag(n):\n  return '--gtest_repeat=%s' % (n,)\ndef ShuffleFlag():",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "SHUFFLED_FILTERED_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "SHUFFLED_FILTERED_TESTS = []\nSHUFFLED_SHARDED_TESTS = []\ndef AlsoRunDisabledTestsFlag():\n  return '--gtest_also_run_disabled_tests'\ndef FilterFlag(test_filter):\n  return '--gtest_filter=%s' % (test_filter,)\ndef RepeatFlag(n):\n  return '--gtest_repeat=%s' % (n,)\ndef ShuffleFlag():\n  return '--gtest_shuffle'",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "SHUFFLED_SHARDED_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "description": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "peekOfCode": "SHUFFLED_SHARDED_TESTS = []\ndef AlsoRunDisabledTestsFlag():\n  return '--gtest_also_run_disabled_tests'\ndef FilterFlag(test_filter):\n  return '--gtest_filter=%s' % (test_filter,)\ndef RepeatFlag(n):\n  return '--gtest_repeat=%s' % (n,)\ndef ShuffleFlag():\n  return '--gtest_shuffle'\ndef RandomSeedFlag(n):",
        "detail": "third-party.googletest.googletest.test.googletest-shuffle-test",
        "documentation": {}
    },
    {
        "label": "ThrowOnFailureTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "description": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "peekOfCode": "class ThrowOnFailureTest(gtest_test_utils.TestCase):\n  \"\"\"Tests the throw-on-failure mode.\"\"\"\n  def RunAndVerify(self, env_var_value, flag_value, should_fail):\n    \"\"\"Runs googletest-throw-on-failure-test_ and verifies that it does\n    (or does not) exit with a non-zero code.\n    Args:\n      env_var_value:    value of the GTEST_BREAK_ON_FAILURE environment\n                        variable; None if the variable should be unset.\n      flag_value:       value of the --gtest_break_on_failure flag;\n                        None if the flag should not be present.",
        "detail": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "description": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "peekOfCode": "def SetEnvVar(env_var, value):\n  \"\"\"Sets an environment variable to a given value; unsets it when the\n  given value is None.\n  \"\"\"\n  env_var = env_var.upper()\n  if value is not None:\n    os.environ[env_var] = value\n  elif env_var in os.environ:\n    del os.environ[env_var]\ndef Run(command):",
        "detail": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "documentation": {}
    },
    {
        "label": "Run",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "description": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "peekOfCode": "def Run(command):\n  \"\"\"Runs a command; returns True/False if its exit code is/isn't 0.\"\"\"\n  print('Running \"%s\". . .' % ' '.join(command))\n  p = gtest_test_utils.Subprocess(command)\n  return p.exited and p.exit_code == 0\n# The tests.\nclass ThrowOnFailureTest(gtest_test_utils.TestCase):\n  \"\"\"Tests the throw-on-failure mode.\"\"\"\n  def RunAndVerify(self, env_var_value, flag_value, should_fail):\n    \"\"\"Runs googletest-throw-on-failure-test_ and verifies that it does",
        "detail": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "documentation": {}
    },
    {
        "label": "THROW_ON_FAILURE",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "description": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "peekOfCode": "THROW_ON_FAILURE = 'gtest_throw_on_failure'\n# Path to the googletest-throw-on-failure-test_ program, compiled with\n# exceptions disabled.\nEXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-throw-on-failure-test_')\n# Utilities.\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets an environment variable to a given value; unsets it when the\n  given value is None.\n  \"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "documentation": {}
    },
    {
        "label": "EXE_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "description": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "peekOfCode": "EXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'googletest-throw-on-failure-test_')\n# Utilities.\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets an environment variable to a given value; unsets it when the\n  given value is None.\n  \"\"\"\n  env_var = env_var.upper()\n  if value is not None:\n    os.environ[env_var] = value",
        "detail": "third-party.googletest.googletest.test.googletest-throw-on-failure-test",
        "documentation": {}
    },
    {
        "label": "GTestUninitializedTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "description": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "peekOfCode": "class GTestUninitializedTest(gtest_test_utils.TestCase):\n  def testExitCodeAndOutput(self):\n    TestExitCodeAndOutput(COMMAND)\nif __name__ == '__main__':\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "documentation": {}
    },
    {
        "label": "Assert",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "description": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "peekOfCode": "def Assert(condition):\n  if not condition:\n    raise AssertionError\ndef AssertEq(expected, actual):\n  if expected != actual:\n    print('Expected: %s' % (expected,))\n    print('  Actual: %s' % (actual,))\n    raise AssertionError\ndef TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"",
        "detail": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "documentation": {}
    },
    {
        "label": "AssertEq",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "description": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "peekOfCode": "def AssertEq(expected, actual):\n  if expected != actual:\n    print('Expected: %s' % (expected,))\n    print('  Actual: %s' % (actual,))\n    raise AssertionError\ndef TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  # Verifies that 'command' exits with code 1.\n  p = gtest_test_utils.Subprocess(command)\n  if p.exited and p.exit_code == 0:",
        "detail": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "documentation": {}
    },
    {
        "label": "TestExitCodeAndOutput",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "description": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "peekOfCode": "def TestExitCodeAndOutput(command):\n  \"\"\"Runs the given command and verifies its exit code and output.\"\"\"\n  # Verifies that 'command' exits with code 1.\n  p = gtest_test_utils.Subprocess(command)\n  if p.exited and p.exit_code == 0:\n    Assert('IMPORTANT NOTICE' in p.output);\n  Assert('InitGoogleTest' in p.output)\nclass GTestUninitializedTest(gtest_test_utils.TestCase):\n  def testExitCodeAndOutput(self):\n    TestExitCodeAndOutput(COMMAND)",
        "detail": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "description": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath('googletest-uninitialized-test_')\ndef Assert(condition):\n  if not condition:\n    raise AssertionError\ndef AssertEq(expected, actual):\n  if expected != actual:\n    print('Expected: %s' % (expected,))\n    print('  Actual: %s' % (actual,))\n    raise AssertionError\ndef TestExitCodeAndOutput(command):",
        "detail": "third-party.googletest.googletest.test.googletest-uninitialized-test",
        "documentation": {}
    },
    {
        "label": "GTestHelpTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "class GTestHelpTest(gtest_test_utils.TestCase):\n  \"\"\"Tests the --help flag and its equivalent forms.\"\"\"\n  def TestHelpFlag(self, flag):\n    \"\"\"Verifies correct behavior when help flag is specified.\n    The right message must be printed and the tests must\n    skipped when the given flag is specified.\n    Args:\n      flag:  A flag to pass to the binary or None.\n    \"\"\"\n    exit_code, output = RunWithFlag(flag)",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "RunWithFlag",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "def RunWithFlag(flag):\n  \"\"\"Runs gtest_help_test_ with the given flag.\n  Returns:\n    the exit code and the text output as a tuple.\n  Args:\n    flag: the command-line flag to pass to gtest_help_test_, or None.\n  \"\"\"\n  if flag is None:\n    command = [PROGRAM_PATH]\n  else:",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "IS_LINUX",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "IS_LINUX = os.name == 'posix' and os.uname()[0] == 'Linux'\nIS_GNUHURD = os.name == 'posix' and os.uname()[0] == 'GNU'\nIS_GNUKFREEBSD = os.name == 'posix' and os.uname()[0] == 'GNU/kFreeBSD'\nIS_WINDOWS = os.name == 'nt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('gtest_help_test_')\nFLAG_PREFIX = '--gtest_'\nDEATH_TEST_STYLE_FLAG = FLAG_PREFIX + 'death_test_style'\nSTREAM_RESULT_TO_FLAG = FLAG_PREFIX + 'stream_result_to'\nUNKNOWN_FLAG = FLAG_PREFIX + 'unknown_flag_for_testing'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "IS_GNUHURD",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "IS_GNUHURD = os.name == 'posix' and os.uname()[0] == 'GNU'\nIS_GNUKFREEBSD = os.name == 'posix' and os.uname()[0] == 'GNU/kFreeBSD'\nIS_WINDOWS = os.name == 'nt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('gtest_help_test_')\nFLAG_PREFIX = '--gtest_'\nDEATH_TEST_STYLE_FLAG = FLAG_PREFIX + 'death_test_style'\nSTREAM_RESULT_TO_FLAG = FLAG_PREFIX + 'stream_result_to'\nUNKNOWN_FLAG = FLAG_PREFIX + 'unknown_flag_for_testing'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nINCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "IS_GNUKFREEBSD",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "IS_GNUKFREEBSD = os.name == 'posix' and os.uname()[0] == 'GNU/kFreeBSD'\nIS_WINDOWS = os.name == 'nt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('gtest_help_test_')\nFLAG_PREFIX = '--gtest_'\nDEATH_TEST_STYLE_FLAG = FLAG_PREFIX + 'death_test_style'\nSTREAM_RESULT_TO_FLAG = FLAG_PREFIX + 'stream_result_to'\nUNKNOWN_FLAG = FLAG_PREFIX + 'unknown_flag_for_testing'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nINCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),\n                           re.sub('^--', '/', LIST_TESTS_FLAG),",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "IS_WINDOWS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "IS_WINDOWS = os.name == 'nt'\nPROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('gtest_help_test_')\nFLAG_PREFIX = '--gtest_'\nDEATH_TEST_STYLE_FLAG = FLAG_PREFIX + 'death_test_style'\nSTREAM_RESULT_TO_FLAG = FLAG_PREFIX + 'stream_result_to'\nUNKNOWN_FLAG = FLAG_PREFIX + 'unknown_flag_for_testing'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nINCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),\n                           re.sub('^--', '/', LIST_TESTS_FLAG),\n                           re.sub('_', '-', LIST_TESTS_FLAG)]",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "PROGRAM_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "PROGRAM_PATH = gtest_test_utils.GetTestExecutablePath('gtest_help_test_')\nFLAG_PREFIX = '--gtest_'\nDEATH_TEST_STYLE_FLAG = FLAG_PREFIX + 'death_test_style'\nSTREAM_RESULT_TO_FLAG = FLAG_PREFIX + 'stream_result_to'\nUNKNOWN_FLAG = FLAG_PREFIX + 'unknown_flag_for_testing'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nINCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),\n                           re.sub('^--', '/', LIST_TESTS_FLAG),\n                           re.sub('_', '-', LIST_TESTS_FLAG)]\nINTERNAL_FLAG_FOR_TESTING = FLAG_PREFIX + 'internal_flag_for_testing'",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "FLAG_PREFIX",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "FLAG_PREFIX = '--gtest_'\nDEATH_TEST_STYLE_FLAG = FLAG_PREFIX + 'death_test_style'\nSTREAM_RESULT_TO_FLAG = FLAG_PREFIX + 'stream_result_to'\nUNKNOWN_FLAG = FLAG_PREFIX + 'unknown_flag_for_testing'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nINCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),\n                           re.sub('^--', '/', LIST_TESTS_FLAG),\n                           re.sub('_', '-', LIST_TESTS_FLAG)]\nINTERNAL_FLAG_FOR_TESTING = FLAG_PREFIX + 'internal_flag_for_testing'\nSUPPORTS_DEATH_TESTS = \"DeathTest\" in gtest_test_utils.Subprocess(",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "DEATH_TEST_STYLE_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "DEATH_TEST_STYLE_FLAG = FLAG_PREFIX + 'death_test_style'\nSTREAM_RESULT_TO_FLAG = FLAG_PREFIX + 'stream_result_to'\nUNKNOWN_FLAG = FLAG_PREFIX + 'unknown_flag_for_testing'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nINCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),\n                           re.sub('^--', '/', LIST_TESTS_FLAG),\n                           re.sub('_', '-', LIST_TESTS_FLAG)]\nINTERNAL_FLAG_FOR_TESTING = FLAG_PREFIX + 'internal_flag_for_testing'\nSUPPORTS_DEATH_TESTS = \"DeathTest\" in gtest_test_utils.Subprocess(\n    [PROGRAM_PATH, LIST_TESTS_FLAG]).output",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "STREAM_RESULT_TO_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "STREAM_RESULT_TO_FLAG = FLAG_PREFIX + 'stream_result_to'\nUNKNOWN_FLAG = FLAG_PREFIX + 'unknown_flag_for_testing'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nINCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),\n                           re.sub('^--', '/', LIST_TESTS_FLAG),\n                           re.sub('_', '-', LIST_TESTS_FLAG)]\nINTERNAL_FLAG_FOR_TESTING = FLAG_PREFIX + 'internal_flag_for_testing'\nSUPPORTS_DEATH_TESTS = \"DeathTest\" in gtest_test_utils.Subprocess(\n    [PROGRAM_PATH, LIST_TESTS_FLAG]).output\n# The help message must match this regex.",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "UNKNOWN_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "UNKNOWN_FLAG = FLAG_PREFIX + 'unknown_flag_for_testing'\nLIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nINCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),\n                           re.sub('^--', '/', LIST_TESTS_FLAG),\n                           re.sub('_', '-', LIST_TESTS_FLAG)]\nINTERNAL_FLAG_FOR_TESTING = FLAG_PREFIX + 'internal_flag_for_testing'\nSUPPORTS_DEATH_TESTS = \"DeathTest\" in gtest_test_utils.Subprocess(\n    [PROGRAM_PATH, LIST_TESTS_FLAG]).output\n# The help message must match this regex.\nHELP_REGEX = re.compile(",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "LIST_TESTS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "LIST_TESTS_FLAG = FLAG_PREFIX + 'list_tests'\nINCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),\n                           re.sub('^--', '/', LIST_TESTS_FLAG),\n                           re.sub('_', '-', LIST_TESTS_FLAG)]\nINTERNAL_FLAG_FOR_TESTING = FLAG_PREFIX + 'internal_flag_for_testing'\nSUPPORTS_DEATH_TESTS = \"DeathTest\" in gtest_test_utils.Subprocess(\n    [PROGRAM_PATH, LIST_TESTS_FLAG]).output\n# The help message must match this regex.\nHELP_REGEX = re.compile(\n    FLAG_PREFIX + r'list_tests.*' +",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "INCORRECT_FLAG_VARIANTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "INCORRECT_FLAG_VARIANTS = [re.sub('^--', '-', LIST_TESTS_FLAG),\n                           re.sub('^--', '/', LIST_TESTS_FLAG),\n                           re.sub('_', '-', LIST_TESTS_FLAG)]\nINTERNAL_FLAG_FOR_TESTING = FLAG_PREFIX + 'internal_flag_for_testing'\nSUPPORTS_DEATH_TESTS = \"DeathTest\" in gtest_test_utils.Subprocess(\n    [PROGRAM_PATH, LIST_TESTS_FLAG]).output\n# The help message must match this regex.\nHELP_REGEX = re.compile(\n    FLAG_PREFIX + r'list_tests.*' +\n    FLAG_PREFIX + r'filter=.*' +",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "INTERNAL_FLAG_FOR_TESTING",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "INTERNAL_FLAG_FOR_TESTING = FLAG_PREFIX + 'internal_flag_for_testing'\nSUPPORTS_DEATH_TESTS = \"DeathTest\" in gtest_test_utils.Subprocess(\n    [PROGRAM_PATH, LIST_TESTS_FLAG]).output\n# The help message must match this regex.\nHELP_REGEX = re.compile(\n    FLAG_PREFIX + r'list_tests.*' +\n    FLAG_PREFIX + r'filter=.*' +\n    FLAG_PREFIX + r'also_run_disabled_tests.*' +\n    FLAG_PREFIX + r'repeat=.*' +\n    FLAG_PREFIX + r'shuffle.*' +",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_DEATH_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "SUPPORTS_DEATH_TESTS = \"DeathTest\" in gtest_test_utils.Subprocess(\n    [PROGRAM_PATH, LIST_TESTS_FLAG]).output\n# The help message must match this regex.\nHELP_REGEX = re.compile(\n    FLAG_PREFIX + r'list_tests.*' +\n    FLAG_PREFIX + r'filter=.*' +\n    FLAG_PREFIX + r'also_run_disabled_tests.*' +\n    FLAG_PREFIX + r'repeat=.*' +\n    FLAG_PREFIX + r'shuffle.*' +\n    FLAG_PREFIX + r'random_seed=.*' +",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "HELP_REGEX",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_help_test",
        "description": "third-party.googletest.googletest.test.gtest_help_test",
        "peekOfCode": "HELP_REGEX = re.compile(\n    FLAG_PREFIX + r'list_tests.*' +\n    FLAG_PREFIX + r'filter=.*' +\n    FLAG_PREFIX + r'also_run_disabled_tests.*' +\n    FLAG_PREFIX + r'repeat=.*' +\n    FLAG_PREFIX + r'shuffle.*' +\n    FLAG_PREFIX + r'random_seed=.*' +\n    FLAG_PREFIX + r'color=.*' +\n    FLAG_PREFIX + r'brief.*' +\n    FLAG_PREFIX + r'print_time.*' +",
        "detail": "third-party.googletest.googletest.test.gtest_help_test",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_json_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_json_test_utils",
        "peekOfCode": "def normalize(obj):\n  \"\"\"Normalize output object.\n  Args:\n     obj: Google Test's JSON output object to normalize.\n  Returns:\n     Normalized output without any references to transient information that may\n     change from run to run.\n  \"\"\"\n  def _normalize(key, value):\n    if key == 'time':",
        "detail": "third-party.googletest.googletest.test.gtest_json_test_utils",
        "documentation": {}
    },
    {
        "label": "GTestListTestsOutputUnitTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "peekOfCode": "class GTestListTestsOutputUnitTest(gtest_test_utils.TestCase):\n  \"\"\"Unit test for Google Test's list tests with output to file functionality.\n  \"\"\"\n  def testXml(self):\n    \"\"\"Verifies XML output for listing tests in a Google Test binary.\n    Runs a test program that generates an empty XML output, and\n    tests that the XML output is expected.\n    \"\"\"\n    self._TestOutput('xml', EXPECTED_XML)\n  def testJSON(self):",
        "detail": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_LIST_TESTS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "peekOfCode": "GTEST_LIST_TESTS_FLAG = '--gtest_list_tests'\nGTEST_OUTPUT_FLAG = '--gtest_output'\nEXPECTED_XML = \"\"\"<\\?xml version=\"1.0\" encoding=\"UTF-8\"\\?>\n<testsuites tests=\"16\" name=\"AllTests\">\n  <testsuite name=\"FooTest\" tests=\"2\">\n    <testcase name=\"Test1\" file=\".*gtest_list_output_unittest_.cc\" line=\"43\" />\n    <testcase name=\"Test2\" file=\".*gtest_list_output_unittest_.cc\" line=\"45\" />\n  </testsuite>\n  <testsuite name=\"FooTestFixture\" tests=\"2\">\n    <testcase name=\"Test3\" file=\".*gtest_list_output_unittest_.cc\" line=\"48\" />",
        "detail": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "peekOfCode": "GTEST_OUTPUT_FLAG = '--gtest_output'\nEXPECTED_XML = \"\"\"<\\?xml version=\"1.0\" encoding=\"UTF-8\"\\?>\n<testsuites tests=\"16\" name=\"AllTests\">\n  <testsuite name=\"FooTest\" tests=\"2\">\n    <testcase name=\"Test1\" file=\".*gtest_list_output_unittest_.cc\" line=\"43\" />\n    <testcase name=\"Test2\" file=\".*gtest_list_output_unittest_.cc\" line=\"45\" />\n  </testsuite>\n  <testsuite name=\"FooTestFixture\" tests=\"2\">\n    <testcase name=\"Test3\" file=\".*gtest_list_output_unittest_.cc\" line=\"48\" />\n    <testcase name=\"Test4\" file=\".*gtest_list_output_unittest_.cc\" line=\"49\" />",
        "detail": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_XML",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "peekOfCode": "EXPECTED_XML = \"\"\"<\\?xml version=\"1.0\" encoding=\"UTF-8\"\\?>\n<testsuites tests=\"16\" name=\"AllTests\">\n  <testsuite name=\"FooTest\" tests=\"2\">\n    <testcase name=\"Test1\" file=\".*gtest_list_output_unittest_.cc\" line=\"43\" />\n    <testcase name=\"Test2\" file=\".*gtest_list_output_unittest_.cc\" line=\"45\" />\n  </testsuite>\n  <testsuite name=\"FooTestFixture\" tests=\"2\">\n    <testcase name=\"Test3\" file=\".*gtest_list_output_unittest_.cc\" line=\"48\" />\n    <testcase name=\"Test4\" file=\".*gtest_list_output_unittest_.cc\" line=\"49\" />\n  </testsuite>",
        "detail": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_JSON",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "peekOfCode": "EXPECTED_JSON = \"\"\"{\n  \"tests\": 16,\n  \"name\": \"AllTests\",\n  \"testsuites\": \\[\n    {\n      \"name\": \"FooTest\",\n      \"tests\": 2,\n      \"testsuite\": \\[\n        {\n          \"name\": \"Test1\",",
        "detail": "third-party.googletest.googletest.test.gtest_list_output_unittest",
        "documentation": {}
    },
    {
        "label": "SkipEntireEnvironmentTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.gtest_skip_check_output_test",
        "description": "third-party.googletest.googletest.test.gtest_skip_check_output_test",
        "peekOfCode": "class SkipEntireEnvironmentTest(gtest_test_utils.TestCase):\n  def testSkipEntireEnvironmentTest(self):\n    self.assertIn('Skipped\\nskipping single test\\n', OUTPUT)\n    skip_fixture = 'Skipped\\nskipping all tests for this fixture\\n'\n    self.assertIsNotNone(\n        re.search(skip_fixture + '.*' + skip_fixture, OUTPUT, flags=re.DOTALL),\n        repr(OUTPUT))\n    self.assertNotIn('FAILED', OUTPUT)\nif __name__ == '__main__':\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googletest.test.gtest_skip_check_output_test",
        "documentation": {}
    },
    {
        "label": "EXE_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_skip_check_output_test",
        "description": "third-party.googletest.googletest.test.gtest_skip_check_output_test",
        "peekOfCode": "EXE_PATH = gtest_test_utils.GetTestExecutablePath('gtest_skip_test')\nOUTPUT = gtest_test_utils.Subprocess([EXE_PATH]).output\n# Test.\nclass SkipEntireEnvironmentTest(gtest_test_utils.TestCase):\n  def testSkipEntireEnvironmentTest(self):\n    self.assertIn('Skipped\\nskipping single test\\n', OUTPUT)\n    skip_fixture = 'Skipped\\nskipping all tests for this fixture\\n'\n    self.assertIsNotNone(\n        re.search(skip_fixture + '.*' + skip_fixture, OUTPUT, flags=re.DOTALL),\n        repr(OUTPUT))",
        "detail": "third-party.googletest.googletest.test.gtest_skip_check_output_test",
        "documentation": {}
    },
    {
        "label": "OUTPUT",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_skip_check_output_test",
        "description": "third-party.googletest.googletest.test.gtest_skip_check_output_test",
        "peekOfCode": "OUTPUT = gtest_test_utils.Subprocess([EXE_PATH]).output\n# Test.\nclass SkipEntireEnvironmentTest(gtest_test_utils.TestCase):\n  def testSkipEntireEnvironmentTest(self):\n    self.assertIn('Skipped\\nskipping single test\\n', OUTPUT)\n    skip_fixture = 'Skipped\\nskipping all tests for this fixture\\n'\n    self.assertIsNotNone(\n        re.search(skip_fixture + '.*' + skip_fixture, OUTPUT, flags=re.DOTALL),\n        repr(OUTPUT))\n    self.assertNotIn('FAILED', OUTPUT)",
        "detail": "third-party.googletest.googletest.test.gtest_skip_check_output_test",
        "documentation": {}
    },
    {
        "label": "SkipEntireEnvironmentTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.gtest_skip_environment_check_output_test",
        "description": "third-party.googletest.googletest.test.gtest_skip_environment_check_output_test",
        "peekOfCode": "class SkipEntireEnvironmentTest(gtest_test_utils.TestCase):\n  def testSkipEntireEnvironmentTest(self):\n    self.assertIn('Skipping the entire environment', OUTPUT)\n    self.assertNotIn('FAILED', OUTPUT)\nif __name__ == '__main__':\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googletest.test.gtest_skip_environment_check_output_test",
        "documentation": {}
    },
    {
        "label": "EXE_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_skip_environment_check_output_test",
        "description": "third-party.googletest.googletest.test.gtest_skip_environment_check_output_test",
        "peekOfCode": "EXE_PATH = gtest_test_utils.GetTestExecutablePath(\n    'gtest_skip_in_environment_setup_test')\nOUTPUT = gtest_test_utils.Subprocess([EXE_PATH]).output\n# Test.\nclass SkipEntireEnvironmentTest(gtest_test_utils.TestCase):\n  def testSkipEntireEnvironmentTest(self):\n    self.assertIn('Skipping the entire environment', OUTPUT)\n    self.assertNotIn('FAILED', OUTPUT)\nif __name__ == '__main__':\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googletest.test.gtest_skip_environment_check_output_test",
        "documentation": {}
    },
    {
        "label": "OUTPUT",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_skip_environment_check_output_test",
        "description": "third-party.googletest.googletest.test.gtest_skip_environment_check_output_test",
        "peekOfCode": "OUTPUT = gtest_test_utils.Subprocess([EXE_PATH]).output\n# Test.\nclass SkipEntireEnvironmentTest(gtest_test_utils.TestCase):\n  def testSkipEntireEnvironmentTest(self):\n    self.assertIn('Skipping the entire environment', OUTPUT)\n    self.assertNotIn('FAILED', OUTPUT)\nif __name__ == '__main__':\n  gtest_test_utils.Main()",
        "detail": "third-party.googletest.googletest.test.gtest_skip_environment_check_output_test",
        "documentation": {}
    },
    {
        "label": "GTestTestFilterTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "description": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "peekOfCode": "class GTestTestFilterTest(gtest_test_utils.TestCase):\n  def testTestExecutionIsFiltered(self):\n    \"\"\"Tests that the test filter is picked up from the testbridge env var.\"\"\"\n    subprocess_env = os.environ.copy()\n    subprocess_env[TESTBRIDGE_NAME] = '*.TestThatSucceeds'\n    p = gtest_test_utils.Subprocess(COMMAND, env=subprocess_env)\n    self.assertEquals(0, p.exit_code)\n    Assert('filter = *.TestThatSucceeds' in p.output)\n    Assert('[       OK ] TestFilterTest.TestThatSucceeds' in p.output)\n    Assert('[  PASSED  ] 1 test.' in p.output)",
        "detail": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "documentation": {}
    },
    {
        "label": "Assert",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "description": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "peekOfCode": "def Assert(condition):\n  if not condition:\n    raise AssertionError\nclass GTestTestFilterTest(gtest_test_utils.TestCase):\n  def testTestExecutionIsFiltered(self):\n    \"\"\"Tests that the test filter is picked up from the testbridge env var.\"\"\"\n    subprocess_env = os.environ.copy()\n    subprocess_env[TESTBRIDGE_NAME] = '*.TestThatSucceeds'\n    p = gtest_test_utils.Subprocess(COMMAND, env=subprocess_env)\n    self.assertEquals(0, p.exit_code)",
        "detail": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "documentation": {}
    },
    {
        "label": "binary_name",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "description": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "peekOfCode": "binary_name = 'gtest_testbridge_test_'\nCOMMAND = gtest_test_utils.GetTestExecutablePath(binary_name)\nTESTBRIDGE_NAME = 'TESTBRIDGE_TEST_ONLY'\ndef Assert(condition):\n  if not condition:\n    raise AssertionError\nclass GTestTestFilterTest(gtest_test_utils.TestCase):\n  def testTestExecutionIsFiltered(self):\n    \"\"\"Tests that the test filter is picked up from the testbridge env var.\"\"\"\n    subprocess_env = os.environ.copy()",
        "detail": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "documentation": {}
    },
    {
        "label": "COMMAND",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "description": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "peekOfCode": "COMMAND = gtest_test_utils.GetTestExecutablePath(binary_name)\nTESTBRIDGE_NAME = 'TESTBRIDGE_TEST_ONLY'\ndef Assert(condition):\n  if not condition:\n    raise AssertionError\nclass GTestTestFilterTest(gtest_test_utils.TestCase):\n  def testTestExecutionIsFiltered(self):\n    \"\"\"Tests that the test filter is picked up from the testbridge env var.\"\"\"\n    subprocess_env = os.environ.copy()\n    subprocess_env[TESTBRIDGE_NAME] = '*.TestThatSucceeds'",
        "detail": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "documentation": {}
    },
    {
        "label": "TESTBRIDGE_NAME",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "description": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "peekOfCode": "TESTBRIDGE_NAME = 'TESTBRIDGE_TEST_ONLY'\ndef Assert(condition):\n  if not condition:\n    raise AssertionError\nclass GTestTestFilterTest(gtest_test_utils.TestCase):\n  def testTestExecutionIsFiltered(self):\n    \"\"\"Tests that the test filter is picked up from the testbridge env var.\"\"\"\n    subprocess_env = os.environ.copy()\n    subprocess_env[TESTBRIDGE_NAME] = '*.TestThatSucceeds'\n    p = gtest_test_utils.Subprocess(COMMAND, env=subprocess_env)",
        "detail": "third-party.googletest.googletest.test.gtest_testbridge_test",
        "documentation": {}
    },
    {
        "label": "Subprocess",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "class Subprocess:\n  def __init__(self, command, working_dir=None, capture_stderr=True, env=None):\n    \"\"\"Changes into a specified directory, if provided, and executes a command.\n    Restores the old directory afterwards.\n    Args:\n      command:        The command to run, in the form of sys.argv.\n      working_dir:    The directory to change into.\n      capture_stderr: Determines whether to capture stderr in the output member\n                      or to discard it.\n      env:            Dictionary with environment to pass to the subprocess.",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "SetEnvVar",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "def SetEnvVar(env_var, value):\n  \"\"\"Sets/unsets an environment variable to a given value.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]\n# Here we expose a class from a particular module, depending on the\n# environment. The comment suppresses the 'Invalid variable name' lint\n# complaint.\nTestCase = _test_module.TestCase  # pylint: disable=C6409",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "GetFlag",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "def GetFlag(flag):\n  \"\"\"Returns the value of the given flag.\"\"\"\n  # In case GetFlag() is called before Main(), we always call\n  # _ParseAndStripGTestFlags() here to make sure the --gtest_* flags\n  # are parsed.\n  _ParseAndStripGTestFlags(sys.argv)\n  return _flag_map[flag]\ndef GetSourceDir():\n  \"\"\"Returns the absolute path of the directory where the .py files are.\"\"\"\n  return os.path.abspath(GetFlag('source_dir'))",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "GetSourceDir",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "def GetSourceDir():\n  \"\"\"Returns the absolute path of the directory where the .py files are.\"\"\"\n  return os.path.abspath(GetFlag('source_dir'))\ndef GetBuildDir():\n  \"\"\"Returns the absolute path of the directory where the test binaries are.\"\"\"\n  return os.path.abspath(GetFlag('build_dir'))\n_temp_dir = None\ndef _RemoveTempDir():\n  if _temp_dir:\n    shutil.rmtree(_temp_dir, ignore_errors=True)",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "GetBuildDir",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "def GetBuildDir():\n  \"\"\"Returns the absolute path of the directory where the test binaries are.\"\"\"\n  return os.path.abspath(GetFlag('build_dir'))\n_temp_dir = None\ndef _RemoveTempDir():\n  if _temp_dir:\n    shutil.rmtree(_temp_dir, ignore_errors=True)\natexit.register(_RemoveTempDir)\ndef GetTempDir():\n  global _temp_dir",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "GetTempDir",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "def GetTempDir():\n  global _temp_dir\n  if not _temp_dir:\n    _temp_dir = tempfile.mkdtemp()\n  return _temp_dir\ndef GetTestExecutablePath(executable_name, build_dir=None):\n  \"\"\"Returns the absolute path of the test binary given its name.\n  The function will print a message and abort the program if the resulting file\n  doesn't exist.\n  Args:",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "GetTestExecutablePath",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "def GetTestExecutablePath(executable_name, build_dir=None):\n  \"\"\"Returns the absolute path of the test binary given its name.\n  The function will print a message and abort the program if the resulting file\n  doesn't exist.\n  Args:\n    executable_name: name of the test binary that the test script runs.\n    build_dir:       directory where to look for executables, by default\n                     the result of GetBuildDir().\n  Returns:\n    The absolute path of the test binary.",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "GetExitStatus",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "def GetExitStatus(exit_code):\n  \"\"\"Returns the argument to exit(), or -1 if exit() wasn't called.\n  Args:\n    exit_code: the result value of os.system(command).\n  \"\"\"\n  if os.name == 'nt':\n    # On Windows, os.WEXITSTATUS() doesn't work and os.system() returns\n    # the argument to exit() directly.\n    return exit_code\n  else:",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "Main",
        "kind": 2,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "def Main():\n  \"\"\"Runs the unit test.\"\"\"\n  # We must call _ParseAndStripGTestFlags() before calling\n  # unittest.main().  Otherwise the latter will be confused by the\n  # --gtest_* flags.\n  _ParseAndStripGTestFlags(sys.argv)\n  # The tested binaries should not be writing XML output files unless the\n  # script explicitly instructs them to.\n  if GTEST_OUTPUT_VAR_NAME in os.environ:\n    del os.environ[GTEST_OUTPUT_VAR_NAME]",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "IS_WINDOWS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "IS_WINDOWS = os.name == 'nt'\nIS_CYGWIN = os.name == 'posix' and 'CYGWIN' in os.uname()[0]\nIS_OS2 = os.name == 'os2'\nimport atexit\nimport shutil\nimport tempfile\nimport unittest as _test_module\n# pylint: enable-msg=C6204\nGTEST_OUTPUT_VAR_NAME = 'GTEST_OUTPUT'\n# The environment variable for specifying the path to the premature-exit file.",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "IS_CYGWIN",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "IS_CYGWIN = os.name == 'posix' and 'CYGWIN' in os.uname()[0]\nIS_OS2 = os.name == 'os2'\nimport atexit\nimport shutil\nimport tempfile\nimport unittest as _test_module\n# pylint: enable-msg=C6204\nGTEST_OUTPUT_VAR_NAME = 'GTEST_OUTPUT'\n# The environment variable for specifying the path to the premature-exit file.\nPREMATURE_EXIT_FILE_ENV_VAR = 'TEST_PREMATURE_EXIT_FILE'",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "IS_OS2",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "IS_OS2 = os.name == 'os2'\nimport atexit\nimport shutil\nimport tempfile\nimport unittest as _test_module\n# pylint: enable-msg=C6204\nGTEST_OUTPUT_VAR_NAME = 'GTEST_OUTPUT'\n# The environment variable for specifying the path to the premature-exit file.\nPREMATURE_EXIT_FILE_ENV_VAR = 'TEST_PREMATURE_EXIT_FILE'\nenviron = os.environ.copy()",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_VAR_NAME",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "GTEST_OUTPUT_VAR_NAME = 'GTEST_OUTPUT'\n# The environment variable for specifying the path to the premature-exit file.\nPREMATURE_EXIT_FILE_ENV_VAR = 'TEST_PREMATURE_EXIT_FILE'\nenviron = os.environ.copy()\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets/unsets an environment variable to a given value.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "PREMATURE_EXIT_FILE_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "PREMATURE_EXIT_FILE_ENV_VAR = 'TEST_PREMATURE_EXIT_FILE'\nenviron = os.environ.copy()\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets/unsets an environment variable to a given value.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]\n# Here we expose a class from a particular module, depending on the\n# environment. The comment suppresses the 'Invalid variable name' lint",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "environ",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "environ = os.environ.copy()\ndef SetEnvVar(env_var, value):\n  \"\"\"Sets/unsets an environment variable to a given value.\"\"\"\n  if value is not None:\n    environ[env_var] = value\n  elif env_var in environ:\n    del environ[env_var]\n# Here we expose a class from a particular module, depending on the\n# environment. The comment suppresses the 'Invalid variable name' lint\n# complaint.",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "TestCase = _test_module.TestCase  # pylint: disable=C6409\n# Initially maps a flag to its default value. After\n# _ParseAndStripGTestFlags() is called, maps a flag to its actual value.\n_flag_map = {'source_dir': os.path.dirname(sys.argv[0]),\n             'build_dir': os.path.dirname(sys.argv[0])}\n_gtest_flags_are_parsed = False\ndef _ParseAndStripGTestFlags(argv):\n  \"\"\"Parses and strips Google Test flags from argv.  This is idempotent.\"\"\"\n  # Suppresses the lint complaint about a global variable since we need it\n  # here to maintain module-wide state.",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "_flag_map",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "_flag_map = {'source_dir': os.path.dirname(sys.argv[0]),\n             'build_dir': os.path.dirname(sys.argv[0])}\n_gtest_flags_are_parsed = False\ndef _ParseAndStripGTestFlags(argv):\n  \"\"\"Parses and strips Google Test flags from argv.  This is idempotent.\"\"\"\n  # Suppresses the lint complaint about a global variable since we need it\n  # here to maintain module-wide state.\n  global _gtest_flags_are_parsed  # pylint: disable=W0603\n  if _gtest_flags_are_parsed:\n    return",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "_gtest_flags_are_parsed",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "_gtest_flags_are_parsed = False\ndef _ParseAndStripGTestFlags(argv):\n  \"\"\"Parses and strips Google Test flags from argv.  This is idempotent.\"\"\"\n  # Suppresses the lint complaint about a global variable since we need it\n  # here to maintain module-wide state.\n  global _gtest_flags_are_parsed  # pylint: disable=W0603\n  if _gtest_flags_are_parsed:\n    return\n  _gtest_flags_are_parsed = True\n  for flag in _flag_map:",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "_temp_dir",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_test_utils",
        "peekOfCode": "_temp_dir = None\ndef _RemoveTempDir():\n  if _temp_dir:\n    shutil.rmtree(_temp_dir, ignore_errors=True)\natexit.register(_RemoveTempDir)\ndef GetTempDir():\n  global _temp_dir\n  if not _temp_dir:\n    _temp_dir = tempfile.mkdtemp()\n  return _temp_dir",
        "detail": "third-party.googletest.googletest.test.gtest_test_utils",
        "documentation": {}
    },
    {
        "label": "GTestXMLOutFilesTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "description": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "peekOfCode": "class GTestXMLOutFilesTest(gtest_xml_test_utils.GTestXMLTestCase):\n  \"\"\"Unit test for Google Test's XML output functionality.\"\"\"\n  def setUp(self):\n    # We want the trailing '/' that the last \"\" provides in os.path.join, for\n    # telling Google Test to create an output directory instead of a single file\n    # for xml output.\n    self.output_dir_ = os.path.join(gtest_test_utils.GetTempDir(),\n                                    GTEST_OUTPUT_SUBDIR, \"\")\n    self.DeleteFilesAndDir()\n  def tearDown(self):",
        "detail": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_SUBDIR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "description": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "peekOfCode": "GTEST_OUTPUT_SUBDIR = \"xml_outfiles\"\nGTEST_OUTPUT_1_TEST = \"gtest_xml_outfile1_test_\"\nGTEST_OUTPUT_2_TEST = \"gtest_xml_outfile2_test_\"\nEXPECTED_XML_1 = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"1\" failures=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\">\n  <testsuite name=\"PropertyOne\" tests=\"1\" failures=\"0\" skipped=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"TestSomeProperties\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"PropertyOne\">\n      <properties>\n        <property name=\"SetUpProp\" value=\"1\"/>\n        <property name=\"TestSomeProperty\" value=\"1\"/>",
        "detail": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_1_TEST",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "description": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "peekOfCode": "GTEST_OUTPUT_1_TEST = \"gtest_xml_outfile1_test_\"\nGTEST_OUTPUT_2_TEST = \"gtest_xml_outfile2_test_\"\nEXPECTED_XML_1 = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"1\" failures=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\">\n  <testsuite name=\"PropertyOne\" tests=\"1\" failures=\"0\" skipped=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"TestSomeProperties\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"PropertyOne\">\n      <properties>\n        <property name=\"SetUpProp\" value=\"1\"/>\n        <property name=\"TestSomeProperty\" value=\"1\"/>\n        <property name=\"TearDownProp\" value=\"1\"/>",
        "detail": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_2_TEST",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "description": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "peekOfCode": "GTEST_OUTPUT_2_TEST = \"gtest_xml_outfile2_test_\"\nEXPECTED_XML_1 = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"1\" failures=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\">\n  <testsuite name=\"PropertyOne\" tests=\"1\" failures=\"0\" skipped=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"TestSomeProperties\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"PropertyOne\">\n      <properties>\n        <property name=\"SetUpProp\" value=\"1\"/>\n        <property name=\"TestSomeProperty\" value=\"1\"/>\n        <property name=\"TearDownProp\" value=\"1\"/>\n      </properties>",
        "detail": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "documentation": {}
    },
    {
        "label": "EXPECTED_XML_1",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "description": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "peekOfCode": "EXPECTED_XML_1 = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"1\" failures=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\">\n  <testsuite name=\"PropertyOne\" tests=\"1\" failures=\"0\" skipped=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"TestSomeProperties\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"PropertyOne\">\n      <properties>\n        <property name=\"SetUpProp\" value=\"1\"/>\n        <property name=\"TestSomeProperty\" value=\"1\"/>\n        <property name=\"TearDownProp\" value=\"1\"/>\n      </properties>\n    </testcase>",
        "detail": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "documentation": {}
    },
    {
        "label": "EXPECTED_XML_2",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "description": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "peekOfCode": "EXPECTED_XML_2 = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"1\" failures=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\">\n  <testsuite name=\"PropertyTwo\" tests=\"1\" failures=\"0\" skipped=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"TestSomeProperties\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"PropertyTwo\">\n      <properties>\n        <property name=\"SetUpProp\" value=\"2\"/>\n        <property name=\"TestSomeProperty\" value=\"2\"/>\n        <property name=\"TearDownProp\" value=\"2\"/>\n      </properties>\n    </testcase>",
        "detail": "third-party.googletest.googletest.test.gtest_xml_outfiles_test",
        "documentation": {}
    },
    {
        "label": "GTestXMLOutputUnitTest",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "class GTestXMLOutputUnitTest(gtest_xml_test_utils.GTestXMLTestCase):\n  \"\"\"\n  Unit test for Google Test's XML output functionality.\n  \"\"\"\n  # This test currently breaks on platforms that do not support typed and\n  # type-parameterized tests, so we don't run it under them.\n  if SUPPORTS_TYPED_TESTS:\n    def testNonEmptyXmlOutput(self):\n      \"\"\"\n      Runs a test program that generates a non-empty XML output, and",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_FILTER_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "GTEST_FILTER_FLAG = '--gtest_filter'\nGTEST_LIST_TESTS_FLAG = '--gtest_list_tests'\nGTEST_OUTPUT_FLAG = '--gtest_output'\nGTEST_DEFAULT_OUTPUT_FILE = 'test_detail.xml'\nGTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\n# The environment variables for test sharding.\nTOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_LIST_TESTS_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "GTEST_LIST_TESTS_FLAG = '--gtest_list_tests'\nGTEST_OUTPUT_FLAG = '--gtest_output'\nGTEST_DEFAULT_OUTPUT_FILE = 'test_detail.xml'\nGTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\n# The environment variables for test sharding.\nTOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_OUTPUT_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "GTEST_OUTPUT_FLAG = '--gtest_output'\nGTEST_DEFAULT_OUTPUT_FILE = 'test_detail.xml'\nGTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\n# The environment variables for test sharding.\nTOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_DEFAULT_OUTPUT_FILE",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "GTEST_DEFAULT_OUTPUT_FILE = 'test_detail.xml'\nGTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\n# The environment variables for test sharding.\nTOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_PROGRAM_NAME",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "GTEST_PROGRAM_NAME = 'gtest_xml_output_unittest_'\n# The flag indicating stacktraces are not supported\nNO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\n# The environment variables for test sharding.\nTOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "NO_STACKTRACE_SUPPORT_FLAG",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "NO_STACKTRACE_SUPPORT_FLAG = '--no_stacktrace_support'\n# The environment variables for test sharding.\nTOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "TOTAL_SHARDS_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "TOTAL_SHARDS_ENV_VAR = 'GTEST_TOTAL_SHARDS'\nSHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''\n  # unittest.main() can't handle unknown flags\n  sys.argv.remove(NO_STACKTRACE_SUPPORT_FLAG)",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "SHARD_INDEX_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "SHARD_INDEX_ENV_VAR = 'GTEST_SHARD_INDEX'\nSHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''\n  # unittest.main() can't handle unknown flags\n  sys.argv.remove(NO_STACKTRACE_SUPPORT_FLAG)\nEXPECTED_NON_EMPTY_XML = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "SHARD_STATUS_FILE_ENV_VAR",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "SHARD_STATUS_FILE_ENV_VAR = 'GTEST_SHARD_STATUS_FILE'\nSUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''\n  # unittest.main() can't handle unknown flags\n  sys.argv.remove(NO_STACKTRACE_SUPPORT_FLAG)\nEXPECTED_NON_EMPTY_XML = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"26\" failures=\"5\" disabled=\"2\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\" ad_hoc_property=\"42\">",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_STACK_TRACES",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "SUPPORTS_STACK_TRACES = NO_STACKTRACE_SUPPORT_FLAG not in sys.argv\nif SUPPORTS_STACK_TRACES:\n  STACK_TRACE_TEMPLATE = '\\nStack trace:\\n*'\nelse:\n  STACK_TRACE_TEMPLATE = ''\n  # unittest.main() can't handle unknown flags\n  sys.argv.remove(NO_STACKTRACE_SUPPORT_FLAG)\nEXPECTED_NON_EMPTY_XML = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"26\" failures=\"5\" disabled=\"2\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\" ad_hoc_property=\"42\">\n  <testsuite name=\"SuccessfulTest\" tests=\"1\" failures=\"0\" disabled=\"0\" skipped=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_NON_EMPTY_XML",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "EXPECTED_NON_EMPTY_XML = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"26\" failures=\"5\" disabled=\"2\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\" ad_hoc_property=\"42\">\n  <testsuite name=\"SuccessfulTest\" tests=\"1\" failures=\"0\" disabled=\"0\" skipped=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"Succeeds\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"SuccessfulTest\"/>\n  </testsuite>\n  <testsuite name=\"FailedTest\" tests=\"1\" failures=\"1\" disabled=\"0\" skipped=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"Fails\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"FailedTest\">\n      <failure message=\"gtest_xml_output_unittest_.cc:*&#x0A;Expected equality of these values:&#x0A;  1&#x0A;  2\" type=\"\"><![CDATA[gtest_xml_output_unittest_.cc:*\nExpected equality of these values:\n  1",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_FILTERED_TEST_XML",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "EXPECTED_FILTERED_TEST_XML = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"1\" failures=\"0\" disabled=\"0\" errors=\"0\" time=\"*\"\n            timestamp=\"*\" name=\"AllTests\" ad_hoc_property=\"42\">\n  <testsuite name=\"SuccessfulTest\" tests=\"1\" failures=\"0\" disabled=\"0\" skipped=\"0\"\n             errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"Succeeds\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"SuccessfulTest\"/>\n  </testsuite>\n</testsuites>\"\"\"\nEXPECTED_SHARDED_TEST_XML = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"3\" failures=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\" ad_hoc_property=\"42\">",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_SHARDED_TEST_XML",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "EXPECTED_SHARDED_TEST_XML = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"3\" failures=\"0\" disabled=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\" name=\"AllTests\" ad_hoc_property=\"42\">\n  <testsuite name=\"SuccessfulTest\" tests=\"1\" failures=\"0\" disabled=\"0\" skipped=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"Succeeds\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"SuccessfulTest\"/>\n  </testsuite>\n  <testsuite name=\"PropertyRecordingTest\" tests=\"1\" failures=\"0\" disabled=\"0\" skipped=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\" SetUpTestSuite=\"yes\" TearDownTestSuite=\"aye\">\n    <testcase name=\"IntValuedProperty\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"PropertyRecordingTest\">\n      <properties>\n        <property name=\"key_int\" value=\"1\"/>\n      </properties>",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "EXPECTED_NO_TEST_XML",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "EXPECTED_NO_TEST_XML = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"0\" failures=\"0\" disabled=\"0\" errors=\"0\" time=\"*\"\n            timestamp=\"*\" name=\"AllTests\">\n  <testsuite name=\"NonTestSuiteFailure\" tests=\"1\" failures=\"1\" disabled=\"0\" skipped=\"0\" errors=\"0\" time=\"*\" timestamp=\"*\">\n    <testcase name=\"\" status=\"run\" result=\"completed\" time=\"*\" timestamp=\"*\" classname=\"\">\n      <failure message=\"gtest_no_test_unittest.cc:*&#x0A;Expected equality of these values:&#x0A;  1&#x0A;  2\" type=\"\"><![CDATA[gtest_no_test_unittest.cc:*\nExpected equality of these values:\n  1\n  2%(stack)s]]></failure>\n    </testcase>",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "GTEST_PROGRAM_PATH",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "GTEST_PROGRAM_PATH = gtest_test_utils.GetTestExecutablePath(GTEST_PROGRAM_NAME)\nSUPPORTS_TYPED_TESTS = 'TypedTest' in gtest_test_utils.Subprocess(\n    [GTEST_PROGRAM_PATH, GTEST_LIST_TESTS_FLAG], capture_stderr=False).output\nclass GTestXMLOutputUnitTest(gtest_xml_test_utils.GTestXMLTestCase):\n  \"\"\"\n  Unit test for Google Test's XML output functionality.\n  \"\"\"\n  # This test currently breaks on platforms that do not support typed and\n  # type-parameterized tests, so we don't run it under them.\n  if SUPPORTS_TYPED_TESTS:",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "SUPPORTS_TYPED_TESTS",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "description": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "peekOfCode": "SUPPORTS_TYPED_TESTS = 'TypedTest' in gtest_test_utils.Subprocess(\n    [GTEST_PROGRAM_PATH, GTEST_LIST_TESTS_FLAG], capture_stderr=False).output\nclass GTestXMLOutputUnitTest(gtest_xml_test_utils.GTestXMLTestCase):\n  \"\"\"\n  Unit test for Google Test's XML output functionality.\n  \"\"\"\n  # This test currently breaks on platforms that do not support typed and\n  # type-parameterized tests, so we don't run it under them.\n  if SUPPORTS_TYPED_TESTS:\n    def testNonEmptyXmlOutput(self):",
        "detail": "third-party.googletest.googletest.test.gtest_xml_output_unittest",
        "documentation": {}
    },
    {
        "label": "GTestXMLTestCase",
        "kind": 6,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_xml_test_utils",
        "peekOfCode": "class GTestXMLTestCase(gtest_test_utils.TestCase):\n  \"\"\"\n  Base class for tests of Google Test's XML output functionality.\n  \"\"\"\n  def AssertEquivalentNodes(self, expected_node, actual_node):\n    \"\"\"\n    Asserts that actual_node (a DOM node object) is equivalent to\n    expected_node (another DOM node object), in that either both of\n    them are CDATA nodes and have the same value, or both are DOM\n    elements and actual_node meets all of the following conditions:",
        "detail": "third-party.googletest.googletest.test.gtest_xml_test_utils",
        "documentation": {}
    },
    {
        "label": "GTEST_DEFAULT_OUTPUT_FILE",
        "kind": 5,
        "importPath": "third-party.googletest.googletest.test.gtest_xml_test_utils",
        "description": "third-party.googletest.googletest.test.gtest_xml_test_utils",
        "peekOfCode": "GTEST_DEFAULT_OUTPUT_FILE = 'test_detail.xml'\nclass GTestXMLTestCase(gtest_test_utils.TestCase):\n  \"\"\"\n  Base class for tests of Google Test's XML output functionality.\n  \"\"\"\n  def AssertEquivalentNodes(self, expected_node, actual_node):\n    \"\"\"\n    Asserts that actual_node (a DOM node object) is equivalent to\n    expected_node (another DOM node object), in that either both of\n    them are CDATA nodes and have the same value, or both are DOM",
        "detail": "third-party.googletest.googletest.test.gtest_xml_test_utils",
        "documentation": {}
    },
    {
        "label": "SigintHandler",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "class SigintHandler(object):\n  class ProcessWasInterrupted(Exception):\n    pass\n  sigint_returncodes = {\n      -signal.SIGINT,  # Unix\n      -1073741510,  # Windows\n  }\n  def __init__(self):\n    self.__lock = threading.Lock()\n    self.__processes = set()",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "Outputter",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "class Outputter(object):\n  def __init__(self, out_file):\n    self.__out_file = out_file\n    self.__previous_line_was_transient = False\n    self.__width = term_width(out_file)  # Line width, or None if not a tty.\n  def transient_line(self, msg):\n    if self.__width is None:\n      self.__out_file.write(msg + \"\\n\")\n      self.__out_file.flush()\n    else:",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "class Task(object):\n  \"\"\"Stores information about a task (single execution of a test).\n  This class stores information about the test to be executed (gtest binary and\n  test name), and its result (log file, exit code and runtime).\n  Each task is uniquely identified by the gtest binary, the test name and an\n  execution number that increases each time the test is executed.\n  Additionaly we store the last execution time, so that next time the test is\n  executed, the slowest tests are run first.\n  \"\"\"\n  def __init__(self, test_binary, test_name, test_command, execution_number,",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "TaskManager",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "class TaskManager(object):\n  \"\"\"Executes the tasks and stores the passed, failed and interrupted tasks.\n  When a task is run, this class keeps track if it passed, failed or was\n  interrupted. After a task finishes it calls the relevant functions of the\n  Logger, TestResults and TestTimes classes, and in case of failure, retries the\n  test as specified by the --retry_failed flag.\n  \"\"\"\n  def __init__(self, times, logger, test_results, task_factory, times_to_retry,\n               initial_execution_number):\n    self.times = times",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "FilterFormat",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "class FilterFormat(object):\n  def __init__(self, output_dir):\n    if sys.stdout.isatty():\n      # stdout needs to be unbuffered since the output is interactive.\n      if isinstance(sys.stdout, io.TextIOWrapper):\n        # workaround for https://bugs.python.org/issue17404\n        sys.stdout = io.TextIOWrapper(sys.stdout.detach(),\n                                      line_buffering=True,\n                                      write_through=True,\n                                      newline='\\n')",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "CollectTestResults",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "class CollectTestResults(object):\n  def __init__(self, json_dump_filepath):\n    self.test_results_lock = threading.Lock()\n    self.json_dump_file = open(json_dump_filepath, 'w')\n    self.test_results = {\n        \"interrupted\": False,\n        \"path_delimiter\": \".\",\n        # Third version of the file format. See the link in the flag description\n        # for details.\n        \"version\": 3,",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "TestTimes",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "class TestTimes(object):\n  class LockedFile(object):\n    def __init__(self, filename, mode):\n      self._filename = filename\n      self._mode = mode\n      self._fo = None\n    def __enter__(self):\n      self._fo = open(self._filename, self._mode)\n      # Regardless of opening mode we always seek to the beginning of file.\n      # This simplifies code working with LockedFile and also ensures that",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "term_width",
        "kind": 2,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "def term_width(out):\n  if not out.isatty():\n    return None\n  try:\n    p = subprocess.Popen([\"stty\", \"size\"],\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE)\n    (out, err) = p.communicate()\n    if p.returncode != 0 or err:\n      return None",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "get_save_file_path",
        "kind": 2,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "def get_save_file_path():\n  \"\"\"Return path to file for saving transient data.\"\"\"\n  if sys.platform == 'win32':\n    default_cache_path = os.path.join(os.path.expanduser('~'), 'AppData',\n                                      'Local')\n    cache_path = os.environ.get('LOCALAPPDATA', default_cache_path)\n  else:\n    # We don't use xdg module since it's not a standard.\n    default_cache_path = os.path.join(os.path.expanduser('~'), '.cache')\n    cache_path = os.environ.get('XDG_CACHE_HOME', default_cache_path)",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "find_tests",
        "kind": 2,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "def find_tests(binaries, additional_args, options, times):\n  test_count = 0\n  tasks = []\n  for test_binary in binaries:\n    command = [test_binary] + additional_args\n    if options.gtest_also_run_disabled_tests:\n      command += ['--gtest_also_run_disabled_tests']\n    list_command = command + ['--gtest_list_tests']\n    if options.gtest_filter != '':\n      list_command += ['--gtest_filter=' + options.gtest_filter]",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "execute_tasks",
        "kind": 2,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "def execute_tasks(tasks, pool_size, task_manager, timeout_seconds,\n                  serialize_test_cases):\n  class WorkerFn(object):\n    def __init__(self, tasks, running_groups):\n      self.tasks = tasks\n      self.running_groups = running_groups\n      self.task_lock = threading.Lock()\n    def __call__(self):\n      while True:\n        with self.task_lock:",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "default_options_parser",
        "kind": 2,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "def default_options_parser():\n  parser = optparse.OptionParser(\n      usage='usage: %prog [options] binary [binary ...] -- [additional args]')\n  parser.add_option('-d',\n                    '--output_dir',\n                    type='string',\n                    default=None,\n                    help='Output directory for test logs. Logs will be '\n                    'available under gtest-parallel-logs/, so '\n                    '--output_dir=/tmp will results in all logs being '",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "def main():\n  # Remove additional arguments (anything after --).\n  additional_args = []\n  for i in range(len(sys.argv)):\n    if sys.argv[i] == '--':\n      additional_args = sys.argv[i + 1:]\n      sys.argv = sys.argv[:i]\n      break\n  parser = default_options_parser()\n  (options, binaries) = parser.parse_args()",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "sigint_handler",
        "kind": 5,
        "importPath": "third-party.gtest-parallel.gtest_parallel",
        "description": "third-party.gtest-parallel.gtest_parallel",
        "peekOfCode": "sigint_handler = SigintHandler()\n# Return the width of the terminal, or None if it couldn't be\n# determined (e.g. because we're not being run interactively).\ndef term_width(out):\n  if not out.isatty():\n    return None\n  try:\n    p = subprocess.Popen([\"stty\", \"size\"],\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE)",
        "detail": "third-party.gtest-parallel.gtest_parallel",
        "documentation": {}
    },
    {
        "label": "LoggerMock",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_mocks",
        "description": "third-party.gtest-parallel.gtest_parallel_mocks",
        "peekOfCode": "class LoggerMock(object):\n  def __init__(self, test_lib):\n    self.test_lib = test_lib\n    self.runtimes = collections.defaultdict(list)\n    self.exit_codes = collections.defaultdict(list)\n    self.last_execution_times = collections.defaultdict(list)\n    self.execution_numbers = collections.defaultdict(list)\n  def log_exit(self, task):\n    self.runtimes[task.test_id].append(task.runtime_ms)\n    self.exit_codes[task.test_id].append(task.exit_code)",
        "detail": "third-party.gtest-parallel.gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TestTimesMock",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_mocks",
        "description": "third-party.gtest-parallel.gtest_parallel_mocks",
        "peekOfCode": "class TestTimesMock(object):\n  def __init__(self, test_lib, test_data=None):\n    self.test_lib = test_lib\n    self.test_data = test_data or {}\n    self.last_execution_times = collections.defaultdict(list)\n  def record_test_time(self, test_binary, test_name, last_execution_time):\n    test_id = (test_binary, test_name)\n    self.last_execution_times[test_id].append(last_execution_time)\n  def get_test_time(self, test_binary, test_name):\n    test_group, test = test_name.split('.')",
        "detail": "third-party.gtest-parallel.gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TestResultsMock",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_mocks",
        "description": "third-party.gtest-parallel.gtest_parallel_mocks",
        "peekOfCode": "class TestResultsMock(object):\n  def __init__(self, test_lib):\n    self.results = []\n    self.test_lib = test_lib\n  def log(self, test_name, runtime_ms, actual_result):\n    self.results.append((test_name, runtime_ms, actual_result))\n  def assertRecorded(self, test_id, expected, retries):\n    test_results = [\n        (test_id[1], runtime_ms / 1000.0, exit_code)\n        for runtime_ms, exit_code in zip(expected['runtime_ms'][:retries],",
        "detail": "third-party.gtest-parallel.gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TaskManagerMock",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_mocks",
        "description": "third-party.gtest-parallel.gtest_parallel_mocks",
        "peekOfCode": "class TaskManagerMock(object):\n  def __init__(self):\n    self.running_groups = []\n    self.check_lock = threading.Lock()\n    self.had_running_parallel_groups = False\n    self.total_tasks_run = 0\n    self.started = {}\n  def __register_start(self, task):\n    self.started[task.task_id] = task\n  def register_exit(self, task):",
        "detail": "third-party.gtest-parallel.gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TaskMockFactory",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_mocks",
        "description": "third-party.gtest-parallel.gtest_parallel_mocks",
        "peekOfCode": "class TaskMockFactory(object):\n  def __init__(self, test_data):\n    self.data = test_data\n    self.passed = []\n    self.failed = []\n  def get_task(self, test_id, execution_number=0):\n    task = TaskMock(test_id, execution_number, self.data[test_id])\n    if task.exit_code == 0:\n      self.passed.append(task)\n    else:",
        "detail": "third-party.gtest-parallel.gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TaskMock",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_mocks",
        "description": "third-party.gtest-parallel.gtest_parallel_mocks",
        "peekOfCode": "class TaskMock(object):\n  def __init__(self, test_id, execution_number, test_data):\n    self.test_id = test_id\n    self.execution_number = execution_number\n    self.runtime_ms = test_data['runtime_ms'][execution_number]\n    self.exit_code = test_data['exit_code'][execution_number]\n    self.last_execution_time = (\n        test_data['last_execution_time'][execution_number])\n    if 'log_file' in test_data:\n      self.log_file = test_data['log_file'][execution_number]",
        "detail": "third-party.gtest-parallel.gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "SubprocessMock",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_mocks",
        "description": "third-party.gtest-parallel.gtest_parallel_mocks",
        "peekOfCode": "class SubprocessMock(object):\n  def __init__(self, test_data=None):\n    self._test_data = test_data\n    self.last_invocation = None\n  def __call__(self, command, **kwargs):\n    self.last_invocation = command\n    binary = command[0]\n    test_list = []\n    tests_for_binary = sorted(self._test_data.get(binary, {}).items())\n    for test_group, tests in tests_for_binary:",
        "detail": "third-party.gtest-parallel.gtest_parallel_mocks",
        "documentation": {}
    },
    {
        "label": "TestTaskManager",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "class TestTaskManager(unittest.TestCase):\n  def setUp(self):\n    self.passing_task = (('fake_binary', 'Fake.PassingTest'), {\n        'runtime_ms': [10],\n        'exit_code': [0],\n        'last_execution_time': [10],\n    })\n    self.failing_task = (('fake_binary', 'Fake.FailingTest'), {\n        'runtime_ms': [20, 30, 40],\n        'exit_code': [1, 1, 1],",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "TestSaveFilePath",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "class TestSaveFilePath(unittest.TestCase):\n  class StreamMock(object):\n    def write(*args):\n      # Suppress any output.\n      pass\n  def test_get_save_file_path_unix(self):\n    with guard_temp_dir() as temp_dir, \\\n        guard_patch_module('os.path.expanduser', lambda p: temp_dir), \\\n        guard_patch_module('sys.stderr', TestSaveFilePath.StreamMock()), \\\n        guard_patch_module('sys.platform', 'darwin'):",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "TestSerializeTestCases",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "class TestSerializeTestCases(unittest.TestCase):\n  def _execute_tasks(self, max_number_of_test_cases,\n                     max_number_of_tests_per_test_case, max_number_of_repeats,\n                     max_number_of_workers, serialize_test_cases):\n    tasks = []\n    for test_case in range(max_number_of_test_cases):\n      for test_name in range(max_number_of_tests_per_test_case):\n        # All arguments for gtest_parallel.Task except for test_name are fake.\n        test_name = 'TestCase{}.test{}'.format(test_case, test_name)\n        for execution_number in range(random.randint(1, max_number_of_repeats)):",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "TestTestTimes",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "class TestTestTimes(unittest.TestCase):\n  def test_race_in_test_times_load_save(self):\n    max_number_of_workers = 8\n    max_number_of_read_write_cycles = 64\n    test_times_file_name = 'test_times.pickle'\n    def start_worker(save_file):\n      def test_times_worker():\n        thread_id = threading.current_thread().ident\n        path_to_binary = 'path/to/binary' + hex(thread_id)\n        for cnt in range(max_number_of_read_write_cycles):",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "TestTimeoutTestCases",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "class TestTimeoutTestCases(unittest.TestCase):\n  def test_task_timeout(self):\n    timeout = 1\n    task = gtest_parallel.Task('test_binary', 'test_name', ['test_command'], 1,\n                               None, 'output_dir')\n    tasks = [task]\n    task_manager = TaskManagerMock()\n    gtest_parallel.execute_tasks(tasks, 1, task_manager, timeout, True)\n    self.assertEqual(1, task_manager.total_tasks_run)\n    self.assertEqual(None, task.exit_code)",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "TestTask",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "class TestTask(unittest.TestCase):\n  def test_log_file_names(self):\n    def root():\n      return 'C:\\\\' if sys.platform == 'win32' else '/'\n    self.assertEqual(os.path.join('.', 'bin-Test_case-100.log'),\n                     gtest_parallel.Task._logname('.', 'bin', 'Test.case', 100))\n    self.assertEqual(\n        os.path.join('..', 'a', 'b', 'bin-Test_case_2-1.log'),\n        gtest_parallel.Task._logname(os.path.join('..', 'a', 'b'),\n                                     os.path.join('..', 'bin'), 'Test.case/2',",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "TestFilterFormat",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "class TestFilterFormat(unittest.TestCase):\n  def _execute_test(self, test_body, drop_output):\n    class StdoutMock(object):\n      def isatty(*_args):\n        return False\n      def write(*args):\n        pass\n      def flush(*args):\n        pass\n    with guard_temp_dir() as temp_dir, \\",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "TestFindTests",
        "kind": 6,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "class TestFindTests(unittest.TestCase):\n  ONE_DISABLED_ONE_ENABLED_TEST = {\n      \"fake_unittests\": {\n          \"FakeTest\": {\n              \"Test1\": None,\n              \"DISABLED_Test2\": None,\n          }\n      }\n  }\n  ONE_FAILED_ONE_PASSED_TEST = {",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "guard_temp_dir",
        "kind": 2,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "def guard_temp_dir():\n  try:\n    temp_dir = tempfile.mkdtemp()\n    yield temp_dir\n  finally:\n    shutil.rmtree(temp_dir)\n@contextlib.contextmanager\ndef guard_temp_subdir(temp_dir, *path):\n  assert path, 'Path should not be empty'\n  try:",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "guard_temp_subdir",
        "kind": 2,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "def guard_temp_subdir(temp_dir, *path):\n  assert path, 'Path should not be empty'\n  try:\n    temp_subdir = os.path.join(temp_dir, *path)\n    os.makedirs(temp_subdir)\n    yield temp_subdir\n  finally:\n    shutil.rmtree(os.path.join(temp_dir, path[0]))\n@contextlib.contextmanager\ndef guard_patch_module(import_name, new_val):",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "guard_patch_module",
        "kind": 2,
        "importPath": "third-party.gtest-parallel.gtest_parallel_tests",
        "description": "third-party.gtest-parallel.gtest_parallel_tests",
        "peekOfCode": "def guard_patch_module(import_name, new_val):\n  def patch(module, names, val):\n    if len(names) == 1:\n      old = getattr(module, names[0])\n      setattr(module, names[0], val)\n      return old\n    else:\n      return patch(getattr(module, names[0]), names[1:], val)\n  try:\n    old_val = patch(gtest_parallel, import_name.split('.'), new_val)",
        "detail": "third-party.gtest-parallel.gtest_parallel_tests",
        "documentation": {}
    },
    {
        "label": "Rapid",
        "kind": 6,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "class Rapid( str ): pass\ndef rapid( item ):\n\tif isinstance( item, str ):\n\t\tr = Rapid( item )\n\t\treturn r\n\treturn list( map( Rapid, item ) )\nclass ReplxxTests( unittest.TestCase ):\n\t_prompt_ = \"\\033\\\\[1;32mreplxx\\033\\\\[0m> \"\n\t_cxxSample_ = \"./build/debug/replxx-example-cxx-api\"\n\t_cSample_ = \"./build/debug/replxx-example-c-api\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "ReplxxTests",
        "kind": 6,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "class ReplxxTests( unittest.TestCase ):\n\t_prompt_ = \"\\033\\\\[1;32mreplxx\\033\\\\[0m> \"\n\t_cxxSample_ = \"./build/debug/replxx-example-cxx-api\"\n\t_cSample_ = \"./build/debug/replxx-example-c-api\"\n\t_end_ = \"\\r\\nExiting Replxx\\r\\n\"\n\tdef send_str( self_, str_, intraKeyDelay_ ):\n\t\tif isinstance(str_, Rapid):\n\t\t\tself_._replxx.send( str_ )\n\t\t\treturn\n\t\tfor char in str_:",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "sym_to_raw",
        "kind": 2,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "def sym_to_raw( str_ ):\n\tfor sym, seq in keytab.items():\n\t\tif isinstance( str_, Rapid ):\n\t\t\tstr_ = Rapid( str_.replace( sym, seq ) )\n\t\telse:\n\t\t\tstr_ = str_.replace( sym, seq )\n\treturn str_\ndef seq_to_sym( str_ ):\n\tfor seq, sym in termseq.items():\n\t\tstr_ = str_.replace( seq, sym )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "seq_to_sym",
        "kind": 2,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "def seq_to_sym( str_ ):\n\tfor seq, sym in termseq.items():\n\t\tstr_ = str_.replace( seq, sym )\n\tstr_ = colRe.sub( \"<c\\\\1>\", str_ )\n\tstr_ = upRe.sub( \"<u\\\\1>\", str_ )\n\tstr_ = downRe.sub( \"<d\\\\1>\", str_ )\n\tstr_ = colorRe.sub( \"<color\\\\1>\", str_ )\n\tstr_ = bgcolorRe.sub( \"<bgcolor\\\\1>\", str_ )\n\treturn str_\n_words_ = [",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "skip",
        "kind": 2,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "def skip( test_ ):\n\treturn \"SKIP\" in os.environ and os.environ[\"SKIP\"].find( test_ ) >= 0\nverbosity = None\nclass Rapid( str ): pass\ndef rapid( item ):\n\tif isinstance( item, str ):\n\t\tr = Rapid( item )\n\t\treturn r\n\treturn list( map( Rapid, item ) )\nclass ReplxxTests( unittest.TestCase ):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "rapid",
        "kind": 2,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "def rapid( item ):\n\tif isinstance( item, str ):\n\t\tr = Rapid( item )\n\t\treturn r\n\treturn list( map( Rapid, item ) )\nclass ReplxxTests( unittest.TestCase ):\n\t_prompt_ = \"\\033\\\\[1;32mreplxx\\033\\\\[0m> \"\n\t_cxxSample_ = \"./build/debug/replxx-example-cxx-api\"\n\t_cSample_ = \"./build/debug/replxx-example-c-api\"\n\t_end_ = \"\\r\\nExiting Replxx\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "parseArgs",
        "kind": 2,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "def parseArgs( self, func, argv ):\n\tglobal verbosity\n\tres = func( self, argv )\n\tverbosity = self.verbosity\n\treturn res\nif __name__ == \"__main__\":\n\tpa = unittest.TestProgram.parseArgs\n\tunittest.TestProgram.parseArgs = lambda self, argv: parseArgs( self, pa, argv )\n\tunittest.main()",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "keytab",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "keytab = {\n\t\"<home>\": \"\\033[1~\",\n\t\"<s-home>\": \"\\033[1;2H\",\n\t\"<c-home>\": \"\\033[1;5H\",\n\t\"<end>\": \"\\033[4~\",\n\t\"<s-end>\": \"\\033[1;2F\",\n\t\"<c-end>\": \"\\033[1;5F\",\n\t\"<ins>\": \"\\033[2~\",\n\t\"<s-ins>\": \"\\033[2;2~\",\n\t\"<c-ins>\": \"\\033[2;5~\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "termseq",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "termseq = {\n\t\"\\x1bc\": \"<RIS>\",\n\t\"\\x1b[0m\": \"<rst>\",\n\t\"\\x1b[H\": \"<mvhm>\",\n\t\"\\x1b[2J\": \"<clr>\",\n\t\"\\x1b[J\": \"<ceos>\",\n\t\"\\x1b[0;22;30m\": \"<black>\",\n\t\"\\x1b[0;22;31m\": \"<red>\",\n\t\"\\x1b[0;22;32m\": \"<green>\",\n\t\"\\x1b[0;22;33m\": \"<brown>\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "colRe",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "colRe = re.compile( \"\\\\x1b\\\\[(\\\\d+)G\" )\nupRe = re.compile( \"\\\\x1b\\\\[(\\\\d+)A\" )\ndownRe = re.compile( \"\\\\x1b\\\\[(\\\\d+)B\" )\ncolorRe = re.compile( \"\\\\x1b\\\\[0;38;5;(\\\\d+)m\" )\nbgcolorRe = re.compile( \"\\\\x1b\\\\[48;5;(\\\\d+)m\" )\ndef sym_to_raw( str_ ):\n\tfor sym, seq in keytab.items():\n\t\tif isinstance( str_, Rapid ):\n\t\t\tstr_ = Rapid( str_.replace( sym, seq ) )\n\t\telse:",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "upRe",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "upRe = re.compile( \"\\\\x1b\\\\[(\\\\d+)A\" )\ndownRe = re.compile( \"\\\\x1b\\\\[(\\\\d+)B\" )\ncolorRe = re.compile( \"\\\\x1b\\\\[0;38;5;(\\\\d+)m\" )\nbgcolorRe = re.compile( \"\\\\x1b\\\\[48;5;(\\\\d+)m\" )\ndef sym_to_raw( str_ ):\n\tfor sym, seq in keytab.items():\n\t\tif isinstance( str_, Rapid ):\n\t\t\tstr_ = Rapid( str_.replace( sym, seq ) )\n\t\telse:\n\t\t\tstr_ = str_.replace( sym, seq )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "downRe",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "downRe = re.compile( \"\\\\x1b\\\\[(\\\\d+)B\" )\ncolorRe = re.compile( \"\\\\x1b\\\\[0;38;5;(\\\\d+)m\" )\nbgcolorRe = re.compile( \"\\\\x1b\\\\[48;5;(\\\\d+)m\" )\ndef sym_to_raw( str_ ):\n\tfor sym, seq in keytab.items():\n\t\tif isinstance( str_, Rapid ):\n\t\t\tstr_ = Rapid( str_.replace( sym, seq ) )\n\t\telse:\n\t\t\tstr_ = str_.replace( sym, seq )\n\treturn str_",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "colorRe",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "colorRe = re.compile( \"\\\\x1b\\\\[0;38;5;(\\\\d+)m\" )\nbgcolorRe = re.compile( \"\\\\x1b\\\\[48;5;(\\\\d+)m\" )\ndef sym_to_raw( str_ ):\n\tfor sym, seq in keytab.items():\n\t\tif isinstance( str_, Rapid ):\n\t\t\tstr_ = Rapid( str_.replace( sym, seq ) )\n\t\telse:\n\t\t\tstr_ = str_.replace( sym, seq )\n\treturn str_\ndef seq_to_sym( str_ ):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "bgcolorRe",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "bgcolorRe = re.compile( \"\\\\x1b\\\\[48;5;(\\\\d+)m\" )\ndef sym_to_raw( str_ ):\n\tfor sym, seq in keytab.items():\n\t\tif isinstance( str_, Rapid ):\n\t\t\tstr_ = Rapid( str_.replace( sym, seq ) )\n\t\telse:\n\t\t\tstr_ = str_.replace( sym, seq )\n\treturn str_\ndef seq_to_sym( str_ ):\n\tfor seq, sym in termseq.items():",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tstr_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tstr_ = Rapid( str_.replace( sym, seq ) )\n\t\telse:\n\t\t\tstr_ = str_.replace( sym, seq )\n\treturn str_\ndef seq_to_sym( str_ ):\n\tfor seq, sym in termseq.items():\n\t\tstr_ = str_.replace( seq, sym )\n\tstr_ = colRe.sub( \"<c\\\\1>\", str_ )\n\tstr_ = upRe.sub( \"<u\\\\1>\", str_ )\n\tstr_ = downRe.sub( \"<d\\\\1>\", str_ )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tstr_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tstr_ = str_.replace( sym, seq )\n\treturn str_\ndef seq_to_sym( str_ ):\n\tfor seq, sym in termseq.items():\n\t\tstr_ = str_.replace( seq, sym )\n\tstr_ = colRe.sub( \"<c\\\\1>\", str_ )\n\tstr_ = upRe.sub( \"<u\\\\1>\", str_ )\n\tstr_ = downRe.sub( \"<d\\\\1>\", str_ )\n\tstr_ = colorRe.sub( \"<color\\\\1>\", str_ )\n\tstr_ = bgcolorRe.sub( \"<bgcolor\\\\1>\", str_ )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tstr_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tstr_ = str_.replace( seq, sym )\n\tstr_ = colRe.sub( \"<c\\\\1>\", str_ )\n\tstr_ = upRe.sub( \"<u\\\\1>\", str_ )\n\tstr_ = downRe.sub( \"<d\\\\1>\", str_ )\n\tstr_ = colorRe.sub( \"<color\\\\1>\", str_ )\n\tstr_ = bgcolorRe.sub( \"<bgcolor\\\\1>\", str_ )\n\treturn str_\n_words_ = [\n\t\"ada\", \"algol\"\n\t\"bash\", \"basic\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\tstr_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\tstr_ = colRe.sub( \"<c\\\\1>\", str_ )\n\tstr_ = upRe.sub( \"<u\\\\1>\", str_ )\n\tstr_ = downRe.sub( \"<d\\\\1>\", str_ )\n\tstr_ = colorRe.sub( \"<color\\\\1>\", str_ )\n\tstr_ = bgcolorRe.sub( \"<bgcolor\\\\1>\", str_ )\n\treturn str_\n_words_ = [\n\t\"ada\", \"algol\"\n\t\"bash\", \"basic\",\n\t\"clojure\", \"cobol\", \"csharp\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\tstr_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\tstr_ = upRe.sub( \"<u\\\\1>\", str_ )\n\tstr_ = downRe.sub( \"<d\\\\1>\", str_ )\n\tstr_ = colorRe.sub( \"<color\\\\1>\", str_ )\n\tstr_ = bgcolorRe.sub( \"<bgcolor\\\\1>\", str_ )\n\treturn str_\n_words_ = [\n\t\"ada\", \"algol\"\n\t\"bash\", \"basic\",\n\t\"clojure\", \"cobol\", \"csharp\",\n\t\"eiffel\", \"erlang\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\tstr_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\tstr_ = downRe.sub( \"<d\\\\1>\", str_ )\n\tstr_ = colorRe.sub( \"<color\\\\1>\", str_ )\n\tstr_ = bgcolorRe.sub( \"<bgcolor\\\\1>\", str_ )\n\treturn str_\n_words_ = [\n\t\"ada\", \"algol\"\n\t\"bash\", \"basic\",\n\t\"clojure\", \"cobol\", \"csharp\",\n\t\"eiffel\", \"erlang\",\n\t\"forth\", \"fortran\", \"fsharp\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\tstr_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\tstr_ = colorRe.sub( \"<color\\\\1>\", str_ )\n\tstr_ = bgcolorRe.sub( \"<bgcolor\\\\1>\", str_ )\n\treturn str_\n_words_ = [\n\t\"ada\", \"algol\"\n\t\"bash\", \"basic\",\n\t\"clojure\", \"cobol\", \"csharp\",\n\t\"eiffel\", \"erlang\",\n\t\"forth\", \"fortran\", \"fsharp\",\n\t\"go\", \"groovy\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\tstr_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\tstr_ = bgcolorRe.sub( \"<bgcolor\\\\1>\", str_ )\n\treturn str_\n_words_ = [\n\t\"ada\", \"algol\"\n\t\"bash\", \"basic\",\n\t\"clojure\", \"cobol\", \"csharp\",\n\t\"eiffel\", \"erlang\",\n\t\"forth\", \"fortran\", \"fsharp\",\n\t\"go\", \"groovy\",\n\t\"haskell\", \"huginn\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "_words_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "_words_ = [\n\t\"ada\", \"algol\"\n\t\"bash\", \"basic\",\n\t\"clojure\", \"cobol\", \"csharp\",\n\t\"eiffel\", \"erlang\",\n\t\"forth\", \"fortran\", \"fsharp\",\n\t\"go\", \"groovy\",\n\t\"haskell\", \"huginn\",\n\t\"java\", \"javascript\", \"julia\",\n\t\"kotlin\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "verbosity",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "verbosity = None\nclass Rapid( str ): pass\ndef rapid( item ):\n\tif isinstance( item, str ):\n\t\tr = Rapid( item )\n\t\treturn r\n\treturn list( map( Rapid, item ) )\nclass ReplxxTests( unittest.TestCase ):\n\t_prompt_ = \"\\033\\\\[1;32mreplxx\\033\\\\[0m> \"\n\t_cxxSample_ = \"./build/debug/replxx-example-cxx-api\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tr",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tr = Rapid( item )\n\t\treturn r\n\treturn list( map( Rapid, item ) )\nclass ReplxxTests( unittest.TestCase ):\n\t_prompt_ = \"\\033\\\\[1;32mreplxx\\033\\\\[0m> \"\n\t_cxxSample_ = \"./build/debug/replxx-example-cxx-api\"\n\t_cSample_ = \"./build/debug/replxx-example-c-api\"\n\t_end_ = \"\\r\\nExiting Replxx\\r\\n\"\n\tdef send_str( self_, str_, intraKeyDelay_ ):\n\t\tif isinstance(str_, Rapid):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t_prompt_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t_prompt_ = \"\\033\\\\[1;32mreplxx\\033\\\\[0m> \"\n\t_cxxSample_ = \"./build/debug/replxx-example-cxx-api\"\n\t_cSample_ = \"./build/debug/replxx-example-c-api\"\n\t_end_ = \"\\r\\nExiting Replxx\\r\\n\"\n\tdef send_str( self_, str_, intraKeyDelay_ ):\n\t\tif isinstance(str_, Rapid):\n\t\t\tself_._replxx.send( str_ )\n\t\t\treturn\n\t\tfor char in str_:\n\t\t\tself_._replxx.send( char )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t_cxxSample_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t_cxxSample_ = \"./build/debug/replxx-example-cxx-api\"\n\t_cSample_ = \"./build/debug/replxx-example-c-api\"\n\t_end_ = \"\\r\\nExiting Replxx\\r\\n\"\n\tdef send_str( self_, str_, intraKeyDelay_ ):\n\t\tif isinstance(str_, Rapid):\n\t\t\tself_._replxx.send( str_ )\n\t\t\treturn\n\t\tfor char in str_:\n\t\t\tself_._replxx.send( char )\n\t\t\ttime.sleep( intraKeyDelay_ )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t_cSample_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t_cSample_ = \"./build/debug/replxx-example-c-api\"\n\t_end_ = \"\\r\\nExiting Replxx\\r\\n\"\n\tdef send_str( self_, str_, intraKeyDelay_ ):\n\t\tif isinstance(str_, Rapid):\n\t\t\tself_._replxx.send( str_ )\n\t\t\treturn\n\t\tfor char in str_:\n\t\t\tself_._replxx.send( char )\n\t\t\ttime.sleep( intraKeyDelay_ )\n\tdef check_scenario(",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t_end_",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t_end_ = \"\\r\\nExiting Replxx\\r\\n\"\n\tdef send_str( self_, str_, intraKeyDelay_ ):\n\t\tif isinstance(str_, Rapid):\n\t\t\tself_._replxx.send( str_ )\n\t\t\treturn\n\t\tfor char in str_:\n\t\t\tself_._replxx.send( char )\n\t\t\ttime.sleep( intraKeyDelay_ )\n\tdef check_scenario(\n\t\tself_, seq_, expected_,",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\thistory",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\thistory = \"one\\ntwo\\nthree\\n\",\n\t\tterm = \"xterm\",\n\t\tcommand = _cxxSample_,\n\t\tdimensions = ( 25, 80 ),\n\t\tprompt = _prompt_,\n\t\tend = None,\n\t\tencoding = \"utf-8\",\n\t\tpause = 0.25,\n\t\tintraKeyDelay = 0.002\n\t):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tterm",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tterm = \"xterm\",\n\t\tcommand = _cxxSample_,\n\t\tdimensions = ( 25, 80 ),\n\t\tprompt = _prompt_,\n\t\tend = None,\n\t\tencoding = \"utf-8\",\n\t\tpause = 0.25,\n\t\tintraKeyDelay = 0.002\n\t):\n\t\tif end is None:",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tcommand = _cxxSample_,\n\t\tdimensions = ( 25, 80 ),\n\t\tprompt = _prompt_,\n\t\tend = None,\n\t\tencoding = \"utf-8\",\n\t\tpause = 0.25,\n\t\tintraKeyDelay = 0.002\n\t):\n\t\tif end is None:\n\t\t\tend = prompt + ReplxxTests._end_",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tdimensions = ( 25, 80 ),\n\t\tprompt = _prompt_,\n\t\tend = None,\n\t\tencoding = \"utf-8\",\n\t\tpause = 0.25,\n\t\tintraKeyDelay = 0.002\n\t):\n\t\tif end is None:\n\t\t\tend = prompt + ReplxxTests._end_\n\t\twith open( \"replxx_history.txt\", \"wb\" ) as f:",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tprompt",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tprompt = _prompt_,\n\t\tend = None,\n\t\tencoding = \"utf-8\",\n\t\tpause = 0.25,\n\t\tintraKeyDelay = 0.002\n\t):\n\t\tif end is None:\n\t\t\tend = prompt + ReplxxTests._end_\n\t\twith open( \"replxx_history.txt\", \"wb\" ) as f:\n\t\t\tf.write( history.encode( encoding ) )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tend",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tend = None,\n\t\tencoding = \"utf-8\",\n\t\tpause = 0.25,\n\t\tintraKeyDelay = 0.002\n\t):\n\t\tif end is None:\n\t\t\tend = prompt + ReplxxTests._end_\n\t\twith open( \"replxx_history.txt\", \"wb\" ) as f:\n\t\t\tf.write( history.encode( encoding ) )\n\t\t\tf.close()",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tencoding",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tencoding = \"utf-8\",\n\t\tpause = 0.25,\n\t\tintraKeyDelay = 0.002\n\t):\n\t\tif end is None:\n\t\t\tend = prompt + ReplxxTests._end_\n\t\twith open( \"replxx_history.txt\", \"wb\" ) as f:\n\t\t\tf.write( history.encode( encoding ) )\n\t\t\tf.close()\n\t\tos.environ[\"TERM\"] = term",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tpause",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tpause = 0.25,\n\t\tintraKeyDelay = 0.002\n\t):\n\t\tif end is None:\n\t\t\tend = prompt + ReplxxTests._end_\n\t\twith open( \"replxx_history.txt\", \"wb\" ) as f:\n\t\t\tf.write( history.encode( encoding ) )\n\t\t\tf.close()\n\t\tos.environ[\"TERM\"] = term\n\t\tif isinstance( command, str ):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tintraKeyDelay",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tintraKeyDelay = 0.002\n\t):\n\t\tif end is None:\n\t\t\tend = prompt + ReplxxTests._end_\n\t\twith open( \"replxx_history.txt\", \"wb\" ) as f:\n\t\t\tf.write( history.encode( encoding ) )\n\t\t\tf.close()\n\t\tos.environ[\"TERM\"] = term\n\t\tif isinstance( command, str ):\n\t\t\tcommand = command.replace( \"\\n\", \"~\" )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tend",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tend = prompt + ReplxxTests._end_\n\t\twith open( \"replxx_history.txt\", \"wb\" ) as f:\n\t\t\tf.write( history.encode( encoding ) )\n\t\t\tf.close()\n\t\tos.environ[\"TERM\"] = term\n\t\tif isinstance( command, str ):\n\t\t\tcommand = command.replace( \"\\n\", \"~\" )\n\t\tif verbosity >= 2:\n\t\t\tprint( \"\\nTERM: {}, SIZE: {}, CMD: {}\".format( term, dimensions, command ) )\n\t\tprompt = prompt.replace( \"\\n\", \"\\r\\n\" ).replace( \"\\r\\r\", \"\\r\" )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tos.environ[\"TERM\"]",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tos.environ[\"TERM\"] = term\n\t\tif isinstance( command, str ):\n\t\t\tcommand = command.replace( \"\\n\", \"~\" )\n\t\tif verbosity >= 2:\n\t\t\tprint( \"\\nTERM: {}, SIZE: {}, CMD: {}\".format( term, dimensions, command ) )\n\t\tprompt = prompt.replace( \"\\n\", \"\\r\\n\" ).replace( \"\\r\\r\", \"\\r\" )\n\t\tend = end.replace( \"\\n\", \"\\r\\n\" ).replace( \"\\r\\r\", \"\\r\" )\n\t\tif isinstance( command, str ):\n\t\t\tself_._replxx = pexpect.spawn( command, maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\telse:",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = command.replace( \"\\n\", \"~\" )\n\t\tif verbosity >= 2:\n\t\t\tprint( \"\\nTERM: {}, SIZE: {}, CMD: {}\".format( term, dimensions, command ) )\n\t\tprompt = prompt.replace( \"\\n\", \"\\r\\n\" ).replace( \"\\r\\r\", \"\\r\" )\n\t\tend = end.replace( \"\\n\", \"\\r\\n\" ).replace( \"\\r\\r\", \"\\r\" )\n\t\tif isinstance( command, str ):\n\t\t\tself_._replxx = pexpect.spawn( command, maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\telse:\n\t\t\tself_._replxx = pexpect.spawn( command[0], args = command[1:], maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\tself_._replxx.expect( prompt )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tprompt",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tprompt = prompt.replace( \"\\n\", \"\\r\\n\" ).replace( \"\\r\\r\", \"\\r\" )\n\t\tend = end.replace( \"\\n\", \"\\r\\n\" ).replace( \"\\r\\r\", \"\\r\" )\n\t\tif isinstance( command, str ):\n\t\t\tself_._replxx = pexpect.spawn( command, maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\telse:\n\t\t\tself_._replxx = pexpect.spawn( command[0], args = command[1:], maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\tself_._replxx.expect( prompt )\n\t\tself_.maxDiff = None\n\t\tif isinstance( seq_, str ):\n\t\t\tif isinstance( seq_, Rapid ):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tend",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tend = end.replace( \"\\n\", \"\\r\\n\" ).replace( \"\\r\\r\", \"\\r\" )\n\t\tif isinstance( command, str ):\n\t\t\tself_._replxx = pexpect.spawn( command, maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\telse:\n\t\t\tself_._replxx = pexpect.spawn( command[0], args = command[1:], maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\tself_._replxx.expect( prompt )\n\t\tself_.maxDiff = None\n\t\tif isinstance( seq_, str ):\n\t\t\tif isinstance( seq_, Rapid ):\n\t\t\t\tseqs = rapid( seq_.split( \"<c-z>\" ) )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tself_._replxx",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tself_._replxx = pexpect.spawn( command, maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\telse:\n\t\t\tself_._replxx = pexpect.spawn( command[0], args = command[1:], maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\tself_._replxx.expect( prompt )\n\t\tself_.maxDiff = None\n\t\tif isinstance( seq_, str ):\n\t\t\tif isinstance( seq_, Rapid ):\n\t\t\t\tseqs = rapid( seq_.split( \"<c-z>\" ) )\n\t\t\telse:\n\t\t\t\tseqs = seq_.split( \"<c-z>\" )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tself_._replxx",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tself_._replxx = pexpect.spawn( command[0], args = command[1:], maxread = 1, encoding = encoding, dimensions = dimensions )\n\t\tself_._replxx.expect( prompt )\n\t\tself_.maxDiff = None\n\t\tif isinstance( seq_, str ):\n\t\t\tif isinstance( seq_, Rapid ):\n\t\t\t\tseqs = rapid( seq_.split( \"<c-z>\" ) )\n\t\t\telse:\n\t\t\t\tseqs = seq_.split( \"<c-z>\" )\n\t\t\tfor seq in seqs:\n\t\t\t\tlast = seq is seqs[-1]",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tself_.maxDiff",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tself_.maxDiff = None\n\t\tif isinstance( seq_, str ):\n\t\t\tif isinstance( seq_, Rapid ):\n\t\t\t\tseqs = rapid( seq_.split( \"<c-z>\" ) )\n\t\t\telse:\n\t\t\t\tseqs = seq_.split( \"<c-z>\" )\n\t\t\tfor seq in seqs:\n\t\t\t\tlast = seq is seqs[-1]\n\t\t\t\tif not last:\n\t\t\t\t\tseq += \"<c-z>\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tseqs",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\t\tseqs = rapid( seq_.split( \"<c-z>\" ) )\n\t\t\telse:\n\t\t\t\tseqs = seq_.split( \"<c-z>\" )\n\t\t\tfor seq in seqs:\n\t\t\t\tlast = seq is seqs[-1]\n\t\t\t\tif not last:\n\t\t\t\t\tseq += \"<c-z>\"\n\t\t\t\tself_.send_str( sym_to_raw( seq ), intraKeyDelay )\n\t\t\t\tif not last:\n\t\t\t\t\ttime.sleep( pause )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tseqs",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\t\tseqs = seq_.split( \"<c-z>\" )\n\t\t\tfor seq in seqs:\n\t\t\t\tlast = seq is seqs[-1]\n\t\t\t\tif not last:\n\t\t\t\t\tseq += \"<c-z>\"\n\t\t\t\tself_.send_str( sym_to_raw( seq ), intraKeyDelay )\n\t\t\t\tif not last:\n\t\t\t\t\ttime.sleep( pause )\n\t\t\t\t\tself_._replxx.kill( signal.SIGCONT )\n\t\telse:",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tlast",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\t\tlast = seq is seqs[-1]\n\t\t\t\tif not last:\n\t\t\t\t\tseq += \"<c-z>\"\n\t\t\t\tself_.send_str( sym_to_raw( seq ), intraKeyDelay )\n\t\t\t\tif not last:\n\t\t\t\t\ttime.sleep( pause )\n\t\t\t\t\tself_._replxx.kill( signal.SIGCONT )\n\t\telse:\n\t\t\tfor seq in seq_:\n\t\t\t\tlast = seq is seq_[-1]",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tlast",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\t\tlast = seq is seq_[-1]\n\t\t\t\tself_.send_str( sym_to_raw( seq ), intraKeyDelay )\n\t\t\t\tif not last:\n\t\t\t\t\ttime.sleep( pause )\n\t\tself_._replxx.expect( end )\n\t\tif isinstance( expected_, str ):\n\t\t\tself_.assertSequenceEqual( seq_to_sym( self_._replxx.before ), expected_ )\n\t\telse:\n\t\t\ttry:\n\t\t\t\tself_.assertIn( seq_to_sym( self_._replxx.before ), expected_ )",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tLC_CTYPE",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tLC_CTYPE = \"LC_CTYPE\"\n\t\texists = LC_CTYPE in os.environ\n\t\tlcCtype = None\n\t\tif exists:\n\t\t\tlcCtype = os.environ[LC_CTYPE]\n\t\tos.environ[LC_CTYPE] = \"pl_PL.ISO-8859-2\"\n\t\tself_.check_scenario(\n\t\t\t\"<aup><cr><c-d>\",\n\t\t\t\"<c9>text ~ó~<rst><ceos><c17><c9>text ~ó~<rst><ceos><c17>\\r\\ntext ~ó~\\r\\n\",\n\t\t\t\"text ~ó~\\n\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\texists",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\texists = LC_CTYPE in os.environ\n\t\tlcCtype = None\n\t\tif exists:\n\t\t\tlcCtype = os.environ[LC_CTYPE]\n\t\tos.environ[LC_CTYPE] = \"pl_PL.ISO-8859-2\"\n\t\tself_.check_scenario(\n\t\t\t\"<aup><cr><c-d>\",\n\t\t\t\"<c9>text ~ó~<rst><ceos><c17><c9>text ~ó~<rst><ceos><c17>\\r\\ntext ~ó~\\r\\n\",\n\t\t\t\"text ~ó~\\n\",\n\t\t\tencoding = \"iso-8859-2\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tlcCtype",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tlcCtype = None\n\t\tif exists:\n\t\t\tlcCtype = os.environ[LC_CTYPE]\n\t\tos.environ[LC_CTYPE] = \"pl_PL.ISO-8859-2\"\n\t\tself_.check_scenario(\n\t\t\t\"<aup><cr><c-d>\",\n\t\t\t\"<c9>text ~ó~<rst><ceos><c17><c9>text ~ó~<rst><ceos><c17>\\r\\ntext ~ó~\\r\\n\",\n\t\t\t\"text ~ó~\\n\",\n\t\t\tencoding = \"iso-8859-2\"\n\t\t)",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tlcCtype",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tlcCtype = os.environ[LC_CTYPE]\n\t\tos.environ[LC_CTYPE] = \"pl_PL.ISO-8859-2\"\n\t\tself_.check_scenario(\n\t\t\t\"<aup><cr><c-d>\",\n\t\t\t\"<c9>text ~ó~<rst><ceos><c17><c9>text ~ó~<rst><ceos><c17>\\r\\ntext ~ó~\\r\\n\",\n\t\t\t\"text ~ó~\\n\",\n\t\t\tencoding = \"iso-8859-2\"\n\t\t)\n\t\tif exists:\n\t\t\tos.environ[LC_CTYPE] = lcCtype",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tos.environ[LC_CTYPE]",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tos.environ[LC_CTYPE] = \"pl_PL.ISO-8859-2\"\n\t\tself_.check_scenario(\n\t\t\t\"<aup><cr><c-d>\",\n\t\t\t\"<c9>text ~ó~<rst><ceos><c17><c9>text ~ó~<rst><ceos><c17>\\r\\ntext ~ó~\\r\\n\",\n\t\t\t\"text ~ó~\\n\",\n\t\t\tencoding = \"iso-8859-2\"\n\t\t)\n\t\tif exists:\n\t\t\tos.environ[LC_CTYPE] = lcCtype\n\t\telse:",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tencoding",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tencoding = \"iso-8859-2\"\n\t\t)\n\t\tif exists:\n\t\t\tos.environ[LC_CTYPE] = lcCtype\n\t\telse:\n\t\t\tdel os.environ[LC_CTYPE]\n\tdef test_bad_term( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"a line of text<cr><c-d>\",\n\t\t\t\"a line of text\\r\\na line of text\\r\\n\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tos.environ[LC_CTYPE]",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tos.environ[LC_CTYPE] = lcCtype\n\t\telse:\n\t\t\tdel os.environ[LC_CTYPE]\n\tdef test_bad_term( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"a line of text<cr><c-d>\",\n\t\t\t\"a line of text\\r\\na line of text\\r\\n\",\n\t\t\tterm = \"dumb\"\n\t\t)\n\tdef test_ctrl_c( self_ ):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tterm",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tterm = \"dumb\"\n\t\t)\n\tdef test_ctrl_c( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"abc<c-c><c-d>\",\n\t\t\t\"<c9>a<rst><ceos><c10><c9>ab<rst><ceos><c11><c9>abc<rst><ceos><c12><c9>abc<rst><ceos><c12>^C\\r\"\n\t\t\t\"\\r\\n\"\n\t\t)\n\tdef test_ctrl_z( self_ ):\n\t\tself_.check_scenario(",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tend",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tend = \"\\r\\nExiting Replxx\\r\\n\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<cr><up><c-left><c-l><cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9>first \"\n\t\t\t\"second<rst><ceos><c21><c9>first \"\n\t\t\t\"second<rst><ceos><c15><RIS><mvhm><clr><rst><brightgreen>replxx<rst>> \"\n\t\t\t\"<c9>first second<rst><ceos><c15><c9>first second<rst><ceos><c21>\\r\\n\"\n\t\t\t\"first second\\r\\n\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 16, 64 )\n\t\t)\n\tdef test_hint_scroll_down( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"co<c-down><c-down><tab><cr><c-d>\",\n\t\t\t\"<c9>c<rst><ceos><c10><c9>co<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>color_black<rst>\\r\\n\"\n\t\t\t\"        <gray>color_red<rst>\\r\\n\"\n\t\t\t\"        \"\n\t\t\t\"<gray>color_green<rst><u3><c11><c9>co<rst><ceos><gray>lor_black<rst>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 16, 48 )\n\t\t)\n\tdef test_history( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><up><up><up><down><down><down><down>four<cr><c-d>\",\n\t\t\t\"<c9>three<rst><ceos><c14><c9>two<rst><ceos><c12><c9>one<rst><ceos><c12><c9>two<rst><ceos><c12><c9>three<rst><ceos><c14><c9><rst><ceos><c9><c9>f<rst><ceos><c10><c9>fo<rst><ceos><c11><c9>fou<rst><ceos><c12><c9>four<rst><ceos><c13><c9>four<rst><ceos><c13>\\r\\n\"\n\t\t\t\"four\\r\\n\"\n\t\t)\n\t\twith open( \"replxx_history.txt\", \"rb\" ) as f:\n\t\t\tdata = f.read().decode()",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdata",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdata = f.read().decode()\n\t\t\tself_.assertSequenceEqual( data[:-33], \"### 0000-00-00 00:00:00.000\\none\\n### 0000-00-00 00:00:00.000\\ntwo\\n### 0000-00-00 00:00:00.000\\nthree\\n\" )\n\t\t\tself_.assertSequenceEqual( data[-5:], \"four\\n\" )\n\tdef test_paren_matching( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"ab(cd)ef<left><left><left><left><left><left><left><cr><c-d>\",\n\t\t\t\"<c9>a<rst><ceos><c10><c9>ab<rst><ceos><c11><c9>ab<brightmagenta>(<rst><ceos><c12><c9>ab<brightmagenta>(<rst>c<rst><ceos><c13><c9>ab<brightmagenta>(<rst>cd<rst><ceos><c14><c9>ab<brightmagenta>(<rst>cd<brightmagenta>)<rst><ceos><c15><c9>ab<brightmagenta>(<rst>cd<brightmagenta>)<rst>e<rst><ceos><c16><c9>ab<brightmagenta>(<rst>cd<brightmagenta>)<rst>ef<rst><ceos><c17><c9>ab<brightmagenta>(<rst>cd<brightmagenta>)<rst>ef<rst><ceos><c16><c15><c9>ab<brightred>(<rst>cd<brightmagenta>)<rst>ef<rst><ceos><c14><c9>ab<brightmagenta>(<rst>cd<brightmagenta>)<rst>ef<rst><ceos><c13><c12><c9>ab<brightmagenta>(<rst>cd<brightred>)<rst>ef<rst><ceos><c11><c9>ab<brightmagenta>(<rst>cd<brightmagenta>)<rst>ef<rst><ceos><c10><c9>ab<brightmagenta>(<rst>cd<brightmagenta>)<rst>ef<rst><ceos><c17>\\r\\n\"\n\t\t\t\"ab(cd)ef\\r\\n\"\n\t\t)\n\tdef test_paren_not_matched( self_ ):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 4, 32 ),\n\t\t\tcommand = [ ReplxxTests._cSample_, \"q1\", \"e0\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab><tab>n<cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"db\\r\\n\"\n\t\t\t\"hello\\r\\n\"\n\t\t\t\"hallo\\r\\n\"\n\t\t\t\"--More--<bell>\\r\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"q1\", \"e0\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab><tab>n<cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"db\\r\\n\"\n\t\t\t\"hello\\r\\n\"\n\t\t\t\"hallo\\r\\n\"\n\t\t\t\"--More--<bell>\\r\"\n\t\t\t\"\\t\\t\\t\\t\\r\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 4, 24 ),\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 e1\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<up><home>co<tab><cr><c-d>\",\n\t\t\t\"<c9>abcd<brightmagenta>()<rst><ceos><c15>\"\n\t\t\t\"<c9>abcd<brightmagenta>()<rst><ceos><c9>\"\n\t\t\t\"<c9>cabcd<brightmagenta>()<rst><ceos><c10>\"\n\t\t\t\"<c9>coabcd<brightmagenta>()<rst><ceos><c11>\"\n\t\t\t\"<c9>color_abcd<brightmagenta>()<rst><ceos><c15>\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 e1\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<up><home>co<tab><cr><c-d>\",\n\t\t\t\"<c9>abcd<brightmagenta>()<rst><ceos><c15>\"\n\t\t\t\"<c9>abcd<brightmagenta>()<rst><ceos><c9>\"\n\t\t\t\"<c9>cabcd<brightmagenta>()<rst><ceos><c10>\"\n\t\t\t\"<c9>coabcd<brightmagenta>()<rst><ceos><c11>\"\n\t\t\t\"<c9>color_abcd<brightmagenta>()<rst><ceos><c15>\"\n\t\t\t\"<c9>color_abcd<brightmagenta>()<rst><ceos><c21>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tcmd",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tcmd = ReplxxTests._cSample_ + \" q1 x\" + \",\".join( _words_ )\n\t\tself_.check_scenario(\n\t\t\t\"<tab>py<cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"ada         groovy      perl\\r\\n\"\n\t\t\t\"algolbash   haskell     php\\r\\n\"\n\t\t\t\"basic       huginn      prolog\\r\\n\"\n\t\t\t\"clojure     java        python\\r\\n\"\n\t\t\t\"cobol       javascript  rebol\\r\\n\"\n\t\t\t\"csharp      julia       ruby\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 10, 40 ),\n\t\t\tcommand = cmd\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab><cr><cr><cr><cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"ada         groovy      perl\\r\\n\"\n\t\t\t\"algolbash   haskell     php\\r\\n\"\n\t\t\t\"basic       huginn      prolog\\r\\n\"\n\t\t\t\"clojure     java        python\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = cmd\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab><cr><cr><cr><cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"ada         groovy      perl\\r\\n\"\n\t\t\t\"algolbash   haskell     php\\r\\n\"\n\t\t\t\"basic       huginn      prolog\\r\\n\"\n\t\t\t\"clojure     java        python\\r\\n\"\n\t\t\t\"cobol       javascript  rebol\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 10, 40 ),\n\t\t\tcommand = cmd\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab><c-c><cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"ada         kotlin\\r\\n\"\n\t\t\t\"algolbash   lisp\\r\\n\"\n\t\t\t\"basic       lua\\r\\n\"\n\t\t\t\"clojure     modula\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = cmd\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab><c-c><cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"ada         kotlin\\r\\n\"\n\t\t\t\"algolbash   lisp\\r\\n\"\n\t\t\t\"basic       lua\\r\\n\"\n\t\t\t\"clojure     modula\\r\\n\"\n\t\t\t\"cobol       nemerle\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 8, 32 ),\n\t\t\tcommand = cmd\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab>q<cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"ada         kotlin\\r\\n\"\n\t\t\t\"algolbash   lisp\\r\\n\"\n\t\t\t\"basic       lua\\r\\n\"\n\t\t\t\"clojure     modula\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = cmd\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab>q<cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"ada         kotlin\\r\\n\"\n\t\t\t\"algolbash   lisp\\r\\n\"\n\t\t\t\"basic       lua\\r\\n\"\n\t\t\t\"clojure     modula\\r\\n\"\n\t\t\t\"cobol       nemerle\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 8, 32 ),\n\t\t\tcommand = cmd\n\t\t)\n\tdef test_double_tab_completion( self_ ):\n\t\tcmd = ReplxxTests._cSample_ + \" d1 q1 x\" + \",\".join( _words_ )\n\t\tself_.check_scenario(\n\t\t\t\"fo<tab><tab>r<tab><cr><c-d>\",\n\t\t\t\"<c9>f<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>forth<rst>\\r\\n\"\n\t\t\t\"        <gray>fortran<rst>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = cmd\n\t\t)\n\tdef test_double_tab_completion( self_ ):\n\t\tcmd = ReplxxTests._cSample_ + \" d1 q1 x\" + \",\".join( _words_ )\n\t\tself_.check_scenario(\n\t\t\t\"fo<tab><tab>r<tab><cr><c-d>\",\n\t\t\t\"<c9>f<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>forth<rst>\\r\\n\"\n\t\t\t\"        <gray>fortran<rst>\\r\\n\"\n\t\t\t\"        <gray>fsharp<rst><u3><c10><c9>fo<rst><ceos>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tcmd",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tcmd = ReplxxTests._cSample_ + \" d1 q1 x\" + \",\".join( _words_ )\n\t\tself_.check_scenario(\n\t\t\t\"fo<tab><tab>r<tab><cr><c-d>\",\n\t\t\t\"<c9>f<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>forth<rst>\\r\\n\"\n\t\t\t\"        <gray>fortran<rst>\\r\\n\"\n\t\t\t\"        <gray>fsharp<rst><u3><c10><c9>fo<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>forth<rst>\\r\\n\"\n\t\t\t\"        <gray>fortran<rst><u2><c11><c9>fort<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>forth<rst>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = cmd\n\t\t)\n\tdef test_beep_on_ambiguous_completion( self_ ):\n\t\tcmd = ReplxxTests._cSample_ + \" b1 d1 q1 x\" + \",\".join( _words_ )\n\t\tself_.check_scenario(\n\t\t\t\"fo<tab><tab>r<tab><cr><c-d>\",\n\t\t\t\"<c9>f<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>forth<rst>\\r\\n\"\n\t\t\t\"        <gray>fortran<rst>\\r\\n\"\n\t\t\t\"        <gray>fsharp<rst><u3><c10><c9>fo<rst><ceos>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tcmd",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tcmd = ReplxxTests._cSample_ + \" b1 d1 q1 x\" + \",\".join( _words_ )\n\t\tself_.check_scenario(\n\t\t\t\"fo<tab><tab>r<tab><cr><c-d>\",\n\t\t\t\"<c9>f<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>forth<rst>\\r\\n\"\n\t\t\t\"        <gray>fortran<rst>\\r\\n\"\n\t\t\t\"        <gray>fsharp<rst><u3><c10><c9>fo<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>forth<rst>\\r\\n\"\n\t\t\t\"        <gray>fortran<rst><u2><c11><bell><c9>fort<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>forth<rst>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = cmd\n\t\t)\n\tdef test_history_search_backward( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<c-r>repl<c-r><cr><c-d>\",\n\t\t\t\"<c1><ceos><c1><ceos>(reverse-i-search)`': \"\n\t\t\t\"<c23><c1><ceos>(reverse-i-search)`r': echo repl \"\n\t\t\t\"golf<c29><c1><ceos>(reverse-i-search)`re': echo repl \"\n\t\t\t\"golf<c30><c1><ceos>(reverse-i-search)`rep': echo repl \"\n\t\t\t\"golf<c31><c1><ceos>(reverse-i-search)`repl': echo repl \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 24, 64 )\n\t\t)\n\tdef test_history_prefix_search_backward( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"repl<m-p><m-p><cr><c-d>\",\n\t\t\t\"<c9>r<rst><ceos><c10><c9>re<rst><ceos><c11><c9>rep<rst><ceos><c12><c9>repl<rst><ceos><c13><c9>repl_echo \"\n\t\t\t\"golf<rst><ceos><c23><c9>repl_charlie \"\n\t\t\t\"delta<rst><ceos><c27><c9>repl_charlie delta<rst><ceos><c27>\\r\\n\"\n\t\t\t\"repl_charlie delta\\r\\n\",\n\t\t\t\"some command\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1\"\n\t\t)\n\tdef test_history_browse( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><aup><pgup><down><up><up><adown><pgdown><up><down><down><up><cr><c-d>\",\n\t\t\t\"<c9>twelve<rst><ceos><c15>\"\n\t\t\t\"<c9>eleven<rst><ceos><c15>\"\n\t\t\t\"<c9>one<rst><ceos><c12>\"\n\t\t\t\"<c9>two<rst><ceos><c12>\"\n\t\t\t\"<c9>one<rst><ceos><c12>\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 s3\"\n\t\t)\n\tdef test_history_unique( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"a<cr>b<cr>a<cr>b<cr><up><up><up><cr><c-d>\",\n\t\t\t\"<c9>a<rst><ceos><c10><c9>a<rst><ceos><c10>\\r\\n\"\n\t\t\t\"a\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9>b<rst><ceos><c10><c9>b<rst><ceos><c10>\\r\\n\"\n\t\t\t\"b\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9>a<rst><ceos><c10><c9>a<rst><ceos><c10>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" u1 q1\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"a<cr>b<cr>a<cr>b<cr><up><up><up><cr><c-d>\",\n\t\t\t\"<c9>a<rst><ceos><c10><c9>a<rst><ceos><c10>\\r\\n\"\n\t\t\t\"a\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9>b<rst><ceos><c10><c9>b<rst><ceos><c10>\\r\\n\"\n\t\t\t\"b\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9>a<rst><ceos><c10><c9>a<rst><ceos><c10>\\r\\n\"\n\t\t\t\"a\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" u0 q1\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\trapid( \"/history<cr>/unique<cr>/history<cr><c-d>\" ),\n\t\t\t\"<c9>/<rst><ceos><c10><c9>/history<rst><ceos><c17>\\r\\n\"\n\t\t\t\"   0: a\\r\\n\"\n\t\t\t\"   1: b\\r\\n\"\n\t\t\t\"   2: c\\r\\n\"\n\t\t\t\"   3: b\\r\\n\"\n\t\t\t\"   4: c\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" u0 q1\"\n\t\t)\n\tdef test_history_recall_most_recent( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<pgup><down><cr><down><cr><c-d>\",\n\t\t\t\"<c9>aaaa<rst><ceos><c13><c9>bbbb<rst><ceos><c13><c9>bbbb<rst><ceos><c13>\\r\\n\"\n\t\t\t\"bbbb\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> \"\n\t\t\t\"<c9>cccc<rst><ceos><c13><c9>cccc<rst><ceos><c13>\\r\\n\"\n\t\t\t\"cccc\\r\\n\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 c3\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab>n<cr><c-d>\",\n\t\t\t\"<c9><rst><ceos><c9>\\r\\n\"\n\t\t\t\"Display all 9 possibilities? (y or n)\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> \"\n\t\t\t\"<c9><rst><ceos><c9><c9><rst><ceos><c9>\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 c3\"\n\t\t)",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 c3\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<tab><c-c><cr><c-d>\",\n\t\t\t\"<c9><rst><ceos><c9>\\r\\n\"\n\t\t\t\"Display all 9 possibilities? (y or n)^C\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> \"\n\t\t\t\"<c9><rst><ceos><c9><c9><rst><ceos><c9>\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 c3\"\n\t\t)",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 c3\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t[\"<tab>\", \"<c-c><cr><c-d>\"],\n\t\t\t\"<c9><rst><ceos><c9>\\r\\n\"\n\t\t\t\"Display all 9 possibilities? (y or n)^C\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> \"\n\t\t\t\"<c9><rst><ceos><c9><c9><rst><ceos><c9>\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 c3 H200\"\n\t\t)",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 c3 H200\"\n\t\t)\n\tdef test_preload( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<cr><c-d>\",\n\t\t\t\"<c9>Alice has a cat.<rst><ceos><c25>\"\n\t\t\t\"<c9>Alice has a cat.<rst><ceos><c25>\\r\\n\"\n\t\t\t\"Alice has a cat.\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PAlice has a cat.'\"\n\t\t)",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PAlice has a cat.'\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<cr><c-d>\",\n\t\t\t\"<c9>Cat  eats  mice. \"\n\t\t\t\"<rst><ceos><c26><c9>Cat  eats  mice. \"\n\t\t\t\"<rst><ceos><c26>\\r\\n\"\n\t\t\t\"Cat  eats  mice. \"\n\t\t\t\"\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PCat\\teats\\tmice.\\r\\n'\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PCat\\teats\\tmice.\\r\\n'\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<cr><c-d>\",\n\t\t\t\"<c9>Cat  eats  mice. \"\n\t\t\t\"<rst><ceos><c26><c9>Cat  eats  mice. \"\n\t\t\t\"<rst><ceos><c26>\\r\\n\"\n\t\t\t\"Cat  eats  mice. \"\n\t\t\t\"\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PCat\\teats\\tmice.\\r\\n\\r\\n\\n\\n'\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PCat\\teats\\tmice.\\r\\n\\r\\n\\n\\n'\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<cr><c-d>\",\n\t\t\t\"<c9>M Alice has a cat.<rst><ceos><c27>\"\n\t\t\t\"<c9>M Alice has a cat.<rst><ceos><c27>\\r\\n\"\n\t\t\t\"M Alice has a cat.\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PM\u0017Alice has a cat.'\"\n\t\t)\n\t\tself_.check_scenario(",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PM\u0017Alice has a cat.'\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<cr><c-d>\",\n\t\t\t\"<c9>M  Alice has a cat.<rst><ceos><c28>\"\n\t\t\t\"<c9>M  Alice has a cat.<rst><ceos><c28>\\r\\n\"\n\t\t\t\"M  Alice has a cat.\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PM\\t\\t\\t\\t\u0017Alice has a cat.'\"\n\t\t)\n\tdef test_prompt( self_ ):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'PM\\t\\t\\t\\t\u0017Alice has a cat.'\"\n\t\t)\n\tdef test_prompt( self_ ):\n\t\tprompt = \"date: now\\nrepl> \"\n\t\tself_.check_scenario(\n\t\t\t\"<up><cr><up><up><cr><c-d>\",\n\t\t\t\"<c7>three<rst><ceos><c12><c7>three<rst><ceos><c12>\\r\\n\"\n\t\t\t\"three\\r\\n\"\n\t\t\t\"date: now\\r\\n\"\n\t\t\t\"repl> \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tprompt",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tprompt = \"date: now\\nrepl> \"\n\t\tself_.check_scenario(\n\t\t\t\"<up><cr><up><up><cr><c-d>\",\n\t\t\t\"<c7>three<rst><ceos><c12><c7>three<rst><ceos><c12>\\r\\n\"\n\t\t\t\"three\\r\\n\"\n\t\t\t\"date: now\\r\\n\"\n\t\t\t\"repl> \"\n\t\t\t\"<c7>three<rst><ceos><c12><c7>two<rst><ceos><c10><c7>two<rst><ceos><c10>\\r\\n\"\n\t\t\t\"two\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'p{}'\".format( prompt ),",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'p{}'\".format( prompt ),\n\t\t\tprompt = prompt,\n\t\t\tend = prompt + ReplxxTests._end_\n\t\t)\n\t\tprompt = \"repl>\\n\"\n\t\tself_.check_scenario(\n\t\t\t\"a<cr><c-d>\",\n\t\t\t\"<c1>a<rst><ceos><c2><c1>a<rst><ceos><c2>\\r\\na\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'p{}'\".format( prompt ),\n\t\t\tprompt = prompt,",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tprompt",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tprompt = prompt,\n\t\t\tend = prompt + ReplxxTests._end_\n\t\t)\n\t\tprompt = \"repl>\\n\"\n\t\tself_.check_scenario(\n\t\t\t\"a<cr><c-d>\",\n\t\t\t\"<c1>a<rst><ceos><c2><c1>a<rst><ceos><c2>\\r\\na\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'p{}'\".format( prompt ),\n\t\t\tprompt = prompt,\n\t\t\tend = prompt + ReplxxTests._end_",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tend",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tend = prompt + ReplxxTests._end_\n\t\t)\n\t\tprompt = \"repl>\\n\"\n\t\tself_.check_scenario(\n\t\t\t\"a<cr><c-d>\",\n\t\t\t\"<c1>a<rst><ceos><c2><c1>a<rst><ceos><c2>\\r\\na\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'p{}'\".format( prompt ),\n\t\t\tprompt = prompt,\n\t\t\tend = prompt + ReplxxTests._end_\n\t\t)",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tprompt",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tprompt = \"repl>\\n\"\n\t\tself_.check_scenario(\n\t\t\t\"a<cr><c-d>\",\n\t\t\t\"<c1>a<rst><ceos><c2><c1>a<rst><ceos><c2>\\r\\na\\r\\n\",\n\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'p{}'\".format( prompt ),\n\t\t\tprompt = prompt,\n\t\t\tend = prompt + ReplxxTests._end_\n\t\t)\n\tdef test_long_line( self_ ):\n\t\tself_.check_scenario(",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'p{}'\".format( prompt ),\n\t\t\tprompt = prompt,\n\t\t\tend = prompt + ReplxxTests._end_\n\t\t)\n\tdef test_long_line( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left><cr><c-d>\",\n\t\t\t\"<c9>ada clojure eiffel fortran groovy java kotlin modula perl python \"\n\t\t\t\"rust sql<rst><ceos><c2><u2><c9>ada clojure eiffel fortran groovy \"\n\t\t\t\"java kotlin modula perl python rust sql<rst><ceos><u1><c39><u1><c9>ada \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tprompt",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tprompt = prompt,\n\t\t\tend = prompt + ReplxxTests._end_\n\t\t)\n\tdef test_long_line( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left><cr><c-d>\",\n\t\t\t\"<c9>ada clojure eiffel fortran groovy java kotlin modula perl python \"\n\t\t\t\"rust sql<rst><ceos><c2><u2><c9>ada clojure eiffel fortran groovy \"\n\t\t\t\"java kotlin modula perl python rust sql<rst><ceos><u1><c39><u1><c9>ada \"\n\t\t\t\"clojure eiffel fortran groovy java kotlin modula perl python rust \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tend",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tend = prompt + ReplxxTests._end_\n\t\t)\n\tdef test_long_line( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left>~<c-left><cr><c-d>\",\n\t\t\t\"<c9>ada clojure eiffel fortran groovy java kotlin modula perl python \"\n\t\t\t\"rust sql<rst><ceos><c2><u2><c9>ada clojure eiffel fortran groovy \"\n\t\t\t\"java kotlin modula perl python rust sql<rst><ceos><u1><c39><u1><c9>ada \"\n\t\t\t\"clojure eiffel fortran groovy java kotlin modula perl python rust \"\n\t\t\t\"~sql<rst><ceos><u1><c40><c34><u1><c9>ada clojure \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 10, 40 )\n\t\t)\n\tdef test_colors( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><cr><c-d>\",\n\t\t\t\"<c9><black>color_black<rst> <red>color_red<rst> \"\n\t\t\t\"<green>color_green<rst> <brown>color_brown<rst> <blue>color_blue<rst> \"\n\t\t\t\"<magenta>color_magenta<rst> <cyan>color_cyan<rst> \"\n\t\t\t\"<lightgray>color_lightgray<rst> <gray>color_gray<rst> \"\n\t\t\t\"<brightred>color_brightred<rst> <brightgreen>color_brightgreen<rst> \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'w \\t-'\"\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<up><c-left>x<c-left><c-left>x<c-left><c-left>x<c-left><c-left>x<c-left><c-left>x<c-left><c-left>x<cr><c-d>\",\n\t\t\t\"<c9>one_two three-four five_six \"\n\t\t\t\"seven-eight<rst><ceos><c48><c9>one_two three-four five_six \"\n\t\t\t\"seven-eight<rst><ceos><c37><c9>one_two three-four five_six \"\n\t\t\t\"xseven-eight<rst><ceos><c38><c37><c33><c9>one_two three-four five_xsix \"\n\t\t\t\"xseven-eight<rst><ceos><c34><c33><c28><c9>one_two three-four xfive_xsix \"\n\t\t\t\"xseven-eight<rst><ceos><c29><c28><c17><c9>one_two xthree-four xfive_xsix \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 'w \\t_'\"\n\t\t)\n\tdef test_no_color( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up> X<cr><c-d>\",\n\t\t\t\"<c9>color_black color_red color_green color_brown color_blue \"\n\t\t\t\"color_magenta color_cyan color_lightgray color_gray color_brightred \"\n\t\t\t\"color_brightgreen color_yellow color_brightblue color_brightmagenta \"\n\t\t\t\"color_brightcyan color_white<ceos><c70><u2><c9>color_black color_red \"\n\t\t\t\"color_green color_brown color_blue color_magenta color_cyan color_lightgray \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = ReplxxTests._cSample_ + \" q1 m1\"\n\t\t)\n\tdef test_backspace_long_line_on_small_term( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<cr><cr><cr><up><backspace><backspace><backspace><backspace><backspace><backspace><backspace><backspace><cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9><ceos><c9>\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9><ceos><c9>\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> \"\n\t\t\t\"<c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c14><u1><c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c13><u1><c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c12><u1><c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c11><u1><c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c10><u1><c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c9><u1><c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c8><u1><c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c7><u1><c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c6><u1><c9>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<rst><ceos><c6>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 10, 40 )\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<cr><cr><cr><up><backspace><backspace><backspace><backspace><backspace><backspace><cr><c-d>\",\n\t\t\t\"<c9><ceos><c9>\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9><ceos><c9>\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9><ceos><c9>\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9>a qu ite lo ng li ne of sh ort wo rds wi \"\n\t\t\t\"ll te st cu rs or mo ve me nt<rst><ceos><c39><u1><c9>a qu ite lo \"\n\t\t\t\"ng li ne of sh ort wo rds wi ll te st cu rs or mo ve me \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 10, 40 )\n\t\t)\n\tdef test_reverse_history_search_on_max_match( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><c-r><cr><c-d>\",\n\t\t\t\"<c9>aaaaaaaaaaaaaaaaaaaaa<rst><ceos><c30><c1><ceos><c1><ceos>(reverse-i-search)`': \"\n\t\t\t\"aaaaaaaaaaaaaaaaaaaaa<c44><c1><ceos><brightgreen>replxx<rst>> \"\n\t\t\t\"aaaaaaaaaaaaaaaaaaaaa<c30><c9>aaaaaaaaaaaaaaaaaaaaa<rst><ceos><c30>\\r\\n\"\n\t\t\t\"aaaaaaaaaaaaaaaaaaaaa\\r\\n\",\n\t\t\t\"aaaaaaaaaaaaaaaaaaaaa\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tres",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tres = subprocess.run( [ ReplxxTests._cSample_, \"q1\" ], input = b\"replxx FTW!\\n\", stdout = subprocess.PIPE, stderr = subprocess.PIPE )\n\t\tself_.assertSequenceEqual( res.stdout, b\"starting...\\nreplxx FTW!\\n\\nExiting Replxx\\n\" )\n\tdef test_async_print( self_ ):\n\t\tself_.check_scenario(\n\t\t\t[ \"a\", \"b\", \"c\", \"d\", \"e\", \"f<cr><c-d>\" ], [\n\t\t\t\t\"<c1><ceos>0\\r\\n\"\n\t\t\t\t\"<brightgreen>replxx<rst>> \"\n\t\t\t\t\"<c9><ceos><c9><c9>a<rst><ceos><c10><c9>ab<rst><ceos><c11><c1><ceos>1\\r\\n\"\n\t\t\t\t\"<brightgreen>replxx<rst>> \"\n\t\t\t\t\"<c9>ab<rst><ceos><c11><c9>abc<rst><ceos><c12><c9>abcd<rst><ceos><c13><c1><ceos>2\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"m\" ],\n\t\t\tpause = 0.5\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t[ \"<up>\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f<cr><c-d>\" ], [\n\t\t\t\t\"<c1><ceos>0\\r\\n\"\n\t\t\t\t\"<brightgreen>replxx<rst>> <c9><ceos><c9><c9>a very long line of \"\n\t\t\t\t\"user input, wider then current terminal, the line is wrapped: \"\n\t\t\t\t\"<rst><ceos><c11><u2><c9>a very long line of user input, wider then current \"\n\t\t\t\t\"terminal, the line is wrapped: a<rst><ceos><c12><u2><c1><ceos>1\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tpause",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tpause = 0.5\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t[ \"<up>\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f<cr><c-d>\" ], [\n\t\t\t\t\"<c1><ceos>0\\r\\n\"\n\t\t\t\t\"<brightgreen>replxx<rst>> <c9><ceos><c9><c9>a very long line of \"\n\t\t\t\t\"user input, wider then current terminal, the line is wrapped: \"\n\t\t\t\t\"<rst><ceos><c11><u2><c9>a very long line of user input, wider then current \"\n\t\t\t\t\"terminal, the line is wrapped: a<rst><ceos><c12><u2><c1><ceos>1\\r\\n\"\n\t\t\t\t\"<brightgreen>replxx<rst>> \\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"m\" ],\n\t\t\tdimensions = ( 10, 40 ),\n\t\t\tpause = 0.5\n\t\t)\n\tdef test_async_emulate_key_press( self_ ):\n\t\tself_.check_scenario(\n\t\t\t[ \"a\", \"b\", \"c\", \"d\", \"e\", \"f<cr><c-d>\" ], [\n\t\t\t\t\"<c9><yellow>1<rst><ceos><c10><c9><yellow>1<rst>a\"\n\t\t\t\t\"<rst><ceos><c11><c9><yellow>1<rst>ab<rst><ceos><c12><c9><yellow>1<rst>ab\"\n\t\t\t\t\"<yellow>2<rst><ceos><c13><c9><yellow>1<rst>ab<yellow>2\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 10, 40 ),\n\t\t\tpause = 0.5\n\t\t)\n\tdef test_async_emulate_key_press( self_ ):\n\t\tself_.check_scenario(\n\t\t\t[ \"a\", \"b\", \"c\", \"d\", \"e\", \"f<cr><c-d>\" ], [\n\t\t\t\t\"<c9><yellow>1<rst><ceos><c10><c9><yellow>1<rst>a\"\n\t\t\t\t\"<rst><ceos><c11><c9><yellow>1<rst>ab<rst><ceos><c12><c9><yellow>1<rst>ab\"\n\t\t\t\t\"<yellow>2<rst><ceos><c13><c9><yellow>1<rst>ab<yellow>2\"\n\t\t\t\t\"<rst>c<rst><ceos><c14><c9><yellow>1<rst>ab<yellow>2\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tpause",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tpause = 0.5\n\t\t)\n\tdef test_async_emulate_key_press( self_ ):\n\t\tself_.check_scenario(\n\t\t\t[ \"a\", \"b\", \"c\", \"d\", \"e\", \"f<cr><c-d>\" ], [\n\t\t\t\t\"<c9><yellow>1<rst><ceos><c10><c9><yellow>1<rst>a\"\n\t\t\t\t\"<rst><ceos><c11><c9><yellow>1<rst>ab<rst><ceos><c12><c9><yellow>1<rst>ab\"\n\t\t\t\t\"<yellow>2<rst><ceos><c13><c9><yellow>1<rst>ab<yellow>2\"\n\t\t\t\t\"<rst>c<rst><ceos><c14><c9><yellow>1<rst>ab<yellow>2\"\n\t\t\t\t\"<rst>cd<rst><ceos><c15><c9><yellow>1<rst>ab<yellow>2<rst>cd<yellow>3\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"k123456\" ],\n\t\t\tpause = 0.5\n\t\t)\n\tdef test_special_keys( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<f1><f2><f3><f4><f5><f6><f7><f8><f9><f10><f11><f12>\"\n\t\t\t\"<s-f1><s-f2><s-f3><s-f4><s-f5><s-f6><s-f7><s-f8><s-f9><s-f10><s-f11><s-f12>\"\n\t\t\t\"<c-f1><c-f2><c-f3><c-f4><c-f5><c-f6><c-f7><c-f8><c-f9><c-f10><c-f11><c-f12>\"\n\t\t\t\"<s-tab><s-left><s-right><s-up><s-down>\"\n\t\t\t\"<s-home><s-end><c-home><c-end><c-pgup><c-pgdown>\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tpause",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tpause = 0.5\n\t\t)\n\tdef test_special_keys( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<f1><f2><f3><f4><f5><f6><f7><f8><f9><f10><f11><f12>\"\n\t\t\t\"<s-f1><s-f2><s-f3><s-f4><s-f5><s-f6><s-f7><s-f8><s-f9><s-f10><s-f11><s-f12>\"\n\t\t\t\"<c-f1><c-f2><c-f3><c-f4><c-f5><c-f6><c-f7><c-f8><c-f9><c-f10><c-f11><c-f12>\"\n\t\t\t\"<s-tab><s-left><s-right><s-up><s-down>\"\n\t\t\t\"<s-home><s-end><c-home><c-end><c-pgup><c-pgdown>\"\n\t\t\t\"<cr><c-d>\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"q1\", \"H200\" ]\n\t\t)\n\tdef test_complete_next( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><c-n><c-n><c-p><c-p><c-p><cr><c-d>\",\n\t\t\t\"<c9>color_<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>color_black<rst>\\r\\n\"\n\t\t\t\"        <gray>color_red<rst>\\r\\n\"\n\t\t\t\"        \"\n\t\t\t\"<gray>color_green<rst><u3><c15><c9><black>color_black<rst><ceos><c20>\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"xlc_ctype,lc_time,lc_messages,zoom\", \"I1\", \"q1\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"l<c-n><c-n><c-p><c-p><cr><c-d>\",\n\t\t\t\"<c9>l<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>lc_ctype<rst>\\r\\n\"\n\t\t\t\"        <gray>lc_time<rst>\\r\\n\"\n\t\t\t\"        <gray>lc_messages<rst><u3><c10><c9>lc_<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>lc_ctype<rst>\\r\\n\"\n\t\t\t\"        <gray>lc_time<rst>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"xlc_ctype,lc_time,lc_messages,zoom\", \"I0\", \"q1\" ]\n\t\t)\n\tdef test_disabled_handlers( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><left><backspace>4<cr><c-d>\",\n\t\t\t\"<c9>(+ 1 2)<rst><ceos><c16><c9><brightred>(<rst>+ 1 \"\n\t\t\t\"2)<rst><ceos><c15><c9><brightred>(<rst>+ 1 \"\n\t\t\t\")<rst><ceos><c14><c9><brightred>(<rst>+ 1 \"\n\t\t\t\"4)<rst><ceos><c15><c9><brightred>(<rst>+ 1 4)<rst><ceos><c16>\\r\\n\"\n\t\t\t\"thanks for the input: (+ 1 4)\\r\\n\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"N\", \"S\" ]\n\t\t)\n\tdef test_state_manipulation( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><f2>~<cr><c-d>\",\n\t\t\t\"<c9>replxx<rst><ceos><c15><c9>REPLXX<rst><ceos><c12><c9>REP~LXX<rst><ceos><c13><c9>REP~LXX<rst><ceos><c16>\\r\\n\"\n\t\t\t\"REP~LXX\\r\\n\",\n\t\t\t\"replxx\\n\",\n\t\t\tcommand = [ ReplxxTests._cSample_, \"q1\" ]\n\t\t)",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"q1\" ]\n\t\t)\n\tdef test_modify_callback( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><home><right><right>*<cr><c-d>\",\n\t\t\t\"<c9>abcd<brightmagenta>12<rst><ceos><c15><c9>abcd<brightmagenta>12<rst><ceos><c9>\"\n\t\t\t\"<c10><c11>\"\n\t\t\t\"<c9>ababcd<brightmagenta>12<rst>cd<brightmagenta>12<rst><ceos><c15>\"\n\t\t\t\"<c9>ababcd<brightmagenta>12<rst>cd<brightmagenta>12<rst><ceos><c21>\\r\\n\"\n\t\t\t\"ababcd12cd12\\r\\n\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"q1\", \"M1\" ]\n\t\t)\n\tdef test_paste( self_ ):\n\t\tself_.check_scenario(\n\t\t\trapid( \"abcdef<cr><c-d>\" ),\n\t\t\t\"<c9>a<rst><ceos><c10><c9>abcdef<rst><ceos><c15>\\r\\nabcdef\\r\\n\"\n\t\t)\n\tdef test_history_merge( self_ ):\n\t\twith open( \"replxx_history_alt.txt\", \"w\" ) as f:\n\t\t\tf.write(",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdata",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdata = f.read()\n\t\t\texpected = (\n\t\t\t\t\"### 0000-00-00 00:00:00.001\\n\"\n\t\t\t\t\"one\\n\"\n\t\t\t\t\"### 0000-00-00 00:00:00.002\\n\"\n\t\t\t\t\"two\\n\"\n\t\t\t\t\"### 0000-00-00 00:00:00.003\\n\"\n\t\t\t\t\"three\\n\"\n\t\t\t\t\"### 0000-00-00 00:00:00.004\\n\"\n\t\t\t\t\"four\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\texpected",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\texpected = (\n\t\t\t\t\"### 0000-00-00 00:00:00.001\\n\"\n\t\t\t\t\"one\\n\"\n\t\t\t\t\"### 0000-00-00 00:00:00.002\\n\"\n\t\t\t\t\"two\\n\"\n\t\t\t\t\"### 0000-00-00 00:00:00.003\\n\"\n\t\t\t\t\"three\\n\"\n\t\t\t\t\"### 0000-00-00 00:00:00.004\\n\"\n\t\t\t\t\"four\\n\"\n\t\t\t\t\"### 0000-00-00 00:00:00.008\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"q1\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"a0<paste-pfx>b1c2d3e<paste-sfx>4f<cr><c-d>\",\n\t\t\t\"<c9>a<rst><ceos><c10>\"\n\t\t\t\"<c9>a<brightmagenta>0<rst><ceos><c11>\"\n\t\t\t\"<c9>a<brightmagenta>0<rst>b<brightmagenta>1<rst>c<brightmagenta>2<rst>d<brightmagenta>3<rst>e<rst><ceos><c18>\"\n\t\t\t\"<c9>a<brightmagenta>0<rst>b<brightmagenta>1<rst>c<brightmagenta>2<rst>d<brightmagenta>3<rst>e<brightmagenta>4<rst><ceos><c19>\"\n\t\t\t\"<c9>a<brightmagenta>0<rst>b<brightmagenta>1<rst>c<brightmagenta>2<rst>d<brightmagenta>3<rst>e<brightmagenta>4<rst>f<rst><ceos><c20>\"\n\t\t\t\"<c9>a<brightmagenta>0<rst>b<brightmagenta>1<rst>c<brightmagenta>2<rst>d<brightmagenta>3<rst>e<brightmagenta>4<rst>f<rst><ceos><c20>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"q1\", \"B\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"a0<left><paste-pfx>/eb<paste-sfx><cr><paste-pfx>/db<paste-sfx><cr><paste-pfx>x<paste-sfx><cr><c-d>\",\n\t\t\t\"<c9>a<rst><ceos><c10><c9>a<brightmagenta>0<rst><ceos><c11><c9>a<brightmagenta>0<rst><ceos><c10>\"\n\t\t\t\"<c9>a/eb<brightmagenta>0<rst><ceos><c13><c9>a/eb<brightmagenta>0<rst><ceos><c14>\\r\\n\"\n\t\t\t\"a/eb0\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9>/db<rst><ceos><c12><c9>/db<rst><ceos><c12>\\r\\n\"\n\t\t\t\"/db\\r\\n\"\n\t\t\t\"<brightgreen>replxx<rst>> <c9>x<rst><ceos><c10><c9>x<rst><ceos><c10>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"q1\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<paste-pfx>aaa\\n\\tbbb<paste-sfx><backspace><backspace><backspace><backspace><backspace><backspace><backspace><backspace><cr><c-d>\",\n\t\t\t\"<c9><ceos><c18><paste-off>\\r\\n\",\n\t\t\tcommand = [ ReplxxTests._cxxSample_, \"B\" ]\n\t\t)\n\tdef test_embedded_newline( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><c-left><s-cr><cr><c-d>\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"B\" ]\n\t\t)\n\tdef test_embedded_newline( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><c-left><s-cr><cr><c-d>\",\n\t\t\t\"<c9><blue>color_blue<rst> \"\n\t\t\t\"<red>color_red<rst><ceos><c29><c9><blue>color_blue<rst> \"\n\t\t\t\"<red>color_red<rst><ceos><c20><c9><ceos><blue>color_blue<rst> \\r\\n\"\n\t\t\t\"<red>color_red<rst><c1><u1><c9><ceos><blue>color_blue<rst> \\r\\n\"\n\t\t\t\"<red>color_red<rst><c10>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"I\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<up><up><up><up>x<up><cr><c-d>\",\n\t\t\t\"<c9><ceos>bbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbbbbbbbbb<rst><c24><u3><c9><ceos>bbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbbbbbb\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"I\" ]\n\t\t)\n\tdef test_move_down_in_multiline( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<pgup><down><pgup><down> <cr><c-d>\",\n\t\t\t\"<c9>some other<rst><ceos><c19><c9><ceos><red>color_red<rst>\\r\\n\"\n\t\t\t\"<blue>color_blue<rst><c11><u1><c9><ceos><red>color_red<rst>\\r\\n\"\n\t\t\t\"<blue>color_blue<rst><u1><c9><d1><c9><u1><c9><ceos><red>color_red<rst>\\r\\n\"\n\t\t\t\"color_bl ue<rst><c10><u1><c9><ceos><red>color_red<rst>\\r\\n\"\n\t\t\t\"color_bl ue<rst><c12>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"I\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<pgup><pgup><down><down><down>x<down><cr><c-d>\",\n\t\t\t\"<c9><ceos>bbbbbbbbbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbb<rst><c17><u3><c9><ceos>bbbbbbbbbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbbbbbb\\r\\n\"\n\t\t\t\"bbbbbbbbbbbbbbbbbbbb\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"I\" ]\n\t\t)\n\tdef test_go_to_beginning_of_multiline_entry( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><pgup>x <pgup><pgup><cr><c-d>\",\n\t\t\t\"<c9><ceos><red>color_red<rst>\\r\\n\"\n\t\t\t\"<blue>color_blue<rst>\\r\\n\"\n\t\t\t\"zzzzzz<rst><c7><u2><c9><ceos><red>color_red<rst>\\r\\n\"\n\t\t\t\"<blue>color_blue<rst>\\r\\n\"\n\t\t\t\"zzzzzz<rst><u2><c9><c9><ceos>xcolor_red\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"I\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"<up><c-down><cr><c-d>\",\n\t\t\t\"<c9><ceos>some text\\r\\n\"\n\t\t\t\"not on start color_b<rst>\\r\\n\"\n\t\t\t\"             <gray>color_black<rst>\\r\\n\"\n\t\t\t\"             <gray>color_brown<rst>\\r\\n\"\n\t\t\t\"             <gray>color_blue<rst><u3><c21><u1><c9><ceos>some text\\r\\n\"\n\t\t\t\"not on start color_b<rst><gray>lack<rst>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"I\" ]\n\t\t)\n\tdef test_async_prompt( self_ ):\n\t\tself_.check_scenario(\n\t\t\t[ \"<up>\", \"r\", \"i\", \"g\", \"h\", \"t\", \"g<tab><cr><c-d>\" ], [\n\t\t\t\t\"<c1><ceos><brightgreen>replxx<rst>[-]> <c12><ceos><c12><c12>long line \"\n\t\t\t\t\"<green>color_green<rst> and color_b<rst><ceos>\\r\\n\"\n\t\t\t\t\"                                     <gray>color_black<rst>\\r\\n\"\n\t\t\t\t\"                                     <gray>color_brown<rst>\\r\\n\"\n\t\t\t\t\"                                     \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"F\" ],\n\t\t\tpause = 0.5\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t[ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g<tab><cr><c-d>\" ], [\n\t\t\t\t\"<c1><ceos>0\\r\\n\"\n\t\t\t\t\"<brightgreen>replxx<rst>[-]> \"\n\t\t\t\t\"<c12><ceos><c12><c1><ceos><brightgreen>replxx<rst>[-]> \"\n\t\t\t\t\"<c12><ceos><c12><c12>a<rst><ceos><c13><c1><ceos><brightgreen>replxx<rst>[\\\\]> \"\n\t\t\t\t\"<c12>a<rst><ceos><c13><c1><ceos><brightgreen>replxx<rst>[|]> \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tpause",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tpause = 0.5\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t[ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g<tab><cr><c-d>\" ], [\n\t\t\t\t\"<c1><ceos>0\\r\\n\"\n\t\t\t\t\"<brightgreen>replxx<rst>[-]> \"\n\t\t\t\t\"<c12><ceos><c12><c1><ceos><brightgreen>replxx<rst>[-]> \"\n\t\t\t\t\"<c12><ceos><c12><c12>a<rst><ceos><c13><c1><ceos><brightgreen>replxx<rst>[\\\\]> \"\n\t\t\t\t\"<c12>a<rst><ceos><c13><c1><ceos><brightgreen>replxx<rst>[|]> \"\n\t\t\t\t\"<c12>a<rst><ceos><c13><c12>ab<rst><ceos><c14><c1><ceos><brightgreen>replxx<rst>[/]> \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"m\", \"F\" ],\n\t\t\tpause = 0.5\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t[ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g<tab><cr><c-d>\" ], [\n\t\t\t\t\"<c1><ceos>0\\r\\n\"\n\t\t\t\t\"<brightgreen>replxx<rst>[-]> \"\n\t\t\t\t\"<c12><ceos><c12><c1><ceos><brightgreen>replxx<rst>[-]> \"\n\t\t\t\t\"<c12><ceos><c13><c12><yellow>1<rst><ceos><c13><c12><yellow>1<rst>a<rst><ceos><c14><c1><ceos><brightgreen>replxx<rst>[\\\\]> \"\n\t\t\t\t\"<c12><yellow>1<rst>a<rst><ceos><c14><c1><ceos><brightgreen>replxx<rst>[|]> \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tpause",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tpause = 0.5\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t[ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g<tab><cr><c-d>\" ], [\n\t\t\t\t\"<c1><ceos>0\\r\\n\"\n\t\t\t\t\"<brightgreen>replxx<rst>[-]> \"\n\t\t\t\t\"<c12><ceos><c12><c1><ceos><brightgreen>replxx<rst>[-]> \"\n\t\t\t\t\"<c12><ceos><c13><c12><yellow>1<rst><ceos><c13><c12><yellow>1<rst>a<rst><ceos><c14><c1><ceos><brightgreen>replxx<rst>[\\\\]> \"\n\t\t\t\t\"<c12><yellow>1<rst>a<rst><ceos><c14><c1><ceos><brightgreen>replxx<rst>[|]> \"\n\t\t\t\t\"<c12><yellow>1<rst>a<rst><ceos><c14><c12><yellow>1<rst>ab<rst><ceos><c15><c1><ceos><brightgreen>replxx<rst>[/]> \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"m\", \"F\", \"k123456\" ],\n\t\t\tpause = 0.487\n\t\t)\n\tdef test_prompt_from_callback( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up>ri<tab>b<tab><cr><c-d>\",\n\t\t\t\"<c9>some text color_b<rst><ceos>\\r\\n\"\n\t\t\t\"                  <gray>color_black<rst>\\r\\n\"\n\t\t\t\"                  <gray>color_brown<rst>\\r\\n\"\n\t\t\t\"                  \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tpause",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tpause = 0.487\n\t\t)\n\tdef test_prompt_from_callback( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up>ri<tab>b<tab><cr><c-d>\",\n\t\t\t\"<c9>some text color_b<rst><ceos>\\r\\n\"\n\t\t\t\"                  <gray>color_black<rst>\\r\\n\"\n\t\t\t\"                  <gray>color_brown<rst>\\r\\n\"\n\t\t\t\"                  \"\n\t\t\t\"<gray>color_blue<rst><u3><c26><c1><ceos><brightgreen>replxx<rst>[17]> \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"P\" ]\n\t\t)\n\tdef test_color_256( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up><cr><c-d>\",\n\t\t\t\"<c9>x <brown><bgcyan>c_3_6<rst> <color67>rgb123<rst> \"\n\t\t\t\"<color205><bgcolor78>fg513bg142<rst> <color253>gs21<rst> \"\n\t\t\t\"<color237>gs5<rst> <color251><bgcolor237>gs19gs5<rst> \"\n\t\t\t\"x<rst><ceos><c53><c9>x <brown><bgcyan>c_3_6<rst> \"\n\t\t\t\"<color67>rgb123<rst> <color205><bgcolor78>fg513bg142<rst> \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\tprompt",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\tprompt = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa> \"\n\t\tself_.check_scenario(\n\t\t\t\"<up><cr><c-d>\",\n\t\t\t\"<c40>co<rst><ceos>\\r\\n\"\n\t\t\t\"                                       <gray>color_black<rst>\\r\\n\"\n\t\t\t\"                                       <gray>color_red<rst>\\r\\n\"\n\t\t\t\"                                       \"\n\t\t\t\"<gray>color_green<rst><u3><c42><c40>co<rst><ceos><c42>\\r\\n\"\n\t\t\t\"co\\r\\n\",\n\t\t\t\"co\\n\",",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"I\", \"p\" + prompt ],\n\t\t\tdimensions = ( 24, 64 ),\n\t\t\tprompt = prompt\n\t\t)\n\tdef test_ignore_case_hints_completions( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"de<tab>e<tab><c-down><tab><cr><c-d>\",\n\t\t\t\"<c9>d<rst><ceos><c10><c9>de<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>determinANT<rst>\\r\\n\"\n\t\t\t\"        <gray>determiNATION<rst>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdimensions",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdimensions = ( 24, 64 ),\n\t\t\tprompt = prompt\n\t\t)\n\tdef test_ignore_case_hints_completions( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"de<tab>e<tab><c-down><tab><cr><c-d>\",\n\t\t\t\"<c9>d<rst><ceos><c10><c9>de<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>determinANT<rst>\\r\\n\"\n\t\t\t\"        <gray>determiNATION<rst>\\r\\n\"\n\t\t\t\"        <gray>deterMINE<rst><u3><c11><c9>determin<rst><ceos>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tprompt",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tprompt = prompt\n\t\t)\n\tdef test_ignore_case_hints_completions( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"de<tab>e<tab><c-down><tab><cr><c-d>\",\n\t\t\t\"<c9>d<rst><ceos><c10><c9>de<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>determinANT<rst>\\r\\n\"\n\t\t\t\"        <gray>determiNATION<rst>\\r\\n\"\n\t\t\t\"        <gray>deterMINE<rst><u3><c11><c9>determin<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>determinANT<rst>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"i\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"de<tab>e<tab>d<tab><cr><c-d>\",\n\t\t\t\"<c9>d<rst><ceos><c10><c9>de<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>determinANT<rst>\\r\\n\"\n\t\t\t\"        <gray>determiNATION<rst>\\r\\n\"\n\t\t\t\"        <gray>deterMINE<rst><u3><c11><c9>determin<rst><ceos>\\r\\n\"\n\t\t\t\"        <gray>determinANT<rst>\\r\\n\"\n\t\t\t\"        <gray>determiNATION<rst>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cxxSample_, \"i\" ]\n\t\t)\n\tdef test_ignore_case_history_search( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<c-r>er<backspace>R<cr><c-d>\",\n\t\t\t\"<c1><ceos><c1><ceos>(reverse-i-search)`': \"\n\t\t\t\"<c23><c1><ceos>(reverse-i-search)`e': \"\n\t\t\t\"determinANT<c27><c1><ceos>(reverse-i-search)`er': \"\n\t\t\t\"determinANT<c28><c1><ceos>(reverse-i-search)`e': \"\n\t\t\t\"determinANT<c27><c1><ceos>(reverse-i-search)`eR': \"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"i1\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"deter<m-p><cr><c-d>\",\n\t\t\t\"<c9>d<rst><ceos><gray>b<rst><c10><c9>de<rst><ceos><c11><c9>det<rst><ceos><c12><c9>dete<rst><ceos><c13><c9>deter<rst><ceos><c14><c9>determinANT<rst><ceos><c20><c9>determinANT<rst><ceos><c20>\\r\\n\"\n\t\t\t\"thanks for the input: determinANT\\r\\n\",\n\t\t\t\"deTERMINED\\ndetERMINISTIC\\ndeteRMINISM\\ndeterMINE\\ndetermiNATION\\ndeterminANT\\n\",\n\t\t\tcommand = [ ReplxxTests._cSample_, \"i1\" ]\n\t\t)\n\t\tself_.check_scenario(",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"i1\" ]\n\t\t)\n\t\tself_.check_scenario(\n\t\t\t\"deteR<m-p><cr><c-d>\",\n\t\t\t\"<c9>d<rst><ceos><gray>b<rst><c10><c9>de<rst><ceos><c11><c9>det<rst><ceos><c12><c9>dete<rst><ceos><c13><c9>deteR<rst><ceos><c14><c9>deteRMINISM<rst><ceos><c20><c9>deteRMINISM<rst><ceos><c20>\\r\\n\"\n\t\t\t\"thanks for the input: deteRMINISM\\r\\n\",\n\t\t\t\"deTERMINED\\ndetERMINISTIC\\ndeteRMINISM\\ndeterMINE\\ndetermiNATION\\ndeterminANT\\n\",\n\t\t\tcommand = [ ReplxxTests._cSample_, \"i1\" ]\n\t\t)\n\tdef test_history_scratch( self_ ):",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"i1\" ]\n\t\t)\n\tdef test_history_scratch( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"<up>x<up>y<up>z<down><up>Z<pgdown><up><pgup><cr><c-d>\",\n\t\t\t\"<c9>three<rst><ceos><c14><c9>threex<rst><ceos><c15>\"\n\t\t\t\"<c9>two<rst><ceos><c12><c9>twoy<rst><ceos><c13>\"\n\t\t\t\"<c9>one<rst><ceos><c12><c9>onez<rst><ceos><c13>\"\n\t\t\t\"<c9>twoy<rst><ceos><c13><c9>onez<rst><ceos><c13>\"\n\t\t\t\"<c9>onezZ<rst><ceos><c14><c9><rst><ceos><c9>\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tdata",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tdata = f.read().decode()\n\t\t\torigHist = \"### 0000-00-00 00:00:00.000\\none\\n### 0000-00-00 00:00:00.000\\ntwo\\n### 0000-00-00 00:00:00.000\\nthree\\n\";\n\t\t\tself_.assertSequenceEqual( data[:len(origHist)], origHist )\n\t\t\tself_.assertSequenceEqual( data[-6:], \"onezZ\\n\" )\n\t\tself_.check_scenario(\n\t\t\t\"<up>x<up>y<up>z<down><c-g><up><down><cr><c-d>\",\n\t\t\t\"<c9>three<rst><ceos><c14><c9>threex<rst><ceos><c15>\"\n\t\t\t\"<c9>two<rst><ceos><c12><c9>twoy<rst><ceos><c13>\"\n\t\t\t\"<c9>one<rst><ceos><c12><c9>onez<rst><ceos><c13>\"\n\t\t\t\"<c9>twoy<rst><ceos><c13><c9>two<rst><ceos><c12>\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\torigHist",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\torigHist = \"### 0000-00-00 00:00:00.000\\none\\n### 0000-00-00 00:00:00.000\\ntwo\\n### 0000-00-00 00:00:00.000\\nthree\\n\";\n\t\t\tself_.assertSequenceEqual( data[:len(origHist)], origHist )\n\t\t\tself_.assertSequenceEqual( data[-6:], \"onezZ\\n\" )\n\t\tself_.check_scenario(\n\t\t\t\"<up>x<up>y<up>z<down><c-g><up><down><cr><c-d>\",\n\t\t\t\"<c9>three<rst><ceos><c14><c9>threex<rst><ceos><c15>\"\n\t\t\t\"<c9>two<rst><ceos><c12><c9>twoy<rst><ceos><c13>\"\n\t\t\t\"<c9>one<rst><ceos><c12><c9>onez<rst><ceos><c13>\"\n\t\t\t\"<c9>twoy<rst><ceos><c13><c9>two<rst><ceos><c12>\"\n\t\t\t\"<c9>onez<rst><ceos><c13><c9>two<rst><ceos><c12>\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\t\t\tcommand",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\t\t\tcommand = [ ReplxxTests._cSample_, \"m\", \"N\", \"S\", \"C\", \"M0\" ]\n\t\t)\n\tdef test_seeded_incremental_history_search( self_ ):\n\t\tself_.check_scenario(\n\t\t\t\"for<m-r><m-r><cr><c-d>\",\n\t\t\t\"<c9>f<rst><ceos><c10><c9>fo<rst><ceos><c11><c9>for<rst><ceos><c12><c1><ceos><c1><ceos>(reverse-i-search)`for': \"\n\t\t\t\"for<c29><c1><ceos>(reverse-i-search)`for': \"\n\t\t\t\"forth<c26><c1><ceos>(reverse-i-search)`for': \"\n\t\t\t\"fortran<c26><c1><ceos><brightgreen>replxx<rst>> \"\n\t\t\t\"fortran<c9><c9>fortran<rst><ceos><c9><c9>fortran<rst><ceos><c16>\\r\\n\"",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\tres",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\tres = func( self, argv )\n\tverbosity = self.verbosity\n\treturn res\nif __name__ == \"__main__\":\n\tpa = unittest.TestProgram.parseArgs\n\tunittest.TestProgram.parseArgs = lambda self, argv: parseArgs( self, pa, argv )\n\tunittest.main()",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\tverbosity",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\tverbosity = self.verbosity\n\treturn res\nif __name__ == \"__main__\":\n\tpa = unittest.TestProgram.parseArgs\n\tunittest.TestProgram.parseArgs = lambda self, argv: parseArgs( self, pa, argv )\n\tunittest.main()",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\tpa",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\tpa = unittest.TestProgram.parseArgs\n\tunittest.TestProgram.parseArgs = lambda self, argv: parseArgs( self, pa, argv )\n\tunittest.main()",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "\tunittest.TestProgram.parseArgs",
        "kind": 5,
        "importPath": "third-party.replxx.tests",
        "description": "third-party.replxx.tests",
        "peekOfCode": "\tunittest.TestProgram.parseArgs = lambda self, argv: parseArgs( self, pa, argv )\n\tunittest.main()",
        "detail": "third-party.replxx.tests",
        "documentation": {}
    },
    {
        "label": "ExitStatus",
        "kind": 6,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "class ExitStatus:\n    SUCCESS = 0\n    DIFF = 1\n    TROUBLE = 2\ndef excludes_from_file(ignore_file):\n    excludes = []\n    try:\n        with io.open(ignore_file, 'r', encoding='utf-8') as f:\n            for line in f:\n                if line.startswith('#'):",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "DiffError",
        "kind": 6,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "class DiffError(Exception):\n    def __init__(self, message, errs=None):\n        super(DiffError, self).__init__(message)\n        self.errs = errs or []\nclass UnexpectedError(Exception):\n    def __init__(self, message, exc=None):\n        super(UnexpectedError, self).__init__(message)\n        self.formatted_traceback = traceback.format_exc()\n        self.exc = exc\ndef run_clang_format_diff_wrapper(args, file):",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "UnexpectedError",
        "kind": 6,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "class UnexpectedError(Exception):\n    def __init__(self, message, exc=None):\n        super(UnexpectedError, self).__init__(message)\n        self.formatted_traceback = traceback.format_exc()\n        self.exc = exc\ndef run_clang_format_diff_wrapper(args, file):\n    try:\n        ret = run_clang_format_diff(args, file)\n        return ret\n    except DiffError:",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "excludes_from_file",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def excludes_from_file(ignore_file):\n    excludes = []\n    try:\n        with io.open(ignore_file, 'r', encoding='utf-8') as f:\n            for line in f:\n                if line.startswith('#'):\n                    # ignore comments\n                    continue\n                pattern = line.rstrip()\n                if not pattern:",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "list_files",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def list_files(files, recursive=False, extensions=None, exclude=None):\n    if extensions is None:\n        extensions = []\n    if exclude is None:\n        exclude = []\n    out = []\n    for file in files:\n        if recursive and os.path.isdir(file):\n            for dirpath, dnames, fnames in os.walk(file):\n                fpaths = [os.path.join(dirpath, fname) for fname in fnames]",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "make_diff",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def make_diff(file, original, reformatted):\n    return list(\n        difflib.unified_diff(\n            original,\n            reformatted,\n            fromfile='{}\\t(original)'.format(file),\n            tofile='{}\\t(reformatted)'.format(file),\n            n=3))\nclass DiffError(Exception):\n    def __init__(self, message, errs=None):",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "run_clang_format_diff_wrapper",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def run_clang_format_diff_wrapper(args, file):\n    try:\n        ret = run_clang_format_diff(args, file)\n        return ret\n    except DiffError:\n        raise\n    except Exception as e:\n        raise UnexpectedError('{}: {}: {}'.format(file, e.__class__.__name__,\n                                                  e), e)\ndef run_clang_format_diff(args, file):",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "run_clang_format_diff",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def run_clang_format_diff(args, file):\n    try:\n        with io.open(file, 'r', encoding='utf-8') as f:\n            original = f.readlines()\n    except IOError as exc:\n        raise DiffError(str(exc))\n    if args.in_place:\n        invocation = [args.clang_format_executable, '-i', file]\n    else:\n        invocation = [args.clang_format_executable, file]",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "bold_red",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def bold_red(s):\n    return '\\x1b[1m\\x1b[31m' + s + '\\x1b[0m'\ndef colorize(diff_lines):\n    def bold(s):\n        return '\\x1b[1m' + s + '\\x1b[0m'\n    def cyan(s):\n        return '\\x1b[36m' + s + '\\x1b[0m'\n    def green(s):\n        return '\\x1b[32m' + s + '\\x1b[0m'\n    def red(s):",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "colorize",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def colorize(diff_lines):\n    def bold(s):\n        return '\\x1b[1m' + s + '\\x1b[0m'\n    def cyan(s):\n        return '\\x1b[36m' + s + '\\x1b[0m'\n    def green(s):\n        return '\\x1b[32m' + s + '\\x1b[0m'\n    def red(s):\n        return '\\x1b[31m' + s + '\\x1b[0m'\n    for line in diff_lines:",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "print_diff",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def print_diff(diff_lines, use_color):\n    if use_color:\n        diff_lines = colorize(diff_lines)\n    if sys.version_info[0] < 3:\n        sys.stdout.writelines((l.encode('utf-8') for l in diff_lines))\n    else:\n        sys.stdout.writelines(diff_lines)\ndef print_trouble(prog, message, use_colors):\n    error_text = 'error:'\n    if use_colors:",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "print_trouble",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def print_trouble(prog, message, use_colors):\n    error_text = 'error:'\n    if use_colors:\n        error_text = bold_red(error_text)\n    print(\"{}: {} {}\".format(prog, error_text, message), file=sys.stderr)\ndef main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        '--clang-format-executable',\n        metavar='EXECUTABLE',",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        '--clang-format-executable',\n        metavar='EXECUTABLE',\n        help='path to the clang-format executable',\n        default='clang-format')\n    parser.add_argument(\n        '--extensions',\n        help='comma separated list of file extensions (default: {})'.format(",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "DEFAULT_EXTENSIONS",
        "kind": 5,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "DEFAULT_EXTENSIONS = 'c,h,C,H,cpp,hpp,cc,hh,c++,h++,cxx,hxx'\nDEFAULT_CLANG_FORMAT_IGNORE = '.clang-format-ignore'\nclass ExitStatus:\n    SUCCESS = 0\n    DIFF = 1\n    TROUBLE = 2\ndef excludes_from_file(ignore_file):\n    excludes = []\n    try:\n        with io.open(ignore_file, 'r', encoding='utf-8') as f:",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CLANG_FORMAT_IGNORE",
        "kind": 5,
        "importPath": "third-party.run-clang-format.run-clang-format",
        "description": "third-party.run-clang-format.run-clang-format",
        "peekOfCode": "DEFAULT_CLANG_FORMAT_IGNORE = '.clang-format-ignore'\nclass ExitStatus:\n    SUCCESS = 0\n    DIFF = 1\n    TROUBLE = 2\ndef excludes_from_file(ignore_file):\n    excludes = []\n    try:\n        with io.open(ignore_file, 'r', encoding='utf-8') as f:\n            for line in f:",
        "detail": "third-party.run-clang-format.run-clang-format",
        "documentation": {}
    },
    {
        "label": "find_compilation_database",
        "kind": 2,
        "importPath": "third-party.run-clang-tidy.run-clang-tidy",
        "description": "third-party.run-clang-tidy.run-clang-tidy",
        "peekOfCode": "def find_compilation_database(path):\n  \"\"\"Adjusts the directory until a compilation database is found.\"\"\"\n  result = './'\n  while not os.path.isfile(os.path.join(result, path)):\n    if os.path.realpath(result) == '/':\n      print('Error: could not find compilation database.')\n      sys.exit(1)\n    result += '../'\n  return os.path.realpath(result)\ndef make_absolute(f, directory):",
        "detail": "third-party.run-clang-tidy.run-clang-tidy",
        "documentation": {}
    },
    {
        "label": "make_absolute",
        "kind": 2,
        "importPath": "third-party.run-clang-tidy.run-clang-tidy",
        "description": "third-party.run-clang-tidy.run-clang-tidy",
        "peekOfCode": "def make_absolute(f, directory):\n  if os.path.isabs(f):\n    return f\n  return os.path.normpath(os.path.join(directory, f))\ndef get_tidy_invocation(f, clang_tidy_binary, checks, tmpdir, build_path,\n                        header_filter, extra_arg, extra_arg_before, quiet,\n                        config):\n  \"\"\"Gets a command line for clang-tidy.\"\"\"\n  start = [clang_tidy_binary]\n  if header_filter is not None:",
        "detail": "third-party.run-clang-tidy.run-clang-tidy",
        "documentation": {}
    },
    {
        "label": "get_tidy_invocation",
        "kind": 2,
        "importPath": "third-party.run-clang-tidy.run-clang-tidy",
        "description": "third-party.run-clang-tidy.run-clang-tidy",
        "peekOfCode": "def get_tidy_invocation(f, clang_tidy_binary, checks, tmpdir, build_path,\n                        header_filter, extra_arg, extra_arg_before, quiet,\n                        config):\n  \"\"\"Gets a command line for clang-tidy.\"\"\"\n  start = [clang_tidy_binary]\n  if header_filter is not None:\n    start.append('-header-filter=' + header_filter)\n  else:\n    # Show warnings in all in-project headers by default.\n    start.append('-header-filter=^' + build_path + '/.*')",
        "detail": "third-party.run-clang-tidy.run-clang-tidy",
        "documentation": {}
    },
    {
        "label": "merge_replacement_files",
        "kind": 2,
        "importPath": "third-party.run-clang-tidy.run-clang-tidy",
        "description": "third-party.run-clang-tidy.run-clang-tidy",
        "peekOfCode": "def merge_replacement_files(tmpdir, mergefile):\n  \"\"\"Merge all replacement files in a directory into a single file\"\"\"\n  # The fixes suggested by clang-tidy >= 4.0.0 are given under\n  # the top level key 'Diagnostics' in the output yaml files\n  mergekey=\"Diagnostics\"\n  merged=[]\n  for replacefile in glob.iglob(os.path.join(tmpdir, '*.yaml')):\n    content = yaml.safe_load(open(replacefile, 'r'))\n    if not content:\n      continue # Skip empty files.",
        "detail": "third-party.run-clang-tidy.run-clang-tidy",
        "documentation": {}
    },
    {
        "label": "check_clang_apply_replacements_binary",
        "kind": 2,
        "importPath": "third-party.run-clang-tidy.run-clang-tidy",
        "description": "third-party.run-clang-tidy.run-clang-tidy",
        "peekOfCode": "def check_clang_apply_replacements_binary(args):\n  \"\"\"Checks if invoking supplied clang-apply-replacements binary works.\"\"\"\n  try:\n    subprocess.check_call([args.clang_apply_replacements_binary, '--version'])\n  except:\n    print('Unable to run clang-apply-replacements. Is clang-apply-replacements '\n          'binary correctly specified?', file=sys.stderr)\n    traceback.print_exc()\n    sys.exit(1)\ndef apply_fixes(args, tmpdir):",
        "detail": "third-party.run-clang-tidy.run-clang-tidy",
        "documentation": {}
    },
    {
        "label": "apply_fixes",
        "kind": 2,
        "importPath": "third-party.run-clang-tidy.run-clang-tidy",
        "description": "third-party.run-clang-tidy.run-clang-tidy",
        "peekOfCode": "def apply_fixes(args, tmpdir):\n  \"\"\"Calls clang-apply-fixes on a given directory.\"\"\"\n  invocation = [args.clang_apply_replacements_binary]\n  if args.format:\n    invocation.append('-format')\n  if args.style:\n    invocation.append('-style=' + args.style)\n  invocation.append(tmpdir)\n  subprocess.call(invocation)\ndef run_tidy(args, tmpdir, build_path, queue, failed_files):",
        "detail": "third-party.run-clang-tidy.run-clang-tidy",
        "documentation": {}
    },
    {
        "label": "run_tidy",
        "kind": 2,
        "importPath": "third-party.run-clang-tidy.run-clang-tidy",
        "description": "third-party.run-clang-tidy.run-clang-tidy",
        "peekOfCode": "def run_tidy(args, tmpdir, build_path, queue, failed_files):\n  \"\"\"Takes filenames out of queue and runs clang-tidy on them.\"\"\"\n  while True:\n    name = queue.get()\n    invocation = get_tidy_invocation(name, args.clang_tidy_binary, args.checks,\n                                     tmpdir, build_path, args.header_filter,\n                                     args.extra_arg, args.extra_arg_before,\n                                     args.quiet, args.config)\n    sys.stdout.write(' '.join(invocation) + '\\n')\n    return_code = subprocess.call(invocation)",
        "detail": "third-party.run-clang-tidy.run-clang-tidy",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "third-party.run-clang-tidy.run-clang-tidy",
        "description": "third-party.run-clang-tidy.run-clang-tidy",
        "peekOfCode": "def main():\n  parser = argparse.ArgumentParser(description='Runs clang-tidy over all files '\n                                   'in a compilation database. Requires '\n                                   'clang-tidy and clang-apply-replacements in '\n                                   '$PATH.')\n  parser.add_argument('-clang-tidy-binary', metavar='PATH',\n                      default='clang-tidy',\n                      help='path to clang-tidy binary')\n  parser.add_argument('-clang-apply-replacements-binary', metavar='PATH',\n                      default='clang-apply-replacements',",
        "detail": "third-party.run-clang-tidy.run-clang-tidy",
        "documentation": {}
    },
    {
        "label": "is_py2",
        "kind": 5,
        "importPath": "third-party.run-clang-tidy.run-clang-tidy",
        "description": "third-party.run-clang-tidy.run-clang-tidy",
        "peekOfCode": "is_py2 = sys.version[0] == '2'\nif is_py2:\n    import Queue as queue\nelse:\n    import queue as queue\ndef find_compilation_database(path):\n  \"\"\"Adjusts the directory until a compilation database is found.\"\"\"\n  result = './'\n  while not os.path.isfile(os.path.join(result, path)):\n    if os.path.realpath(result) == '/':",
        "detail": "third-party.run-clang-tidy.run-clang-tidy",
        "documentation": {}
    },
    {
        "label": "find_element",
        "kind": 2,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "def find_element(prefix, bindings):\n    i=0\n    for element in bindings:\n        if element.startswith(prefix):\n            return i\n        i=(i + 1)\n    return -1\ndef save_controller(line):\n    global controllers\n    match = split_pattern.match(line)",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "save_controller",
        "kind": 2,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "def save_controller(line):\n    global controllers\n    match = split_pattern.match(line)\n    entry = [ match.group(1), match.group(2), match.group(3) ]\n    bindings = sorted(match.group(4).split(\",\"))\n    if (bindings[0] == \"\"):\n        bindings.pop(0)\n    name = entry[2].rstrip(',')\n    crc = \"\"\n    pos = find_element(\"crc:\", bindings)",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "write_controllers",
        "kind": 2,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "def write_controllers():\n    global controllers\n    global controller_guids\n    # Check for duplicates\n    for entry in controllers:\n        entry_id = entry[1] + entry[3]\n        if (entry_id in controller_guids and entry_id not in conditionals):\n            current_name = entry[2]\n            existing_name = controller_guids[entry_id][2]\n            print(\"Warning: entry '%s' is duplicate of entry '%s'\" % (current_name, existing_name))",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "filename",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "filename = \"SDL_gamecontrollerdb.h\"\ninput = open(filename)\noutput = open(f\"{filename}.new\", \"w\")\nparsing_controllers = False\ncontrollers = []\ncontroller_guids = {}\nconditionals = []\nsplit_pattern = re.compile(r'([^\"]*\")([^,]*,)([^,]*,)([^\"]*)(\".*)')\n#                                     BUS (1)         CRC (3,2)                       VID (5,4)                       (6)   PID (8,7)                       (9)   VERSION (11,10)                 MISC (12)\nstandard_guid_pattern = re.compile(r'^([0-9a-fA-F]{4})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{4},)$')",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "input = open(filename)\noutput = open(f\"{filename}.new\", \"w\")\nparsing_controllers = False\ncontrollers = []\ncontroller_guids = {}\nconditionals = []\nsplit_pattern = re.compile(r'([^\"]*\")([^,]*,)([^,]*,)([^\"]*)(\".*)')\n#                                     BUS (1)         CRC (3,2)                       VID (5,4)                       (6)   PID (8,7)                       (9)   VERSION (11,10)                 MISC (12)\nstandard_guid_pattern = re.compile(r'^([0-9a-fA-F]{4})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{4},)$')\n# These chipsets are used in multiple controllers with different mappings,",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "output = open(f\"{filename}.new\", \"w\")\nparsing_controllers = False\ncontrollers = []\ncontroller_guids = {}\nconditionals = []\nsplit_pattern = re.compile(r'([^\"]*\")([^,]*,)([^,]*,)([^\"]*)(\".*)')\n#                                     BUS (1)         CRC (3,2)                       VID (5,4)                       (6)   PID (8,7)                       (9)   VERSION (11,10)                 MISC (12)\nstandard_guid_pattern = re.compile(r'^([0-9a-fA-F]{4})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{4},)$')\n# These chipsets are used in multiple controllers with different mappings,\n# without enough unique information to differentiate them. e.g.",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "parsing_controllers",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "parsing_controllers = False\ncontrollers = []\ncontroller_guids = {}\nconditionals = []\nsplit_pattern = re.compile(r'([^\"]*\")([^,]*,)([^,]*,)([^\"]*)(\".*)')\n#                                     BUS (1)         CRC (3,2)                       VID (5,4)                       (6)   PID (8,7)                       (9)   VERSION (11,10)                 MISC (12)\nstandard_guid_pattern = re.compile(r'^([0-9a-fA-F]{4})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{4},)$')\n# These chipsets are used in multiple controllers with different mappings,\n# without enough unique information to differentiate them. e.g.\n# https://github.com/gabomdq/SDL_GameControllerDB/issues/202",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "controllers",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "controllers = []\ncontroller_guids = {}\nconditionals = []\nsplit_pattern = re.compile(r'([^\"]*\")([^,]*,)([^,]*,)([^\"]*)(\".*)')\n#                                     BUS (1)         CRC (3,2)                       VID (5,4)                       (6)   PID (8,7)                       (9)   VERSION (11,10)                 MISC (12)\nstandard_guid_pattern = re.compile(r'^([0-9a-fA-F]{4})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{4},)$')\n# These chipsets are used in multiple controllers with different mappings,\n# without enough unique information to differentiate them. e.g.\n# https://github.com/gabomdq/SDL_GameControllerDB/issues/202\ninvalid_controllers = (",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "controller_guids",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "controller_guids = {}\nconditionals = []\nsplit_pattern = re.compile(r'([^\"]*\")([^,]*,)([^,]*,)([^\"]*)(\".*)')\n#                                     BUS (1)         CRC (3,2)                       VID (5,4)                       (6)   PID (8,7)                       (9)   VERSION (11,10)                 MISC (12)\nstandard_guid_pattern = re.compile(r'^([0-9a-fA-F]{4})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{4},)$')\n# These chipsets are used in multiple controllers with different mappings,\n# without enough unique information to differentiate them. e.g.\n# https://github.com/gabomdq/SDL_GameControllerDB/issues/202\ninvalid_controllers = (\n    ('0079', '0006', '0000'), # DragonRise Inc. Generic USB Joystick",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "conditionals",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "conditionals = []\nsplit_pattern = re.compile(r'([^\"]*\")([^,]*,)([^,]*,)([^\"]*)(\".*)')\n#                                     BUS (1)         CRC (3,2)                       VID (5,4)                       (6)   PID (8,7)                       (9)   VERSION (11,10)                 MISC (12)\nstandard_guid_pattern = re.compile(r'^([0-9a-fA-F]{4})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{4},)$')\n# These chipsets are used in multiple controllers with different mappings,\n# without enough unique information to differentiate them. e.g.\n# https://github.com/gabomdq/SDL_GameControllerDB/issues/202\ninvalid_controllers = (\n    ('0079', '0006', '0000'), # DragonRise Inc. Generic USB Joystick\n    ('0079', '0006', '6120'), # DragonRise Inc. Generic USB Joystick",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "split_pattern",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "split_pattern = re.compile(r'([^\"]*\")([^,]*,)([^,]*,)([^\"]*)(\".*)')\n#                                     BUS (1)         CRC (3,2)                       VID (5,4)                       (6)   PID (8,7)                       (9)   VERSION (11,10)                 MISC (12)\nstandard_guid_pattern = re.compile(r'^([0-9a-fA-F]{4})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{4},)$')\n# These chipsets are used in multiple controllers with different mappings,\n# without enough unique information to differentiate them. e.g.\n# https://github.com/gabomdq/SDL_GameControllerDB/issues/202\ninvalid_controllers = (\n    ('0079', '0006', '0000'), # DragonRise Inc. Generic USB Joystick\n    ('0079', '0006', '6120'), # DragonRise Inc. Generic USB Joystick\n    ('04b4', '2412', 'c529'), # Flydigi Vader 2, Vader 2 Pro, Apex 2, Apex 3",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "standard_guid_pattern",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "standard_guid_pattern = re.compile(r'^([0-9a-fA-F]{4})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})(0000)([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{4},)$')\n# These chipsets are used in multiple controllers with different mappings,\n# without enough unique information to differentiate them. e.g.\n# https://github.com/gabomdq/SDL_GameControllerDB/issues/202\ninvalid_controllers = (\n    ('0079', '0006', '0000'), # DragonRise Inc. Generic USB Joystick\n    ('0079', '0006', '6120'), # DragonRise Inc. Generic USB Joystick\n    ('04b4', '2412', 'c529'), # Flydigi Vader 2, Vader 2 Pro, Apex 2, Apex 3\n    ('16c0', '05e1', '0000'), # Xinmotek Controller\n)",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "invalid_controllers",
        "kind": 5,
        "importPath": "third-party.SDL.src.joystick.sort_controllers",
        "description": "third-party.SDL.src.joystick.sort_controllers",
        "peekOfCode": "invalid_controllers = (\n    ('0079', '0006', '0000'), # DragonRise Inc. Generic USB Joystick\n    ('0079', '0006', '6120'), # DragonRise Inc. Generic USB Joystick\n    ('04b4', '2412', 'c529'), # Flydigi Vader 2, Vader 2 Pro, Apex 2, Apex 3\n    ('16c0', '05e1', '0000'), # Xinmotek Controller\n)\ndef find_element(prefix, bindings):\n    i=0\n    for element in bindings:\n        if element.startswith(prefix):",
        "detail": "third-party.SDL.src.joystick.sort_controllers",
        "documentation": {}
    },
    {
        "label": "Build",
        "kind": 6,
        "importPath": "third-party.tree-sitter.tree-sitter.cli.src.generate.templates.setup",
        "description": "third-party.tree-sitter.tree-sitter.cli.src.generate.templates.setup",
        "peekOfCode": "class Build(build):\n    def run(self):\n        if isdir(\"queries\"):\n            dest = join(self.build_lib, \"tree_sitter_PARSER_NAME\", \"queries\")\n            self.copy_tree(\"queries\", dest)\n        super().run()\nclass BdistWheel(bdist_wheel):\n    def get_tag(self):\n        python, abi, platform = super().get_tag()\n        if python.startswith(\"cp\"):",
        "detail": "third-party.tree-sitter.tree-sitter.cli.src.generate.templates.setup",
        "documentation": {}
    },
    {
        "label": "BdistWheel",
        "kind": 6,
        "importPath": "third-party.tree-sitter.tree-sitter.cli.src.generate.templates.setup",
        "description": "third-party.tree-sitter.tree-sitter.cli.src.generate.templates.setup",
        "peekOfCode": "class BdistWheel(bdist_wheel):\n    def get_tag(self):\n        python, abi, platform = super().get_tag()\n        if python.startswith(\"cp\"):\n            python, abi = \"cp38\", \"abi3\"\n        return python, abi, platform\nsetup(\n    packages=find_packages(\"bindings/python\"),\n    package_dir={\"\": \"bindings/python\"},\n    package_data={",
        "detail": "third-party.tree-sitter.tree-sitter.cli.src.generate.templates.setup",
        "documentation": {}
    },
    {
        "label": "StatList",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class StatList:\n    def __init__(self,l,desc):\n        cnt = len(l)\n        assert(cnt > 1)\n        l.sort()\n        self.cnt    = cnt\n        self.l      = l\n        self.total  = SumList(l)\n        self.mean   = self.total / float(self.cnt)\n        self.s      = math.sqrt(SumList([(x-self.mean) * ",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "TimedTest",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class TimedTest:\n    def __init__(self, target, source, runnable,\n                 skip_trials = SKIP_TRIALS,\n                 min_trials = MIN_TRIALS,\n                 max_trials = MAX_TRIALS,\n                 min_stddev_pct = MIN_STDDEV_PCT):\n        self.target = target\n        self.source = source\n        self.runnable = runnable\n        self.skip_trials = skip_trials",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "Xdelta3RunClass",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class Xdelta3RunClass:\n    def __init__(self, extra):\n        self.extra = extra\n    #end\n    def __str__(self):\n        return ' '.join(self.extra)\n    #end\n    def New(self):\n        return Xdelta3Runner(self.extra)\n    #end",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "Xdelta3Runner",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class Xdelta3Runner:\n    # Use \"forkexec\" to get special command-line only features like\n    # external compression support.\n    def __init__(self, extra, forkexec=False):\n        self.forkexec = forkexec\n        self.extra = extra\n    #end\n    def Encode(self, target, source, output):\n        args = (ALL_ARGS +\n                self.extra +",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "Xdelta3Mod1",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class Xdelta3Mod1:\n    def __init__(self, file):\n        self.target_data = open(file, 'r').read()\n    #end\n    def Encode(self, ignore1, ignore2, ignore3):\n        r1, encoded = xdelta3.xd3_encode_memory(self.target_data, None, 1000000, 1<<10)\n        if r1 != 0:\n            raise CommandError('memory', 'encode failed: %s' % r1)\n        #end\n        self.encoded = encoded",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "GzipRun1",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class GzipRun1:\n    def Encode(self, target, source, output):\n        assert source == None\n        RunCommandIO(['gzip', '-cf'], target, output)\n    #end\n    def Decode(self, input, source, output):\n        assert source == None\n        RunCommandIO(['gzip', '-dcf'], input, output)\n    #end\n    def Verify(self, target, recon):",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "Xdelta1RunClass",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class Xdelta1RunClass:\n    def __str__(self):\n        return 'xdelta1'\n    #end\n    def New(self):\n        return Xdelta1Runner()\n    #end\n#end\nclass Xdelta1Runner:\n    def Encode(self, target, source, output):",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "Xdelta1Runner",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class Xdelta1Runner:\n    def Encode(self, target, source, output):\n        assert source != None\n        args = ['xdelta1', 'delta', '-q', source, target, output]\n        RunCommand(args, [0, 1])\n    #end\n    def Decode(self, input, source, output):\n        assert source != None\n        args = ['xdelta1', 'patch', '-q', input, source, output]\n        # Note: for dumb historical reasons, xdelta1 returns 1 or 0",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "SkipRcsException",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class SkipRcsException:\n    def __init__(self,reason):\n        self.reason = reason\n    #end\n#end\nclass NotEnoughVersions:\n    def __init__(self):\n        pass\n    #end\n#end",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "NotEnoughVersions",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class NotEnoughVersions:\n    def __init__(self):\n        pass\n    #end\n#end\nclass CommandError:\n    def __init__(self,cmd,str):\n        if type(cmd) is types.TupleType or \\\n           type(cmd) is types.ListType:\n            cmd = reduce(lambda x,y: '%s %s' % (x,y),cmd)",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "CommandError",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class CommandError:\n    def __init__(self,cmd,str):\n        if type(cmd) is types.TupleType or \\\n           type(cmd) is types.ListType:\n            cmd = reduce(lambda x,y: '%s %s' % (x,y),cmd)\n        #end\n        print 'command was: ',cmd\n        print 'command failed: ',str\n        print 'have fun debugging'\n    #end",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RcsVersion",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class RcsVersion:\n    def __init__(self,vstr):\n        self.vstr = vstr\n    #end\n    def __cmp__(self,other):\n        return cmp(self.date, other.date)\n    #end\n    def __str__(self):\n        return str(self.vstr)\n    #end",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RcsFile",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class RcsFile:\n    def __init__(self, fname):\n        self.fname    = fname\n        self.versions = []\n        self.state    = HEAD_STATE\n    #end\n    def SetTotRev(self,s):\n        self.totrev = int(s)\n    #end\n    def Rev(self,s):",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RcsFinder",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class RcsFinder:\n    def __init__(self):\n        self.subdirs  = []\n        self.rcsfiles = []\n        self.others   = []\n        self.skipped  = []\n        self.biground = 0\n    #end\n    def Scan1(self,dir):\n        dents = os.listdir(dir)",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "SampleDataTest",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class SampleDataTest:\n    def __init__(self, dirs):\n        dirs_in = dirs\n        self.pairs = []\n        while dirs:\n            d = dirs[0]\n            dirs = dirs[1:]\n            l = os.listdir(d)\n            files = []\n            for e in l:",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RandomTest",
        "kind": 6,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "class RandomTest:\n    def __init__(self, tnum, tinput, config, syntuple = None):\n        self.mytinput = tinput[2]\n        self.myconfig = config\n        self.tnum = tnum\n        if syntuple != None:\n            self.runtime = syntuple[0]\n            self.compsize = syntuple[1]\n            self.decodetime = None\n        else:",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "INPUT_SPEC",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def INPUT_SPEC(rand):\n    return {\n    # Time/space costs:\n    # -C 1,2,3,4,5,6,7\n    'large_look' : lambda d: rand.choice([9, 10, 11, 12]),\n    'large_step' : lambda d: rand.choice([25, 26, 27, 28, 29, 30]),\n    'small_look'   : lambda d: rand.choice([4]),\n    'small_chain'  : lambda d: rand.choice([1]),\n    'small_lchain' : lambda d: rand.choice([1]),\n    'max_lazy'     : lambda d: rand.choice([4, 5, 6, 7, 8, 9, 10 ]),",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "c2str",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def c2str(c):\n    return ' '.join(['%s' % x for x in c])\n#end\ndef SumList(l):\n    return reduce(lambda x,y: x+y, l)\n#end\n# returns (total, mean, stddev, q2 (median),\n#          (q3-q1)/2 (\"semi-interquartile range\"), max-min (spread))\nclass StatList:\n    def __init__(self,l,desc):",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "SumList",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def SumList(l):\n    return reduce(lambda x,y: x+y, l)\n#end\n# returns (total, mean, stddev, q2 (median),\n#          (q3-q1)/2 (\"semi-interquartile range\"), max-min (spread))\nclass StatList:\n    def __init__(self,l,desc):\n        cnt = len(l)\n        assert(cnt > 1)\n        l.sort()",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RunCommand",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def RunCommand(args, ok = [0]):\n    #print 'run command %s' % (' '.join(args))\n    p = os.spawnvp(os.P_WAIT, args[0], args)\n    if p not in ok:\n        raise CommandError(args, 'exited %d' % p)\n    #end\n#end\ndef RunCommandIO(args,infn,outfn):\n    p = os.fork()\n    if p == 0:",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RunCommandIO",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def RunCommandIO(args,infn,outfn):\n    p = os.fork()\n    if p == 0:\n        os.dup2(os.open(infn,os.O_RDONLY),0)\n        os.dup2(os.open(outfn,os.O_CREAT|os.O_TRUNC|os.O_WRONLY),1)\n        os.execvp(args[0], args)\n    else:\n        s = os.waitpid(p,0)\n        o = os.WEXITSTATUS(s[1])\n        if not os.WIFEXITED(s[1]) or o != 0:",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "Decimals",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def Decimals(start, end):\n    l = []\n    step = start\n    while 1:\n        r = range(step, step * 10, step)\n        l = l + r\n        if step * 10 >= end:\n            l.append(step * 10)\n            break\n        step = step * 10",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RunSpeedTest",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def RunSpeedTest():\n    for L in Decimals(MIN_RUN, MAX_RUN):\n        SetFileSize(RUNFILE, L)\n        trx = TimedTest(RUNFILE, None, Xdelta3Runner(['-W', str(1<<20)]))\n        ReportSpeed(L, trx, '1MB ')\n        trx = TimedTest(RUNFILE, None, Xdelta3Runner(['-W', str(1<<19)]))\n        ReportSpeed(L, trx, '512k')\n        trx = TimedTest(RUNFILE, None, Xdelta3Runner(['-W', str(1<<18)]))\n        ReportSpeed(L, trx, '256k')\n        trm = TimedTest(RUNFILE, None, Xdelta3Mod1(RUNFILE))",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "SetFileSize",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def SetFileSize(F,L):\n    fd = os.open(F, os.O_CREAT | os.O_WRONLY)\n    os.ftruncate(fd,L)\n    assert os.fstat(fd).st_size == L\n    os.close(fd)\n#end\ndef ReportSpeed(L,tr,desc):\n    print '%s run length %u: size %u: time %.3f ms: decode %.3f ms' % \\\n          (desc, L,\n           tr.encode_size,",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "ReportSpeed",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def ReportSpeed(L,tr,desc):\n    print '%s run length %u: size %u: time %.3f ms: decode %.3f ms' % \\\n          (desc, L,\n           tr.encode_size,\n           tr.encode_time.mean * 1000.0,\n           tr.decode_time.mean * 1000.0)\n#end\nclass Xdelta3RunClass:\n    def __init__(self, extra):\n        self.extra = extra",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "GetTestRcsFiles",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def GetTestRcsFiles():\n    rcsf = RcsFinder()\n    rcsf.Crawl(RCSDIR)\n    if len(rcsf.rcsfiles) == 0:\n        raise CommandError('', 'no RCS files')\n    #end\n    rcsf.Summarize()\n    print \"rcsfiles: rcsfiles %d; subdirs %d; others %d; skipped %d\" % (\n        len(rcsf.rcsfiles),\n        len(rcsf.subdirs),",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "ConfigToArgs",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def ConfigToArgs(config):\n    args = [ '-C',\n             ','.join([str(x) for x in config[0:SOFT_CONFIG_CNT]])]\n    for i in range(SOFT_CONFIG_CNT, len(CONFIG_ORDER)):\n        key = CONFIG_ARGMAP[CONFIG_ORDER[i]]\n        val = config[i]\n        if val == 'true' or val == 'false':\n            if val == 'true':\n                args.append('%s' % key)\n            #end",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "PosInAlist",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def PosInAlist(l, e):\n    for i in range(0, len(l)):\n        if l[i][1] == e:\n            return i;\n        #end\n    #end\n    return -1\n#end\n# Generates a set of num_results test configurations, given the list of\n# retest-configs.",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RandomTestConfigs",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def RandomTestConfigs(rand, input_configs, num_results):\n    outputs = input_configs[:]\n    have_set = dict([(c,c) for c in input_configs])\n    # Compute a random configuration\n    def RandomConfig():\n        config = []\n        cmap = {}\n        for key in CONFIG_ORDER:\n            val = cmap[key] = (INPUT_SPEC(rand)[key])(cmap)\n            config.append(val)",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RunOptimizationLoop",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def RunOptimizationLoop(rand, generator, rounds):\n    configs = []\n    for rnum in xrange(rounds):\n        configs = RandomTestConfigs(rand, configs, MAX_RESULTS)\n        tinput = generator(rand)\n        tests = []\n        for x in xrange(len(configs)):\n            t = RandomTest(x, tinput, configs[x])\n            print 'Round %d test %d: %s' % (rnum, x, t)\n            tests.append(t)",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "ScoreTests",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def ScoreTests(results):\n    scored = []\n    timed = []\n    sized = []\n    t_min = float(min([test.time() for test in results]))\n    #t_max = float(max([test.time() for test in results]))\n    s_min = float(min([test.size() for test in results]))\n    #s_max = float(max([test.size() for test in results]))\n    for test in results:\n        # Hyperbolic function. Smaller scores still better",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "GraphResults",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def GraphResults(desc, results):\n    f = open(\"data-%s.csv\" % desc, \"w\")\n    for r in results:\n        f.write(\"%0.9f\\t%d\\t# %s\\n\" % (r.time(), r.size(), r))\n    #end\n    f.close()\n    os.system(\"./plot.sh data-%s.csv plot-%s.jpg\" % (desc, desc))\n#end\ndef GraphSummary(desc, results_ignore):\n    test_population = 0",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "GraphSummary",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def GraphSummary(desc, results_ignore):\n    test_population = 0\n    config_ordered = []\n    # drops duplicate test/config pairs (TODO: don't retest them)\n    for config, cresults in test_all_config_results.items():\n        input_config_map = {}\n        uniq = []\n        for test in cresults:\n            assert test.config() == config\n            test_population += 1",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RunRegressionTest",
        "kind": 2,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "def RunRegressionTest(pairs, rounds):\n    for args in [\n        [],\n        ['-S=djw'],\n        ['-B=412907520'],\n        ['-B 412907520', ],\n                 ]:\n        print \"Args %s\" % (args)\n        for (file1, file2, testkey) in pairs:\n            ttest = TimedTest(file1, file2, Xdelta3Runner(args, forkexec=True),",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RCSDIR",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "RCSDIR = '/tmp/rcs'\nSAMPLEDIR = \"/tmp/diff\"\n#\nMIN_SIZE       = 0\nTIME_TOO_SHORT = 0.050\nSKIP_TRIALS    = 2\nMIN_TRIALS     = 3\nMAX_TRIALS     = 15\n# 10 = fast 1.5 = slow\nMIN_STDDEV_PCT = 1.5",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "SAMPLEDIR",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "SAMPLEDIR = \"/tmp/diff\"\n#\nMIN_SIZE       = 0\nTIME_TOO_SHORT = 0.050\nSKIP_TRIALS    = 2\nMIN_TRIALS     = 3\nMAX_TRIALS     = 15\n# 10 = fast 1.5 = slow\nMIN_STDDEV_PCT = 1.5\n# How many results per round",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "TIME_TOO_SHORT",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "TIME_TOO_SHORT = 0.050\nSKIP_TRIALS    = 2\nMIN_TRIALS     = 3\nMAX_TRIALS     = 15\n# 10 = fast 1.5 = slow\nMIN_STDDEV_PCT = 1.5\n# How many results per round\nMAX_RESULTS = 500\nTEST_ROUNDS = 10\nKEEP_P = (0.5)",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "MIN_STDDEV_PCT",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "MIN_STDDEV_PCT = 1.5\n# How many results per round\nMAX_RESULTS = 500\nTEST_ROUNDS = 10\nKEEP_P = (0.5)\n# For RCS testing, what percent to select\nFILE_P = (0.50)\n# For run-speed tests\nMIN_RUN = 1000 * 1000 * 1\nMAX_RUN = 1000 * 1000 * 10",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "MAX_RESULTS",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "MAX_RESULTS = 500\nTEST_ROUNDS = 10\nKEEP_P = (0.5)\n# For RCS testing, what percent to select\nFILE_P = (0.50)\n# For run-speed tests\nMIN_RUN = 1000 * 1000 * 1\nMAX_RUN = 1000 * 1000 * 10\n# Testwide defaults\nALL_ARGS = [",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "TEST_ROUNDS",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "TEST_ROUNDS = 10\nKEEP_P = (0.5)\n# For RCS testing, what percent to select\nFILE_P = (0.50)\n# For run-speed tests\nMIN_RUN = 1000 * 1000 * 1\nMAX_RUN = 1000 * 1000 * 10\n# Testwide defaults\nALL_ARGS = [\n    '-q'  # '-vv'",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "KEEP_P",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "KEEP_P = (0.5)\n# For RCS testing, what percent to select\nFILE_P = (0.50)\n# For run-speed tests\nMIN_RUN = 1000 * 1000 * 1\nMAX_RUN = 1000 * 1000 * 10\n# Testwide defaults\nALL_ARGS = [\n    '-q'  # '-vv'\n    ]",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "FILE_P",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "FILE_P = (0.50)\n# For run-speed tests\nMIN_RUN = 1000 * 1000 * 1\nMAX_RUN = 1000 * 1000 * 10\n# Testwide defaults\nALL_ARGS = [\n    '-q'  # '-vv'\n    ]\n# The first 7 args go to -C\nSOFT_CONFIG_CNT = 7",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "MIN_RUN",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "MIN_RUN = 1000 * 1000 * 1\nMAX_RUN = 1000 * 1000 * 10\n# Testwide defaults\nALL_ARGS = [\n    '-q'  # '-vv'\n    ]\n# The first 7 args go to -C\nSOFT_CONFIG_CNT = 7\nCONFIG_ORDER = [ 'large_look',\n                 'large_step',",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "MAX_RUN",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "MAX_RUN = 1000 * 1000 * 10\n# Testwide defaults\nALL_ARGS = [\n    '-q'  # '-vv'\n    ]\n# The first 7 args go to -C\nSOFT_CONFIG_CNT = 7\nCONFIG_ORDER = [ 'large_look',\n                 'large_step',\n                 'small_look',",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "ALL_ARGS",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "ALL_ARGS = [\n    '-q'  # '-vv'\n    ]\n# The first 7 args go to -C\nSOFT_CONFIG_CNT = 7\nCONFIG_ORDER = [ 'large_look',\n                 'large_step',\n                 'small_look',\n                 'small_chain',\n                 'small_lchain',",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "SOFT_CONFIG_CNT",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "SOFT_CONFIG_CNT = 7\nCONFIG_ORDER = [ 'large_look',\n                 'large_step',\n                 'small_look',\n                 'small_chain',\n                 'small_lchain',\n                 'max_lazy',\n                 'long_enough',\n                 # > SOFT_CONFIG_CNT\n                 'nocompress',",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "CONFIG_ORDER",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "CONFIG_ORDER = [ 'large_look',\n                 'large_step',\n                 'small_look',\n                 'small_chain',\n                 'small_lchain',\n                 'max_lazy',\n                 'long_enough',\n                 # > SOFT_CONFIG_CNT\n                 'nocompress',\n                 'winsize',",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "CONFIG_ARGMAP",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "CONFIG_ARGMAP = {\n    'winsize'    : '-W',\n    'srcwinsize' : '-B',\n    'sprevsz'    : '-P',\n    'iopt'       : '-I',\n    'nocompress' : '-N',\n    'djw'        : '-Sdjw',\n    'altcode'    : '-T',\n    }\ndef INPUT_SPEC(rand):",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "TMPDIR",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "TMPDIR = '/tmp/xd3regtest.%d' % os.getpid()\nRUNFILE = os.path.join(TMPDIR, 'run')\nDFILE   = os.path.join(TMPDIR, 'output')\nRFILE   = os.path.join(TMPDIR, 'recon')\nCMPTMP1 = os.path.join(TMPDIR, 'cmptmp1')\nCMPTMP2 = os.path.join(TMPDIR, 'cmptmp2')\nHEAD_STATE = 0\nBAR_STATE  = 1\nREV_STATE  = 2\nDATE_STATE = 3",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RUNFILE",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "RUNFILE = os.path.join(TMPDIR, 'run')\nDFILE   = os.path.join(TMPDIR, 'output')\nRFILE   = os.path.join(TMPDIR, 'recon')\nCMPTMP1 = os.path.join(TMPDIR, 'cmptmp1')\nCMPTMP2 = os.path.join(TMPDIR, 'cmptmp2')\nHEAD_STATE = 0\nBAR_STATE  = 1\nREV_STATE  = 2\nDATE_STATE = 3\n#",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "CMPTMP1",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "CMPTMP1 = os.path.join(TMPDIR, 'cmptmp1')\nCMPTMP2 = os.path.join(TMPDIR, 'cmptmp2')\nHEAD_STATE = 0\nBAR_STATE  = 1\nREV_STATE  = 2\nDATE_STATE = 3\n#\nIGNORE_FILENAME  = re.compile('.*\\\\.(gif|jpg).*')\n# rcs output\nRE_TOTREV  = re.compile('total revisions: (\\\\d+)')",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "CMPTMP2",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "CMPTMP2 = os.path.join(TMPDIR, 'cmptmp2')\nHEAD_STATE = 0\nBAR_STATE  = 1\nREV_STATE  = 2\nDATE_STATE = 3\n#\nIGNORE_FILENAME  = re.compile('.*\\\\.(gif|jpg).*')\n# rcs output\nRE_TOTREV  = re.compile('total revisions: (\\\\d+)')\nRE_BAR     = re.compile('----------------------------')",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "HEAD_STATE",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "HEAD_STATE = 0\nBAR_STATE  = 1\nREV_STATE  = 2\nDATE_STATE = 3\n#\nIGNORE_FILENAME  = re.compile('.*\\\\.(gif|jpg).*')\n# rcs output\nRE_TOTREV  = re.compile('total revisions: (\\\\d+)')\nRE_BAR     = re.compile('----------------------------')\nRE_REV     = re.compile('revision (.+)')",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "DATE_STATE",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "DATE_STATE = 3\n#\nIGNORE_FILENAME  = re.compile('.*\\\\.(gif|jpg).*')\n# rcs output\nRE_TOTREV  = re.compile('total revisions: (\\\\d+)')\nRE_BAR     = re.compile('----------------------------')\nRE_REV     = re.compile('revision (.+)')\nRE_DATE    = re.compile('date: ([^;]+);.*')\n# xdelta output\nRE_HDRSZ   = re.compile('VCDIFF header size: +(\\\\d+)')",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "RE_EXTCOMP",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "RE_EXTCOMP = re.compile('XDELTA ext comp.*')\ndef c2str(c):\n    return ' '.join(['%s' % x for x in c])\n#end\ndef SumList(l):\n    return reduce(lambda x,y: x+y, l)\n#end\n# returns (total, mean, stddev, q2 (median),\n#          (q3-q1)/2 (\"semi-interquartile range\"), max-min (spread))\nclass StatList:",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "test_all_config_results",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "peekOfCode": "test_all_config_results = {}\ndef ScoreTests(results):\n    scored = []\n    timed = []\n    sized = []\n    t_min = float(min([test.time() for test in results]))\n    #t_max = float(max([test.time() for test in results]))\n    s_min = float(min([test.size() for test in results]))\n    #s_max = float(max([test.size() for test in results]))\n    for test in results:",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-regtest",
        "documentation": {}
    },
    {
        "label": "source",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "peekOfCode": "source = 'source source input0 source source'\ntarget = 'source source target source source'\n#\n#\nprint 'encode: basic ...'\nresult, patch = xdelta3.xd3_encode_memory(target, source, 50)\nassert result == 0\nassert len(patch) < len(source)\nprint 'encode: adler32 ...'\nresult, patch_adler32 = xdelta3.xd3_encode_memory(target, source, 50,",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "peekOfCode": "target = 'source source target source source'\n#\n#\nprint 'encode: basic ...'\nresult, patch = xdelta3.xd3_encode_memory(target, source, 50)\nassert result == 0\nassert len(patch) < len(source)\nprint 'encode: adler32 ...'\nresult, patch_adler32 = xdelta3.xd3_encode_memory(target, source, 50,\n                                                  xdelta3.XD3_ADLER32)",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "documentation": {}
    },
    {
        "label": "extra_count",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "peekOfCode": "extra_count = 4\nnoverify_count = 0\nfor corrupt_pos in range(len(patch_adler32)):\n    input = ''.join([j == corrupt_pos and '\\xff' or patch_adler32[j]\n                     for j in range(len(patch_adler32))])\n    result, ignore = xdelta3.xd3_decode_memory(input, source, len(target), 0)\n    assert result == -17712\n    assert ignore == None\n    # without adler32 verification, the error may be in the data section which\n    # in this case is 6 bytes 'target'",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "documentation": {}
    },
    {
        "label": "noverify_count",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "peekOfCode": "noverify_count = 0\nfor corrupt_pos in range(len(patch_adler32)):\n    input = ''.join([j == corrupt_pos and '\\xff' or patch_adler32[j]\n                     for j in range(len(patch_adler32))])\n    result, ignore = xdelta3.xd3_decode_memory(input, source, len(target), 0)\n    assert result == -17712\n    assert ignore == None\n    # without adler32 verification, the error may be in the data section which\n    # in this case is 6 bytes 'target'\n    result, corrupt = xdelta3.xd3_decode_memory(input, source, len(target),",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "documentation": {}
    },
    {
        "label": "source",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "peekOfCode": "source = '_la_la_abcdefghi_la_la_ABCDEFGHI'\ntarget = 'la_la_ABCDEFGH__la_la_abcdefgh__'\nresult1, level1 = xdelta3.xd3_encode_memory(target, source, 50, xdelta3.XD3_COMPLEVEL_1)\nresult9, level9 = xdelta3.xd3_encode_memory(target, source, 50, xdelta3.XD3_COMPLEVEL_9)\nassert result1 == 0 and result9 == 0\nassert len(level1) > len(level9)\n#\n# Issue 65\nprint 'encode: 65 ...'\nsource = 'Hello World' ",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "peekOfCode": "target = 'la_la_ABCDEFGH__la_la_abcdefgh__'\nresult1, level1 = xdelta3.xd3_encode_memory(target, source, 50, xdelta3.XD3_COMPLEVEL_1)\nresult9, level9 = xdelta3.xd3_encode_memory(target, source, 50, xdelta3.XD3_COMPLEVEL_9)\nassert result1 == 0 and result9 == 0\nassert len(level1) > len(level9)\n#\n# Issue 65\nprint 'encode: 65 ...'\nsource = 'Hello World' \ntarget = 'Hello everyone' ",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "documentation": {}
    },
    {
        "label": "source",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "peekOfCode": "source = 'Hello World' \ntarget = 'Hello everyone' \nresult, patch = xdelta3.xd3_encode_memory(target, source, len(target))\nassert result != 0\nresult, patch = xdelta3.xd3_encode_memory(target, source, 2 * len(target))\nassert result == 0\nprint 'PASS'",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "description": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "peekOfCode": "target = 'Hello everyone' \nresult, patch = xdelta3.xd3_encode_memory(target, source, len(target))\nassert result != 0\nresult, patch = xdelta3.xd3_encode_memory(target, source, 2 * len(target))\nassert result == 0\nprint 'PASS'",
        "detail": "third-party.xdelta3.xdelta3.testing.xdelta3-test",
        "documentation": {}
    },
    {
        "label": "glob_in_dir",
        "kind": 2,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "def glob_in_dir(\n    pattern: str,\n    root_dir: Path,\n):\n    cwd = os.getcwd()\n    root_dir = root_dir.resolve()\n    os.chdir(root_dir)\n    try:\n        for path in glob(pattern, recursive=True):\n            yield Path(root_dir) / path",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "find_include_path",
        "kind": 2,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "def find_include_path(\n    include: str,\n    search_paths: List[Path],\n) -> Path:\n    for search_path in search_paths:\n        path = search_path / include\n        if path.exists():\n            return path.absolute()\n    else:\n        raise FileNotFoundError(f'can\\'t find header: {include}')",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "merge_headers",
        "kind": 2,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "def merge_headers(\n    *,\n    header: str,\n    search_paths: List[Path],\n    covered_headers: Set[Path],\n    stack: List[str],\n) -> List[str]:\n    # Locate and load header contents.\n    path = find_include_path(header, search_paths)\n    with path.open() as f:",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "merge_sources",
        "kind": 2,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "def merge_sources(*, source_dir: Path, covered_headers: Set[Path]):\n    output = [\n        '#include <Zydis.h>',\n        '',\n    ]\n    for source_file in glob_in_dir('**/*.c', source_dir):\n        print(f'Processing source file \"{source_file}\"')\n        # Print some comments to show where the code is from.\n        output += [\n            f'',",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "def main():\n    if OUTPUT_DIR.exists():\n        print('Output directory exists. Deleting.')\n        rmtree(OUTPUT_DIR)\n    OUTPUT_DIR.mkdir()\n    covered_headers = set()\n    with open(OUTPUT_DIR / 'Zydis.h', 'w') as f:\n        f.write('\\n'.join(FILE_HEADER + merge_headers(\n            header='Zydis/Zydis.h', \n            search_paths=PUBLIC_INCLUDE_PATHS,",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "ZYDIS_ROOT",
        "kind": 5,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "ZYDIS_ROOT = Path(__file__).resolve().parent.parent\nPUBLIC_INCLUDE_PATHS = [\n    ZYDIS_ROOT / 'include',\n    ZYDIS_ROOT / 'dependencies' / 'zycore' / 'include',\n]\nINTERNAL_INCLUDE_PATHS = [ZYDIS_ROOT / 'src']\nINCLUDE_REGEXP = re.compile(r'^#\\s*include\\s*<((?:Zy|Generated).*)>\\s*$')\nOUTPUT_DIR = ZYDIS_ROOT / 'amalgamated-dist'\nFILE_HEADER = ['// DO NOT EDIT. This file is auto-generated by `amalgamate.py`.', '']\n# Python versions before 3.10 don't have the root_dir argument for glob, so we ",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "PUBLIC_INCLUDE_PATHS",
        "kind": 5,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "PUBLIC_INCLUDE_PATHS = [\n    ZYDIS_ROOT / 'include',\n    ZYDIS_ROOT / 'dependencies' / 'zycore' / 'include',\n]\nINTERNAL_INCLUDE_PATHS = [ZYDIS_ROOT / 'src']\nINCLUDE_REGEXP = re.compile(r'^#\\s*include\\s*<((?:Zy|Generated).*)>\\s*$')\nOUTPUT_DIR = ZYDIS_ROOT / 'amalgamated-dist'\nFILE_HEADER = ['// DO NOT EDIT. This file is auto-generated by `amalgamate.py`.', '']\n# Python versions before 3.10 don't have the root_dir argument for glob, so we \n# crudely emulate it here.",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "INTERNAL_INCLUDE_PATHS",
        "kind": 5,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "INTERNAL_INCLUDE_PATHS = [ZYDIS_ROOT / 'src']\nINCLUDE_REGEXP = re.compile(r'^#\\s*include\\s*<((?:Zy|Generated).*)>\\s*$')\nOUTPUT_DIR = ZYDIS_ROOT / 'amalgamated-dist'\nFILE_HEADER = ['// DO NOT EDIT. This file is auto-generated by `amalgamate.py`.', '']\n# Python versions before 3.10 don't have the root_dir argument for glob, so we \n# crudely emulate it here.\ndef glob_in_dir(\n    pattern: str,\n    root_dir: Path,\n):",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "INCLUDE_REGEXP",
        "kind": 5,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "INCLUDE_REGEXP = re.compile(r'^#\\s*include\\s*<((?:Zy|Generated).*)>\\s*$')\nOUTPUT_DIR = ZYDIS_ROOT / 'amalgamated-dist'\nFILE_HEADER = ['// DO NOT EDIT. This file is auto-generated by `amalgamate.py`.', '']\n# Python versions before 3.10 don't have the root_dir argument for glob, so we \n# crudely emulate it here.\ndef glob_in_dir(\n    pattern: str,\n    root_dir: Path,\n):\n    cwd = os.getcwd()",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "kind": 5,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "OUTPUT_DIR = ZYDIS_ROOT / 'amalgamated-dist'\nFILE_HEADER = ['// DO NOT EDIT. This file is auto-generated by `amalgamate.py`.', '']\n# Python versions before 3.10 don't have the root_dir argument for glob, so we \n# crudely emulate it here.\ndef glob_in_dir(\n    pattern: str,\n    root_dir: Path,\n):\n    cwd = os.getcwd()\n    root_dir = root_dir.resolve()",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "FILE_HEADER",
        "kind": 5,
        "importPath": "third-party.zydis.assets.amalgamate",
        "description": "third-party.zydis.assets.amalgamate",
        "peekOfCode": "FILE_HEADER = ['// DO NOT EDIT. This file is auto-generated by `amalgamate.py`.', '']\n# Python versions before 3.10 don't have the root_dir argument for glob, so we \n# crudely emulate it here.\ndef glob_in_dir(\n    pattern: str,\n    root_dir: Path,\n):\n    cwd = os.getcwd()\n    root_dir = root_dir.resolve()\n    os.chdir(root_dir)",
        "detail": "third-party.zydis.assets.amalgamate",
        "documentation": {}
    },
    {
        "label": "BinaryReader",
        "kind": 6,
        "importPath": "third-party.zydis.tests.binary_reader",
        "description": "third-party.zydis.tests.binary_reader",
        "peekOfCode": "class BinaryReader(object):\n    def __init__(self, data):\n        self.data = data\n        self.cursor = 0\n    def _check_eof(self, size):\n        if self.cursor + size > len(self.data):\n            raise EOFError('Attempted to read past the end of internal data buffer')\n    def _read_internal(self, fmt, size):\n        self._check_eof(size)\n        data_to_unpack = self.data[self.cursor:self.cursor + size]",
        "detail": "third-party.zydis.tests.binary_reader",
        "documentation": {}
    },
    {
        "label": "BinaryWriter",
        "kind": 6,
        "importPath": "third-party.zydis.tests.binary_writer",
        "description": "third-party.zydis.tests.binary_writer",
        "peekOfCode": "class BinaryWriter(object):\n    def __init__(self):\n        self.data = b''\n    def _write_internal(self, fmt, val):\n        self.data += pack(fmt, val)\n        return self\n    def write_uint8(self, val):\n        return self._write_internal('<B', val)\n    def write_uint16(self, val):\n        return self._write_internal('<H', val)",
        "detail": "third-party.zydis.tests.binary_writer",
        "documentation": {}
    },
    {
        "label": "to_json",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def to_json(obj):\n    return json.dumps(obj, indent=4)\ndef get_width_from_enum(enum_value):\n    return enum_value.name[enum_value.name.rfind('_') + 1:]\ndef get_enum_max(enum_class):\n    if issubclass(enum_class, IntEnum):\n        return max([v.value for v in enum_class])\n    elif issubclass(enum_class, IntFlag):\n        return functools.reduce(lambda x, y: x | y, [v.value for v in enum_class])\n    else:",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "get_width_from_enum",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def get_width_from_enum(enum_value):\n    return enum_value.name[enum_value.name.rfind('_') + 1:]\ndef get_enum_max(enum_class):\n    if issubclass(enum_class, IntEnum):\n        return max([v.value for v in enum_class])\n    elif issubclass(enum_class, IntFlag):\n        return functools.reduce(lambda x, y: x | y, [v.value for v in enum_class])\n    else:\n        raise RuntimeError('Invalid type passed to get_enum_max: ' + enum_class.__name__)\ndef get_sanitized_enum(reader, enum_class):",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "get_enum_max",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def get_enum_max(enum_class):\n    if issubclass(enum_class, IntEnum):\n        return max([v.value for v in enum_class])\n    elif issubclass(enum_class, IntFlag):\n        return functools.reduce(lambda x, y: x | y, [v.value for v in enum_class])\n    else:\n        raise RuntimeError('Invalid type passed to get_enum_max: ' + enum_class.__name__)\ndef get_sanitized_enum(reader, enum_class):\n    raw_value = reader.read_uint32()\n    if issubclass(enum_class, IntEnum):",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "get_sanitized_enum",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def get_sanitized_enum(reader, enum_class):\n    raw_value = reader.read_uint32()\n    if issubclass(enum_class, IntEnum):\n        return enum_class(raw_value % (get_enum_max(enum_class) + 1))\n    elif issubclass(enum_class, IntFlag):\n        return enum_class(raw_value & get_enum_max(enum_class))\n    else:\n        raise RuntimeError('Invalid type passed to get_sanitized_enum: ' + enum_class.__name__)\ndef get_decomposed_flags(combined_flags):\n    enum_class = type(combined_flags)",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "get_decomposed_flags",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def get_decomposed_flags(combined_flags):\n    enum_class = type(combined_flags)\n    flag_str = '|'.join([v.name for v in enum_class if v in combined_flags and v.value != 0])\n    if flag_str == '':\n        return enum_class(0).name\n    return flag_str\ndef get_combined_flags(flag_str, enum_class):\n    return functools.reduce(lambda x, y: x | y, [enum_class[v] for v in flag_str.split('|')])\ndef get_disasm(zydis_info, machine_mode, stack_width, payload):\n    if not zydis_info:",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "get_combined_flags",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def get_combined_flags(flag_str, enum_class):\n    return functools.reduce(lambda x, y: x | y, [enum_class[v] for v in flag_str.split('|')])\ndef get_disasm(zydis_info, machine_mode, stack_width, payload):\n    if not zydis_info:\n        return ''\n    arg_machine_mode = '-' + get_width_from_enum(machine_mode)\n    arg_stack_width = '-' + get_width_from_enum(stack_width)\n    proc = Popen([zydis_info, arg_machine_mode, arg_stack_width, payload[:30]], stdout=PIPE, stderr=PIPE)\n    out = proc.communicate()[0].decode('utf-8')\n    if proc.returncode != 0:",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "get_disasm",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def get_disasm(zydis_info, machine_mode, stack_width, payload):\n    if not zydis_info:\n        return ''\n    arg_machine_mode = '-' + get_width_from_enum(machine_mode)\n    arg_stack_width = '-' + get_width_from_enum(stack_width)\n    proc = Popen([zydis_info, arg_machine_mode, arg_stack_width, payload[:30]], stdout=PIPE, stderr=PIPE)\n    out = proc.communicate()[0].decode('utf-8')\n    if proc.returncode != 0:\n        return ''\n    match = re.search(r\"INTEL[^A]+ABSOLUTE: ([^\\r\\n]+)\", out)",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "convert_enc_crash_to_json",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def convert_enc_crash_to_json(crash, return_dict=False):\n    reader = BinaryReader(crash)\n    machine_mode = get_sanitized_enum(reader, ZydisMachineMode)\n    allowed_encoding = get_sanitized_enum(reader, ZydisEncodableEncoding)\n    mnemonic = get_sanitized_enum(reader, ZydisMnemonic)\n    reader.read_bytes(4)\n    prefixes = ZydisInstructionAttributes(reader.read_uint64() & ZYDIS_ENCODABLE_PREFIXES)\n    branch_type = get_sanitized_enum(reader, ZydisBranchType)\n    branch_width = get_sanitized_enum(reader, ZydisBranchWidth)\n    address_size_hint = get_sanitized_enum(reader, ZydisAddressSizeHint)",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "convert_re_enc_crash_to_json",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def convert_re_enc_crash_to_json(crash, zydis_info, return_dict=False):\n    reader = BinaryReader(crash)\n    machine_mode = ZydisMachineMode(reader.read_uint32())\n    stack_width = ZydisStackWidth(reader.read_uint32())\n    payload = reader.read_bytes().hex().upper()\n    test_case = {\n        'machine_mode': machine_mode.name,\n        'stack_width': stack_width.name,\n        'payload': payload,\n        'description': get_disasm(zydis_info, machine_mode, stack_width, payload),",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "convert_enc_json_to_crash",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def convert_enc_json_to_crash(test_case_json, from_dict=False):\n    if from_dict:\n        test_case = test_case_json\n    else:\n        test_case = json.loads(test_case_json)\n    writer = BinaryWriter()\n    writer.write_uint32(ZydisMachineMode[test_case['machine_mode']])\n    writer.write_uint32(get_combined_flags(test_case['allowed_encodings'], ZydisEncodableEncoding))\n    writer.write_uint32(ZydisMnemonic[test_case['mnemonic']])\n    writer.write_padding(4)",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "convert_re_enc_json_to_crash",
        "kind": 2,
        "importPath": "third-party.zydis.tests.crash_tool",
        "description": "third-party.zydis.tests.crash_tool",
        "peekOfCode": "def convert_re_enc_json_to_crash(test_case_json, from_dict=False):\n    if from_dict:\n        test_case = test_case_json\n    else:\n        test_case = json.loads(test_case_json)\n    writer = BinaryWriter()\n    writer.write_uint32(ZydisMachineMode[test_case['machine_mode']])\n    writer.write_uint32(ZydisStackWidth[test_case['stack_width']])\n    writer.write_bytes(bytes.fromhex(test_case['payload']))\n    return writer.get_data()",
        "detail": "third-party.zydis.tests.crash_tool",
        "documentation": {}
    },
    {
        "label": "get_exitcode_stdout_stderr",
        "kind": 2,
        "importPath": "third-party.zydis.tests.regression",
        "description": "third-party.zydis.tests.regression",
        "peekOfCode": "def get_exitcode_stdout_stderr(path, cmd):\n    \"\"\"\n    Executes an external command and returns the exitcode, stdout and stderr.\n    \"\"\"\n    args = [path]\n    args.extend(shlex.split(cmd))\n    proc = Popen(args, stdout=PIPE, stderr=PIPE)\n    out, err = proc.communicate()\n    exitcode = proc.returncode\n    return exitcode, out, err",
        "detail": "third-party.zydis.tests.regression",
        "documentation": {}
    },
    {
        "label": "TEST_CASE_DIRECTORY",
        "kind": 5,
        "importPath": "third-party.zydis.tests.regression",
        "description": "third-party.zydis.tests.regression",
        "peekOfCode": "TEST_CASE_DIRECTORY = os.path.join('.', 'cases')\ndef get_exitcode_stdout_stderr(path, cmd):\n    \"\"\"\n    Executes an external command and returns the exitcode, stdout and stderr.\n    \"\"\"\n    args = [path]\n    args.extend(shlex.split(cmd))\n    proc = Popen(args, stdout=PIPE, stderr=PIPE)\n    out, err = proc.communicate()\n    exitcode = proc.returncode",
        "detail": "third-party.zydis.tests.regression",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "third-party.zydis.tests.regression",
        "description": "third-party.zydis.tests.regression",
        "peekOfCode": "parser = argparse.ArgumentParser(description=\"Regression testing.\")\nparser.add_argument(dest=\"operation\", choices=[\"test\", \"rebase\"])\nparser.add_argument(dest=\"zydis_info_path\", type=str)\nargs = parser.parse_args()\nhas_failed = False\nfor case in os.listdir(TEST_CASE_DIRECTORY):\n    if not case.endswith(\".in\"):\n        continue\n    path = os.path.join(TEST_CASE_DIRECTORY, case)\n    print(path)",
        "detail": "third-party.zydis.tests.regression",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "third-party.zydis.tests.regression",
        "description": "third-party.zydis.tests.regression",
        "peekOfCode": "args = parser.parse_args()\nhas_failed = False\nfor case in os.listdir(TEST_CASE_DIRECTORY):\n    if not case.endswith(\".in\"):\n        continue\n    path = os.path.join(TEST_CASE_DIRECTORY, case)\n    print(path)\n    with open(path, mode=\"r\") as f:\n        payload = f.read()\n    exitcode, out, err = get_exitcode_stdout_stderr(args.zydis_info_path, payload)",
        "detail": "third-party.zydis.tests.regression",
        "documentation": {}
    },
    {
        "label": "has_failed",
        "kind": 5,
        "importPath": "third-party.zydis.tests.regression",
        "description": "third-party.zydis.tests.regression",
        "peekOfCode": "has_failed = False\nfor case in os.listdir(TEST_CASE_DIRECTORY):\n    if not case.endswith(\".in\"):\n        continue\n    path = os.path.join(TEST_CASE_DIRECTORY, case)\n    print(path)\n    with open(path, mode=\"r\") as f:\n        payload = f.read()\n    exitcode, out, err = get_exitcode_stdout_stderr(args.zydis_info_path, payload)\n    pre, ext = os.path.splitext(case)",
        "detail": "third-party.zydis.tests.regression",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": "third-party.zydis.tests.regression_encoder",
        "description": "third-party.zydis.tests.regression_encoder",
        "peekOfCode": "def run_test(binary, payload=None):\n    proc = Popen(binary, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n    proc.communicate(input=payload)\n    return proc.returncode == 0\ndef run_test_collection(test_db_file, binary, converter):\n    with open(test_db_file, 'r') as f:\n        cases = json.loads(f.read())\n    tests_passed = True\n    for i, case in enumerate(cases):\n        test_result = run_test(binary, converter(case, True))",
        "detail": "third-party.zydis.tests.regression_encoder",
        "documentation": {}
    },
    {
        "label": "run_test_collection",
        "kind": 2,
        "importPath": "third-party.zydis.tests.regression_encoder",
        "description": "third-party.zydis.tests.regression_encoder",
        "peekOfCode": "def run_test_collection(test_db_file, binary, converter):\n    with open(test_db_file, 'r') as f:\n        cases = json.loads(f.read())\n    tests_passed = True\n    for i, case in enumerate(cases):\n        test_result = run_test(binary, converter(case, True))\n        tests_passed &= test_result\n        description = 'Case #%d: ' % i\n        if 'description' in case:\n            description += case['description']",
        "detail": "third-party.zydis.tests.regression_encoder",
        "documentation": {}
    },
    {
        "label": "ZYDIS_ENCODER_MAX_OPERANDS",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZYDIS_ENCODER_MAX_OPERANDS = 5\nSIZE_OF_ZYDIS_ENCODER_OPERAND = 64  # This value must be corrected manually if structure layout changes\nZydisInstructionAttributes = IntFlag('ZydisInstructionAttributes', [\n    ('ZYDIS_ATTRIB_NONE', 0),\n    ('ZYDIS_ATTRIB_HAS_MODRM', (1 <<  0)),\n    ('ZYDIS_ATTRIB_HAS_SIB', (1 <<  1)),\n    ('ZYDIS_ATTRIB_HAS_REX', (1 <<  2)),\n    ('ZYDIS_ATTRIB_HAS_XOP', (1 <<  3)),\n    ('ZYDIS_ATTRIB_HAS_VEX', (1 <<  4)),\n    ('ZYDIS_ATTRIB_HAS_EVEX', (1 <<  5)),",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "SIZE_OF_ZYDIS_ENCODER_OPERAND",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "SIZE_OF_ZYDIS_ENCODER_OPERAND = 64  # This value must be corrected manually if structure layout changes\nZydisInstructionAttributes = IntFlag('ZydisInstructionAttributes', [\n    ('ZYDIS_ATTRIB_NONE', 0),\n    ('ZYDIS_ATTRIB_HAS_MODRM', (1 <<  0)),\n    ('ZYDIS_ATTRIB_HAS_SIB', (1 <<  1)),\n    ('ZYDIS_ATTRIB_HAS_REX', (1 <<  2)),\n    ('ZYDIS_ATTRIB_HAS_XOP', (1 <<  3)),\n    ('ZYDIS_ATTRIB_HAS_VEX', (1 <<  4)),\n    ('ZYDIS_ATTRIB_HAS_EVEX', (1 <<  5)),\n    ('ZYDIS_ATTRIB_HAS_MVEX', (1 <<  6)),",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisInstructionAttributes",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisInstructionAttributes = IntFlag('ZydisInstructionAttributes', [\n    ('ZYDIS_ATTRIB_NONE', 0),\n    ('ZYDIS_ATTRIB_HAS_MODRM', (1 <<  0)),\n    ('ZYDIS_ATTRIB_HAS_SIB', (1 <<  1)),\n    ('ZYDIS_ATTRIB_HAS_REX', (1 <<  2)),\n    ('ZYDIS_ATTRIB_HAS_XOP', (1 <<  3)),\n    ('ZYDIS_ATTRIB_HAS_VEX', (1 <<  4)),\n    ('ZYDIS_ATTRIB_HAS_EVEX', (1 <<  5)),\n    ('ZYDIS_ATTRIB_HAS_MVEX', (1 <<  6)),\n    ('ZYDIS_ATTRIB_IS_RELATIVE', (1 <<  7)),",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZYDIS_ENCODABLE_PREFIXES",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZYDIS_ENCODABLE_PREFIXES = ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_LOCK | \\\n                           ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_REP | \\\n                           ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_REPE | \\\n                           ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_REPNE | \\\n                           ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_BND | \\\n                           ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_XACQUIRE | \\\n                           ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_XRELEASE | \\\n                           ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_BRANCH_NOT_TAKEN | \\\n                           ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_BRANCH_TAKEN | \\\n                           ZydisInstructionAttributes.ZYDIS_ATTRIB_HAS_NOTRACK | \\",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisMachineMode",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisMachineMode = IntEnum('ZydisMachineMode', [\n    'ZYDIS_MACHINE_MODE_LONG_64',\n    'ZYDIS_MACHINE_MODE_LONG_COMPAT_32',\n    'ZYDIS_MACHINE_MODE_LONG_COMPAT_16',\n    'ZYDIS_MACHINE_MODE_LEGACY_32',\n    'ZYDIS_MACHINE_MODE_LEGACY_16',\n    'ZYDIS_MACHINE_MODE_REAL_16',\n], start=0)\nZydisStackWidth = IntEnum('ZydisStackWidth', [\n    'ZYDIS_STACK_WIDTH_16',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisStackWidth",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisStackWidth = IntEnum('ZydisStackWidth', [\n    'ZYDIS_STACK_WIDTH_16',\n    'ZYDIS_STACK_WIDTH_32',\n    'ZYDIS_STACK_WIDTH_64',\n], start=0)\nZydisBranchType = IntEnum('ZydisBranchType', [\n    'ZYDIS_BRANCH_TYPE_NONE',\n    'ZYDIS_BRANCH_TYPE_SHORT',\n    'ZYDIS_BRANCH_TYPE_NEAR',\n    'ZYDIS_BRANCH_TYPE_FAR',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisBranchType",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisBranchType = IntEnum('ZydisBranchType', [\n    'ZYDIS_BRANCH_TYPE_NONE',\n    'ZYDIS_BRANCH_TYPE_SHORT',\n    'ZYDIS_BRANCH_TYPE_NEAR',\n    'ZYDIS_BRANCH_TYPE_FAR',\n], start=0)\nZydisBranchWidth = IntEnum('ZydisBranchWidth', [\n    'ZYDIS_BRANCH_WIDTH_NONE',\n    'ZYDIS_BRANCH_WIDTH_8',\n    'ZYDIS_BRANCH_WIDTH_16',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisBranchWidth",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisBranchWidth = IntEnum('ZydisBranchWidth', [\n    'ZYDIS_BRANCH_WIDTH_NONE',\n    'ZYDIS_BRANCH_WIDTH_8',\n    'ZYDIS_BRANCH_WIDTH_16',\n    'ZYDIS_BRANCH_WIDTH_32',\n    'ZYDIS_BRANCH_WIDTH_64',\n], start=0)\nZydisEncodableEncoding = IntFlag('ZydisEncodableEncoding', [\n    'ZYDIS_ENCODABLE_ENCODING_DEFAULT',\n    'ZYDIS_ENCODABLE_ENCODING_LEGACY',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisEncodableEncoding",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisEncodableEncoding = IntFlag('ZydisEncodableEncoding', [\n    'ZYDIS_ENCODABLE_ENCODING_DEFAULT',\n    'ZYDIS_ENCODABLE_ENCODING_LEGACY',\n    'ZYDIS_ENCODABLE_ENCODING_3DNOW',\n    'ZYDIS_ENCODABLE_ENCODING_XOP',\n    'ZYDIS_ENCODABLE_ENCODING_VEX',\n    'ZYDIS_ENCODABLE_ENCODING_EVEX',\n    'ZYDIS_ENCODABLE_ENCODING_MVEX',\n], start=0)\nZydisAddressSizeHint = IntEnum('ZydisAddressSizeHint', [",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisAddressSizeHint",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisAddressSizeHint = IntEnum('ZydisAddressSizeHint', [\n    'ZYDIS_ADDRESS_SIZE_HINT_NONE',\n    'ZYDIS_ADDRESS_SIZE_HINT_16',\n    'ZYDIS_ADDRESS_SIZE_HINT_32',\n    'ZYDIS_ADDRESS_SIZE_HINT_64',\n], start=0)\nZydisOperandSizeHint = IntEnum('ZydisOperandSizeHint', [\n    'ZYDIS_OPERAND_SIZE_HINT_NONE',\n    'ZYDIS_OPERAND_SIZE_HINT_8',\n    'ZYDIS_OPERAND_SIZE_HINT_16',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisOperandSizeHint",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisOperandSizeHint = IntEnum('ZydisOperandSizeHint', [\n    'ZYDIS_OPERAND_SIZE_HINT_NONE',\n    'ZYDIS_OPERAND_SIZE_HINT_8',\n    'ZYDIS_OPERAND_SIZE_HINT_16',\n    'ZYDIS_OPERAND_SIZE_HINT_32',\n    'ZYDIS_OPERAND_SIZE_HINT_64',\n], start=0)\nZydisBroadcastMode = IntEnum('ZydisBroadcastMode', [\n    'ZYDIS_BROADCAST_MODE_INVALID',\n    'ZYDIS_BROADCAST_MODE_1_TO_2',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisBroadcastMode",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisBroadcastMode = IntEnum('ZydisBroadcastMode', [\n    'ZYDIS_BROADCAST_MODE_INVALID',\n    'ZYDIS_BROADCAST_MODE_1_TO_2',\n    'ZYDIS_BROADCAST_MODE_1_TO_4',\n    'ZYDIS_BROADCAST_MODE_1_TO_8',\n    'ZYDIS_BROADCAST_MODE_1_TO_16',\n    'ZYDIS_BROADCAST_MODE_1_TO_32',\n    'ZYDIS_BROADCAST_MODE_1_TO_64',\n    'ZYDIS_BROADCAST_MODE_2_TO_4',\n    'ZYDIS_BROADCAST_MODE_2_TO_8',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisRoundingMode",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisRoundingMode = IntEnum('ZydisRoundingMode', [\n    'ZYDIS_ROUNDING_MODE_INVALID',\n    'ZYDIS_ROUNDING_MODE_RN',\n    'ZYDIS_ROUNDING_MODE_RD',\n    'ZYDIS_ROUNDING_MODE_RU',\n    'ZYDIS_ROUNDING_MODE_RZ',\n], start=0)\nZydisConversionMode = IntEnum('ZydisConversionMode', [\n    'ZYDIS_CONVERSION_MODE_INVALID',\n    'ZYDIS_CONVERSION_MODE_FLOAT16',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisConversionMode",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisConversionMode = IntEnum('ZydisConversionMode', [\n    'ZYDIS_CONVERSION_MODE_INVALID',\n    'ZYDIS_CONVERSION_MODE_FLOAT16',\n    'ZYDIS_CONVERSION_MODE_SINT8',\n    'ZYDIS_CONVERSION_MODE_UINT8',\n    'ZYDIS_CONVERSION_MODE_SINT16',\n    'ZYDIS_CONVERSION_MODE_UINT16',\n], start=0)\nZydisSwizzleMode = IntEnum('ZydisSwizzleMode', [\n    'ZYDIS_SWIZZLE_MODE_INVALID',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisSwizzleMode",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisSwizzleMode = IntEnum('ZydisSwizzleMode', [\n    'ZYDIS_SWIZZLE_MODE_INVALID',\n    'ZYDIS_SWIZZLE_MODE_DCBA',\n    'ZYDIS_SWIZZLE_MODE_CDAB',\n    'ZYDIS_SWIZZLE_MODE_BADC',\n    'ZYDIS_SWIZZLE_MODE_DACB',\n    'ZYDIS_SWIZZLE_MODE_AAAA',\n    'ZYDIS_SWIZZLE_MODE_BBBB',\n    'ZYDIS_SWIZZLE_MODE_CCCC',\n    'ZYDIS_SWIZZLE_MODE_DDDD',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisOperandType",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisOperandType = IntEnum('ZydisOperandType', [\n    'ZYDIS_OPERAND_TYPE_UNUSED',\n    'ZYDIS_OPERAND_TYPE_REGISTER',\n    'ZYDIS_OPERAND_TYPE_MEMORY',\n    'ZYDIS_OPERAND_TYPE_POINTER',\n    'ZYDIS_OPERAND_TYPE_IMMEDIATE',\n], start=0)\nZydisMnemonic = IntEnum('ZydisMnemonic', [\n    'ZYDIS_MNEMONIC_INVALID',\n    'ZYDIS_MNEMONIC_AAA',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisMnemonic",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisMnemonic = IntEnum('ZydisMnemonic', [\n    'ZYDIS_MNEMONIC_INVALID',\n    'ZYDIS_MNEMONIC_AAA',\n    'ZYDIS_MNEMONIC_AAD',\n    'ZYDIS_MNEMONIC_AAM',\n    'ZYDIS_MNEMONIC_AAS',\n    'ZYDIS_MNEMONIC_ADC',\n    'ZYDIS_MNEMONIC_ADCX',\n    'ZYDIS_MNEMONIC_ADD',\n    'ZYDIS_MNEMONIC_ADDPD',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    },
    {
        "label": "ZydisRegister",
        "kind": 5,
        "importPath": "third-party.zydis.tests.zydis_encoder_types",
        "description": "third-party.zydis.tests.zydis_encoder_types",
        "peekOfCode": "ZydisRegister = IntEnum('ZydisRegister', [\n    'ZYDIS_REGISTER_NONE',\n    'ZYDIS_REGISTER_AL',\n    'ZYDIS_REGISTER_CL',\n    'ZYDIS_REGISTER_DL',\n    'ZYDIS_REGISTER_BL',\n    'ZYDIS_REGISTER_AH',\n    'ZYDIS_REGISTER_CH',\n    'ZYDIS_REGISTER_DH',\n    'ZYDIS_REGISTER_BH',",
        "detail": "third-party.zydis.tests.zydis_encoder_types",
        "documentation": {}
    }
]