(deftype flock (structure)
  ((chicks handle NUM_FLOCKPOINTS :offset-assert 0)))

(define *flock* (new 'static 'flock))

(deftype flock-points (structure)
  ((points vector NUM_FLOCKPOINTS :inline :offset-assert 0)))

(define *flock-points* (new 'static 'flock-points))

(define *return-points* (new 'static 'flock-points))

(deftype demon-chicken (process-drawable)
  ((cshape           collide-shape-moving :offset 112)
   (trajectory       trajectory :inline)
   (target-pos       vector :inline)
   (dir              vector :inline)
   (notice-dist      meters)
   (stop-chase-dist  meters)
   (touch-time       time-frame)
   (anim-speed       float)
   (traj-time        float)
   (grace-period     time-frame)
   (to-point-speed   float)
   (parent-cell-name string)
   (substate         symbol)
   (last-retrieved?  time-frame)
   (locked?          symbol))
  (:methods
   (init-collision! (_type_) none)
   (init-skel! (_type_) none)
   (common-init! (_type_) none)
   (target-in-range? (_type_ float) basic)
   (move! (_type_) none)
   (send-attack! (_type_ process touching-shapes-entry symbol) object)
   (touch-handler (_type_ process event-message-block) object)
   (debug-draw-text! (_type_) none)
   (should-chase? (_type_) basic)
   (dist-to-target (_type_) float))
  (:states
   demon-chicken-dormant
   demon-chicken-idle
   demon-chicken-chase
   ;; demon-chicken-victory
   ))

(defmethod init-collision! ((this demon-chicken))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) default-collision-reaction)
    (set! (-> cshape no-reaction) (the (function collide-shape-moving collide-shape-intersect vector vector none) nothing))
    ;; set up a prim group with one sphere
    (let ((prim-group (new 'process 'collide-shape-prim-group cshape (the uint 1) 0)))
      (set! (-> prim-group prim-core collide-as) (collide-kind enemy))
      (set! (-> prim-group collide-with) (collide-kind target))
      (set! (-> prim-group prim-core offense) (collide-offense touch))
      (set-vector! (-> prim-group local-sphere) 0.0 (meters 0.5) 0.0 (meters 1.25))
      (set-root-prim! cshape prim-group)
      (let ((prim-sphere (new 'process 'collide-shape-prim-sphere cshape (the uint 1))))
        (set! (-> prim-sphere prim-core collide-as) (collide-kind enemy))
        (set! (-> prim-sphere collide-with) (collide-kind target))
        (set! (-> prim-sphere prim-core offense) (collide-offense touch))
        (set-vector! (-> prim-sphere local-sphere) 0.0 (meters 0.5) 0.0 (meters 0.5))
        (append-prim prim-group prim-sphere)))
    (set! (-> cshape max-iteration-count) (the uint 2))
    (backup-collide-with-as cshape)
    (set! (-> this cshape) cshape))
  (none))

(defmethod init-skel! ((this demon-chicken))
  (initialize-skeleton this *flutflut-sg* '())
  (set! (-> this draw origin-joint-index) (the uint 6))
  (set! (-> this draw shadow-joint-index) (the uint 6))
  (set! (-> this skel effect) (the effect-control #f))
  (logior! (-> this skel status) (janim-status eye))
  (set! (-> this draw shadow-ctrl) *target-shadow-control*)
  (let ((scale 0.25))
    (set! (-> this root scale x) scale)
    (set! (-> this root scale y) scale)
    (set! (-> this root scale z) scale))
  ;;Shiny chicken
  (when (= (rand-vu-int-range 0 4096) 4096)
    (set! (-> this draw color-mult x) (rand-vu-float-range 0.0 70.0))
    (set! (-> this draw color-mult y) (rand-vu-float-range 0.0 70.0))
    (set! (-> this draw color-mult z) (rand-vu-float-range 0.0 70.0)))
  (none))

(defmethod common-init! ((this demon-chicken))
  (init-collision! this)
  ;; (set! (-> this mask) (logior (process-mask enemy) (-> this mask)))
  ;; (logclear! (-> this mask) (process-mask actor-pause))
  (init-skel! this)
  (set! (-> this align) (new 'process 'align-control this))
  (set! (-> this notice-dist) NOTICE_DIST)
  (set! (-> this stop-chase-dist) STOP_CHASE_DIST)
  (set! (-> this anim-speed) 1.0)
  (set! (-> this traj-time) 1.0)
  (set! (-> this grace-period) (seconds 0))
  (set! (-> this to-point-speed) 6.0)
  (set! (-> this substate) 'uncollected)
  (set! (-> this parent-cell-name) "NOT SET")
  (set! (-> this last-retrieved?) (seconds 0.0))
  (set! (-> this locked?) #f)
  ;;(set! (-> this part) (create-launch-control (-> *part-group-id-table* 800) this))
  (none))

(defun update-chicken-substate ((chicken demon-chicken) (state symbol))
  (when done-init?
    (case state
      (('following) (vector-copy! (-> chicken target-pos) (-> *target* root trans)) (set! (-> chicken substate) 'following))
      (('waiting-to-return) (set! (-> chicken substate) 'waiting-to-return))
      (('moving-to-portal) (set! (-> chicken to-point-speed) 10.0) (set! (-> chicken substate) 'moving-to-portal))
      (('uncollected) (set! (-> chicken to-point-speed) 6.0) (set! (-> chicken substate) 'uncollected))
      (else (play-sound-file "codemistake.mp3" 3000))))
  #t)

(defbehavior demon-chicken-init-by-other demon-chicken ((vec vector))
  (common-init! self)
  (set! (-> self to-point-speed) 6.0)
  (set! (-> self cshape trans quad) (-> vec quad))
  (go demon-chicken-dormant)
  (none))

(defmethod init-from-entity! ((this demon-chicken) (entity entity-actor))
  (common-init! this)
  (process-drawable-from-entity! this entity)
  (go demon-chicken-dormant)
  (none))

(defbehavior demon-chicken-follow-trajectory demon-chicken ((time float))
  ;; make chickens run back and forth when idle
  (when (and (-> *pc-settings* speedrunner-mode?) (= (-> self substate) 'waiting-to-return))
    (let ((traj (-> self trajectory)))
      (eval-position! traj time (-> self cshape trans))
      (eval-velocity! traj time (-> self cshape transv)))
    (vector-normalize-copy! (-> self dir) (-> self cshape transv) 1.0)
    (forward-up->quaternion (-> self cshape quat) (-> self dir) *up-vector*))
  (when (and (or (not (= (-> self substate) 'waiting-to-return)) (not (-> *pc-settings* speedrunner-mode?)))
             (> (vector-vector-distance (-> self root trans) (-> self target-pos)) (meters 0.5)))
    (let ((traj (-> self trajectory)))
      (eval-position! traj time (-> self cshape trans))
      (eval-velocity! traj time (-> self cshape transv)))
    (vector-normalize-copy! (-> self dir) (-> self cshape transv) 1.0)
    (forward-up->quaternion (-> self cshape quat) (-> self dir) *up-vector*))
  (none))

(defbehavior send-attack! demon-chicken ((proc process) (tshapes touching-shapes-entry))
  ;; (when (and (logtest? (-> *target* control root-prim prim-core action) (collide-action racer))
  ;;            (send-event proc 'attack tshapes (static-attack-info ((mode 'explode)))))
  ;;   (set-collide-offense (-> self cshape) 1 (collide-offense no-offense))
  ;;   #t
  ;;   )
  ;; (when (send-event proc 'attack tshapes (static-attack-info ((mode 'death))))
  ;;   (set-collide-offense (-> self cshape) 1 (collide-offense no-offense))
  ;;   #t
  ;;   )
  #f)

(defmethod touch-handler ((this demon-chicken) (proc process) (msg event-message-block))
  (let ((target-anim (-> *target* skel channel 0 frame-group name))
        (level (aif (level-get-target-inside *level*) (-> it name) #f)))
    (when (or (> (-> this grace-period) (seconds 0))
              (and (string= target-anim "eichar-launch-jump") ;; hack to prevent dying after launching out of the temple/helix
                   (or (= level 'jungle) (= level 'jungleb) (= level 'sunken) (= level 'sunkenb))))
      (return #f)))
  (when (prims-touching? (the touching-shapes-entry (-> msg param 0)) (-> this cshape) (the uint 1))
    (when (send-attack! proc (the touching-shapes-entry (-> msg param 0)))
      ;; (go demon-chicken-victory)
      #t)))

(defbehavior demon-chicken-event-handler demon-chicken ((proc process) (arg1 int) (event symbol) (msg event-message-block))
  (case event
    (('touch 'attack) (when (= (-> proc type) target) (touch-handler self proc msg)))))

(defmethod target-in-range? ((this demon-chicken) (dist float))
  "Is [[target]] close enough?"
  (and *target* (< (vector-vector-distance (-> this target-pos) (-> this cshape trans)) dist)))

(defmethod should-chase? ((this demon-chicken))
  "Should we chase after [[target]]?"
  (if *target*
    (let* ((state (-> *target* next-state name))
           (exclude-state? (nmember state
                                    '(target-racing-get-on target-racing-get-off
                                                          target-racing-get-off-jump
                                                          target-flut-get-on
                                                          target-flut-get-off
                                                          target-flut-get-off-jump
                                                          target-warp-in
                                                          target-warp-out))))
      (and (not (logtest? (-> *target* state-flags)
                          (state-flags grabbed being-attacked invulnerable timed-invulnerable invuln-powerup do-not-notice dying)))
           (target-in-range? this (-> this notice-dist))
           (not (or exclude-state?
                    (aif (process-by-ename "billy-2") (= (-> it next-state name) 'billy-playing)) ;; rats
                    (aif (the level-hint (process-by-name "level-hint" *active-pool*)) (string= (-> it sound-to-play) "gamcam20")))) ;; mole cam
           (= (-> this grace-period) (seconds 0))))
    #f))

(defmethod move! ((this demon-chicken))
  "Update our position."
  (collide-shape-moving-method-58 (-> this cshape) (-> this cshape transv))
  (none))

(defbehavior demon-chicken-post demon-chicken ()
  "Basic post: Update grace period, shadow, joint control and disable sidekick."
  (update-direction-from-time-of-day (-> self draw shadow-ctrl))
  (false! (-> *setting-control* default play-hints))
  ;; joint control debug prints
  (if ORANGE_DEMON_DEBUG (aif (-> self skel) (debug-print-channels it (the symbol *stdcon*))))
  (if (= (-> *target* next-state name) 'target-continue) (set! (-> self grace-period) (current-time)))
  (if (> (- (current-time) (-> self grace-period)) (seconds 2)) (set! (-> self grace-period) (seconds 0)))
  (ja-post)
  (none))

(defbehavior sleep-code process ()
  (loop
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend))
  (none))

(defbehavior demon-chicken-chase-post demon-chicken ()
  "Chase post: Poll [[target]]'s position and update our own position, direction and trajectory time."
  ;;(set! (-> self target-pos quad) (-> (target-pos 0) quad))
  (when (and *show-debug* *draw-chicken-information*)
    (add-debug-sphere #t (bucket-id debug-no-zbuf) (-> self target-pos) (meters 0.05) *color-red*)
    (when (= (-> self substate) 'moving-to-portal)
      (add-debug-text-3d #t
                         (bucket-id debug-no-zbuf)
                         (string-format "~S" (-> self name))
                         (-> self root trans)
                         (font-color red)
                         (the-as vector2h #f))))
  ;;(set! (-> self target-pos quad) (-> (adjust-chick-origin (find-best-master-mark)) quad))
  ;;Here we should check the demons distance to its target, if its too far away just teleport it to target
  (if (and (> (vector-vector-xz-distance (-> self root trans) (-> self target-pos)) (meters 10.0)))
    (begin
      (vector-copy! (-> self root trans) (-> self target-pos))))
  (set! (-> self traj-time) 1.0)
  ;;(format *stdcon* "traj-time ~f~%" (-> self traj-time))
  (let ((fnt (new 'stack 'font-context *font-default-matrix* 170 130 0.0 (font-color red) (font-flags shadow kerning middle)))
        (percent (cond
                   ((<= (-> self traj-time) 0.47) 100.0)
                   (else (+ 47.0 (calculate-completion (the progress #f)))))))
    (none)
    ;;(print-game-text (string-format "speed: ~,,2f%~%" percent) fnt #f 128 12)
    )
  (compute-alignment! (-> self align))
  (move! self)
  (demon-chicken-post)
  (none))

;; dormant state: if target is not active, hide
(defstate demon-chicken-dormant (demon-chicken)
  :event demon-chicken-event-handler
  :enter
    (behavior ()
      (logior! (-> self draw status) (draw-status hidden))
      (clear-collide-with-as (-> self cshape))
      (none))
  :code
    (behavior ()
      (sleep-code))
  :trans
    (behavior ()
      (when *target*
        (go demon-chicken-idle))
      (none))
  :exit
    (behavior ()
      (logclear! (-> self draw status) (draw-status hidden))
      (restore-collide-with-as (-> self cshape))
      (none)))

;; idle state: target was hit/grace period is active/etc.
(defstate demon-chicken-idle (demon-chicken)
  :event demon-chicken-event-handler
  :enter
    (behavior ()
      ;; (if (and (!= (-> self draw status) (the draw-status 17))
      ;;          (< (vector-vector-distance (target-pos 0) (-> self root trans)) (meters 100.0)))
      ;;   ;;Show demon chick
      ;;   (set! (-> self draw status) (the draw-status 17))
      ;;   ;;Hide demon chick
      ;;   (logior! (-> self draw status) (draw-status hidden)))
      (set! (-> self state-time) (current-time))
      (none))
  :code
    (behavior ()
      (loop
        ;; (if (and (!= (-> self draw status) (the draw-status 17))
        ;;          (< (vector-vector-distance (target-pos 0) (-> self root trans)) (meters 100.0)))
        ;;   ;;Show demon chick
        ;;   (set! (-> self draw status) (the draw-status 17))
        ;;   ;;Hide demon chick
        ;;   (logior! (-> self draw status) (draw-status hidden)))
        (ja-channel-set! 1)
        (ja-no-eval :group! flut-saddle-flut-run-ja :num! min)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))))
      (none))
  :trans
    (behavior ()
      (if (and (>= (- (current-time) (-> self state-time)) (seconds 0.017)) ;; probably need this so bones have run at least once? crashes otherwise
               (should-chase? self)
               (nonzero? (-> self draw)))
        (go demon-chicken-chase))
      (none))
  :post demon-chicken-post)

(defstate demon-chicken-chase (demon-chicken)
  :event demon-chicken-event-handler
  :enter
    (behavior ()
      (set! (-> self state-time) (current-time))
      (none))
  :code
    (behavior ()
      (ja-channel-push! 1 (seconds 0.2))
      (ja :group! flut-saddle-flut-run-ja :num! min)
      (loop
        ;;(spawn (-> self part) (the vector (-> self cshape root-prim prim-core))) ;; fire rings
        ;; set up trajectory to follow target
        ;;hack doesnt work(set! (-> self traj-time) 1.0)
        ;; (if (and (!= (-> self draw status) (the draw-status 17))
        ;;          (< (vector-vector-distance (target-pos 0) (-> self root trans)) (meters 100.0)))
        ;;   ;;Show demon chick
        ;;   (set! (-> self draw status) (the draw-status 17))
        ;;   ;;Hide demon chick
        ;;   (logior! (-> self draw status) (draw-status hidden)))
        (setup-from-to-duration-scaled! (-> self trajectory)
                                        (-> self cshape trans)
                                        (-> self target-pos)
                                        (-> self traj-time)
                                        0.0
                                        (-> self to-point-speed))
        (demon-chicken-follow-trajectory (ja-aframe-num 1))
        (when ORANGE_DEMON_DEBUG
          (debug-draw! (-> self trajectory))
          (debug-draw-text! self))
        (suspend)
        ;; speed up animation when getting closer to target
        (+ 1.0 (1/ (vector-vector-xz-distance (-> self target-pos) (-> self cshape trans))))
        (ja :num! (loop!)))
      (none))
  :trans
    (behavior ()
      (if (not (should-chase? self)) (go demon-chicken-dormant))
      (none))
  :post demon-chicken-chase-post)

(defun target-pos-with-offset ()
  (let ((vec (new-stack-vector0))
        (offset (new-stack-vector0))
        (negative? (= 1 (rand-vu-int-range 1 10))))
    (vector-copy! vec *Origin*)
    ;; add a random offset
    (set-vector! offset
                 (* (if negative? -1.0 1.0) (meters (rand-vu-int-range 20 30)))
                 (meters (rand-vu-int-range 0 10))
                 (* (if negative? -1.0 1.0) (meters (rand-vu-int-range 20 30)))
                 (meters 0))
    (vector+! vec vec offset))
  ;;Where a demon chicken spawns in
  ;; (adjust-chick-origin (find-best-master-mark))
  )

(defun start2 ()
  (process-spawn demon-chicken (target-pos-with-offset) :from *demon-chicken-dead-pool* :to *demon-chicken-pool*))

(defun chicken-pls ()
  (define *chicken-0* (-> (start2) 0))
  (set! (-> *chicken-0* name) "chicken-0")
  (set! (-> *flock* chicks 0) (process->handle *chicken-0*))
  (set! *target-chicken* *chicken-0*)
  (define *chicken-1* (-> (start2) 0))
  (set! (-> *chicken-1* name) "chicken-1")
  (set! (-> *flock* chicks 1) (process->handle *chicken-1*))
  (define *chicken-2* (-> (start2) 0))
  (set! (-> *chicken-2* name) "chicken-2")
  (set! (-> *flock* chicks 2) (process->handle *chicken-2*))
  (define *chicken-3* (-> (start2) 0))
  (set! (-> *chicken-3* name) "chicken-3")
  (set! (-> *flock* chicks 3) (process->handle *chicken-3*))
  (define *chicken-4* (-> (start2) 0))
  (set! (-> *chicken-4* name) "chicken-4")
  (set! (-> *flock* chicks 4) (process->handle *chicken-4*))
  (define *chicken-5* (-> (start2) 0))
  (set! (-> *chicken-5* name) "chicken-5")
  (set! (-> *flock* chicks 5) (process->handle *chicken-5*))
  (define *chicken-6* (-> (start2) 0))
  (set! (-> *chicken-6* name) "chicken-6")
  (set! (-> *flock* chicks 6) (process->handle *chicken-6*))
  (define *chicken-7* (-> (start2) 0))
  (set! (-> *chicken-7* name) "chicken-7")
  (set! (-> *flock* chicks 7) (process->handle *chicken-7*))
  (define *chicken-8* (-> (start2) 0))
  (set! (-> *chicken-8* name) "chicken-8")
  (set! (-> *flock* chicks 8) (process->handle *chicken-8*))
  (define *chicken-9* (-> (start2) 0))
  (set! (-> *chicken-9* name) "chicken-9")
  (set! (-> *flock* chicks 9) (process->handle *chicken-9*))
  (define *chicken-10* (-> (start2) 0))
  (set! (-> *chicken-10* name) "chicken-10")
  (set! (-> *flock* chicks 10) (process->handle *chicken-10*))
  (define *chicken-11* (-> (start2) 0))
  (set! (-> *chicken-11* name) "chicken-11")
  (set! (-> *flock* chicks 11) (process->handle *chicken-11*))
  (none))

(defun vegan ()
  (kill-by-name "target-3" *active-pool*)
  (none))

(defmethod run-logic? ((this demon-chicken))
  #t)

(defmethod dist-to-target ((this demon-chicken))
  (vector-vector-distance (-> this cshape trans) (-> this target-pos)))

(defmethod deactivate ((this demon-chicken))
  ((method-of-type process-drawable deactivate) this)
  (none))

(defun point-at-origin? ()
  (dotimes (i NUM_FLOCKPOINTS)
    (if (= (vector-vector-distance (-> *flock-points* points i) *Origin*) 0.0) (return #t)))
  (return #f)
  #f)

(defun point-close-to-another? ((vec vector))
  (dotimes (i NUM_FLOCKPOINTS)
    (if (> (vector-vector-xz-distance vec (-> *flock-points* points i)) (meters 0.1)) (return #t)))
  #f)

(defun return-point-at-origin? ()
  (dotimes (i NUM_FLOCKPOINTS)
    (if (= (vector-vector-distance (-> *return-points* points i) *Origin-R*) 0.0) (return #t)))
  (return #f)
  #f)

(defun return-point-close-to-another? ((vec vector))
  (dotimes (i NUM_FLOCKPOINTS)
    (if (> (vector-vector-xz-distance vec (-> *return-points* points i)) (meters 0.1)) (return #t)))
  #f)

(defun set-flock-false ()
  "initalizes the flock to #f to avoid crashes when referencing."
  (dotimes (i NUM_FLOCKPOINTS)
    (set! (-> *flock* chicks i) (the handle #f))))

(defun set-flock-points-start ()
  (dotimes (i NUM_FLOCKPOINTS)
    (vector-identity! (-> *flock-points* points i))))

(defun set-flock-points ()
  (let ((old-origin (new 'static 'vector :x (meters 32.0085) :y (meters 300.1105) :z (meters 153.0149) :w 1.0)))
    (dotimes (i NUM_FLOCKPOINTS)
      ;; If we dont have a point at the origin addone there
      (when (not (point-at-origin?))
        ;;(format #t "There was no chicken at origin, assiging chicken ~D now ~%" i)
        (vector-copy! (-> *flock-points* points i) *Origin*))
      ;;Do this so we can save the old origin
      (vector-copy! old-origin *Origin*)
      ;; If we are too close to another point, then keep making random spots until we arent
      ;;This should be a (while valid?... instead of (when close...
      (when (point-close-to-another? old-origin)
        ;;(format #t "MAKING NEW POS~%")
        (set! (-> old-origin x) (+ (-> old-origin x) (rand-vu-float-range 0.0 (meters 2))))
        ;;(set! (-> old-origin y) (+ (-> old-origin y) (rand-vu-float-range 0.0 (meters 1))))
        (set! (-> old-origin z) (+ (-> old-origin z) (rand-vu-float-range 0.0 (meters 2)))))
      ;;store it in the list of points
      (vector-copy! (-> *flock-points* points i) old-origin))))

(defun set-return-points ()
  (if (= (-> *Origin-R* x) (meters 3.0)) (vector-copy! *Origin-R* (get-chicken-initial-return-point)))
  (let ((old-origin (new 'static 'vector :x (meters 32.0085) :y (meters 300.1105) :z (meters 153.0149) :w 1.0)))
    (dotimes (i NUM_FLOCKPOINTS)
      ;; If we dont have a point at the origin addone there
      (when (not (return-point-at-origin?))
        ;;(format #t "There was no chicken at origin, assiging chicken ~D now ~%" i)
        (vector-copy! (-> *return-points* points i) *Origin-R*))
      ;;Do this so we can save the old origin
      (vector-copy! old-origin *Origin-R*)
      ;; If we are too close to another point, then keep making random spots until we arent
      ;;This should be a (while valid?... instead of (when close...
      (when (return-point-close-to-another? old-origin)
        ;;(format #t "MAKING NEW POS~%")
        (set! (-> old-origin x) (+ (-> old-origin x) (rand-vu-float-range 0.0 (meters 2))))
        ;;(set! (-> old-origin y) (+ (-> old-origin y) (rand-vu-float-range 0.0 (meters 1))))
        (set! (-> old-origin z) (+ (-> old-origin z) (rand-vu-float-range 0.0 (meters 2)))))
      ;;store it in the list of points
      (vector-copy! (-> *return-points* points i) old-origin))))

(defun move-return-flock-by-xz ((xchange float) (ychange float) (zchange float))
  (dotimes (i NUM_FLOCKPOINTS)
    (set! (-> *return-points* points i x) (- (-> *return-points* points i x) xchange))
    (set! (-> *return-points* points i y) (- (-> *return-points* points i y) ychange))
    (set! (-> *return-points* points i z) (- (-> *return-points* points i z) zchange))
    ;;(format #t "Moved flock by X ~D Y ~D Z ~D~%" xchange ychange zchange)
    )
  (none))

(defun move-flock-by-xz ((xchange float) (ychange float) (zchange float))
  (dotimes (i NUM_FLOCKPOINTS)
    (set! (-> *flock-points* points i x) (- (-> *flock-points* points i x) xchange))
    (set! (-> *flock-points* points i y) (- (-> *flock-points* points i y) ychange))
    (set! (-> *flock-points* points i z) (- (-> *flock-points* points i z) zchange))
    ;;(format #t "Moved flock by X ~D Y ~D Z ~D~%" xchange ychange zchange)
    )
  (none))

(defun portal-mort-switch ()
  (the-as warp-gate-switch (process-by-ename "project-warp-gate-switch")))

(defun get-saved-chicks-from-mem ()
  ;;(format #t "getting unlock level it is ~D~%" (-> *game-info* money-per-level 3))
  (the int (-> *game-info* money-per-level 5)))

(defun get-chick-from-flock ((idx int))
  ;; Chicken indexes are 0-11 (- NUM_FLOCKPOINTS 1)
  (when (or (< idx 0) (>= idx NUM_FLOCKPOINTS))
    (format #t (string-format "AHHH idx in get-chick-from-flock is outside of bounds value of idx was ~D~%" idx))
    (suspend)
    (set! *target* (the-as target 46327846237649324325.0))
    ;;break
    )
  (when *flock*
    (if (the demon-chicken (handle->process (-> *flock* chicks idx)))
      (return (the demon-chicken (handle->process (-> *flock* chicks idx))))
      (return (the demon-chicken #f))))
  (the demon-chicken #f))

(defun draw-beta-flock-points ()
  ;;beta function to draw spheres assiend my set-flock-points
  (when (and *show-debug* *draw-chicken-information*)
    (dotimes (i NUM_FLOCKPOINTS)
      ;;draw a black circle where a chick is trying to get to.
      (add-debug-sphere #t (bucket-id debug-no-zbuf) (-> (get-chick-from-flock i) target-pos) (meters 0.10) *color-black*)
      ;;draw index of chick trying to get to black circle
      (add-debug-text-3d #t
                         (bucket-id debug-no-zbuf)
                         (string-format "~D" i)
                         (-> (get-chick-from-flock i) target-pos)
                         (font-color red)
                         (the-as vector2h #f))
      ;;draw all possible flockpoints
      (add-debug-sphere #t (bucket-id debug-no-zbuf) (-> *flock-points* points i) (meters 0.05) *color-cyan*)
      (add-debug-sphere #t (bucket-id debug-no-zbuf) (-> *return-points* points i) (meters 0.05) *color-magenta*))
    ;; (add-debug-sphere #t (bucket-id debug-no-zbuf) (-> *flock-points* points i) (meters 0.1) *color-green*)
    )
  (none))

(defun get-current-chicks ()
  (when done-init?
    (let* ((current-chick-num 0))
      (dotimes (i NUM_FLOCKPOINTS)
        (when (and (get-chick-from-flock i) (= (-> (get-chick-from-flock i) substate) 'following) (+! current-chick-num 1))))
      (return current-chick-num)))
  0)

(defun get-uncollected-chicks ()
  (when done-init?
    (let* ((current-chick-num 0))
      (dotimes (i NUM_FLOCKPOINTS)
        (when (and (get-chick-from-flock i) (= (-> (get-chick-from-flock i) substate) 'uncollected) (+! current-chick-num 1))))
      (return current-chick-num)))
  0)

(defun get-to-portal-chicks ()
  (when done-init?
    (let* ((current-chick-num 0))
      (dotimes (i NUM_FLOCKPOINTS)
        (when (and (get-chick-from-flock i) (= (-> (get-chick-from-flock i) substate) 'moving-to-portal) (+! current-chick-num 1))))
      (return current-chick-num)))
  0)

(defun get-waiting-chicks ()
  (when done-init?
    (let* ((current-chick-num 0))
      (dotimes (i NUM_FLOCKPOINTS)
        (when (and (get-chick-from-flock i) (= (-> (get-chick-from-flock i) substate) 'waiting-to-return) (+! current-chick-num 1))))
      (return current-chick-num)))
  0)

(defun get-chick-with-state ((state symbol))
  "takes in a substate and returns the first chicken in the pool with said sate"
  (when done-init?
    (dotimes (i NUM_FLOCKPOINTS)
      (when (and (get-chick-from-flock i) (= (-> (get-chick-from-flock i) substate) state))
        (set! (-> (get-chick-from-flock i) last-retrieved?) (current-time))
        (return (get-chick-from-flock i)))))
  ;;Some function requested a chicken in some state we dont have, something is wrong, this is essentially my version of an assert
  (format #t
          (string-format "SOMEONE ASKED FOR A CHICKEN IN STATE ~A BUT WE DONT HAVE IT ~D~%" state (get-current-chicks)))
  (set! (-> (get-chick-from-flock 0) root scale y) 3.0)
  (get-chick-from-flock 0))

;; (defun vector-copy! ((dst vector) (src vector))
;;   "Copy vector src to dst. Copies the entire quadword (xyzw).
;;    The vectors must be aligned."
;;      (declare (inline))
;;    (when (and (= dst (-> (get-chick-with-state 'moving-to-portal) target-pos))  (= (-> src x) 0.0))
;;         (format #t (string-format "Set a moving-to-portal to 0.0~%" ))
;;         (suspend)
;;         (set! *target* (the-as target "thejks"))
;;    )

;;   (rlet ((vf1 :class vf :reset-here #t)) (.lvf vf1 src) (.svf dst vf1))
;;   dst)

(defun get-saved-chicks ()
  (let ((lvl-idx (-> *level-task-data-remap* (+ (-> (level-get-target-inside *level*) info index) -1))))
    (if (and (>= lvl-idx 16) (< lvl-idx 35)) ;; (not (>= (-> *game-info* blackout-time) (current-time)))
      (-> *custom-level-info* data lvl-idx saved-chicks)
      0)))

(defun chicken-going-to-portal? ()
  ;;Is a chicken going to the portal?
  (when mort-level?
    (dotimes (i NUM_FLOCKPOINTS)
      (if (or (= (-> (get-chick-from-flock i) substate) 'moving-to-portal)
              (= (-> (get-chick-from-flock i) substate) 'waiting-to-return))
        (return #t))
      #f)))

(defun get-chicken-initial-return-point ()
  (let* ((warpgate-pos (-> (the-as process-drawable (process-by-ename "project-training-part-1")) root trans)) ;; point A
         (target-pos (-> *target* root trans)) ;; point B
         (circle-radius (meters 7.5)) ;; desired distance from warpgate-pos
         (vector-AB (new 'static 'vector)) ;; vector from A to B (ignoring y)
         (normalized-AB (new 'static 'vector)) ;; normalized direction vector
         (final-point (new 'static 'vector)) ;; final point on the circle
         (magnitude 0.0))
    ;; Calculate vector AB by subtracting warpgate-pos from target-pos (ignoring y)
    (set! (-> vector-AB x) (- (-> target-pos x) (-> warpgate-pos x)))
    (set! (-> vector-AB z) (- (-> target-pos z) (-> warpgate-pos z)))
    (set! (-> vector-AB y) 0.0) ;; Ignore y component for direction
    ;; Draw initial points for reference
    (when *draw-chicken-information*
      (draw-origin-sphere-text warpgate-pos "warpgate/vector A")
      (draw-origin-sphere-text target-pos "target/vector B")
      (draw-origin-sphere-text vector-AB "Vector AB (ignoring y)"))
    ;; Normalize vector AB to get a unit direction vector
    (set! magnitude (sqrtf (+ (* (-> vector-AB x) (-> vector-AB x)) (* (-> vector-AB z) (-> vector-AB z)))))
    (if (= magnitude 0.0)
      (return (vector+! (-> (the-as process-drawable (process-by-ename "project-training-part-1")) root trans)
                        (-> (the-as process-drawable (process-by-ename "project-training-part-1")) root trans)
                        (vector-identity! (new-stack-vector0)))))
    (when (> magnitude 0.0)
      (set! (-> normalized-AB x) (/ (-> vector-AB x) magnitude))
      (set! (-> normalized-AB z) (/ (-> vector-AB z) magnitude)))
    ;; Scale the normalized direction vector by the circle radius
    (set! (-> normalized-AB x) (* (-> normalized-AB x) circle-radius))
    (set! (-> normalized-AB z) (* (-> normalized-AB z) circle-radius))
    ;; Calculate the final point by adding the scaled vector to warpgate-pos
    (set! (-> final-point x) (+ (-> warpgate-pos x) (-> normalized-AB x)))
    (set! (-> final-point z) (+ (-> warpgate-pos z) (-> normalized-AB z)))
    ;; Set y-coordinate to match the warpgate y-coordinate
    (set! (-> final-point y) (-> warpgate-pos y))
    ;; Draw the final point at the specified distance from warpgate-pos
    (when *draw-chicken-information*
      (draw-origin-sphere-text final-point "Point on Circle Radius (ignoring y)"))
    (return final-point))
  (the-as vector #f))

(defun reset-saved-chick-in-mem ()
  (when (nonzero? (get-saved-chicks-from-mem))
    (format #t "All chicks in this level are safe, setting saved chicks mem to 0~%")
    (set! (-> *game-info* money-per-level 5) 0))
  (none))

(defun reset-custom-info ()
  "This is called when we reset the game, it is called in game-save when making a new save, and speedruns when starting a new run."
  (reset-saved-chick-in-mem)
  ;; Loop all the custom-level-info and set it to 1/0/0 first
  (dotimes (i 40)
    (set! (-> *custom-level-info* data i saved-chicks) 0)
    (set! (-> *custom-level-info* data i current-chicks) 0))
  ;;getters
  (none))

(reset-custom-info)

(defun get-total-chicks ()
  (-> *custom-level-info*
      data
      (-> *level-task-data-remap* (+ (-> (level-get-target-inside *level*) info index) -1))
      total-chicks))

(defun get-unlock-level ()
  ;;(format #t "getting unlock level it is ~D~%" (-> *game-info* money-per-level 3))
  (the int (-> *game-info* money-per-level 3)))

(defun set-unlock-level-val ((arg1 int))
  (set! (-> *game-info* money-per-level 3) (the-as uint arg1))
  (format #t "Unlocked the next level!  ~D~%" (-> *game-info* money-per-level 3))
  (none))

(defun unlock-level-func ((idx int))
  (set-unlock-level-val idx)
  (play-sound-file "end-level.wav" (the int (-> *setting-control* default sfx-volume)))
  (reset-saved-chick-in-mem)
  (auto-save-command 'auto-save 0 0 *default-pool*)
  (none))

(defun set-unlock-level ()
  "adds to the unlock level"
  (if (chicken-going-to-portal?) (return #f))
  ;; (-> *level-task-data-remap* (+ (-> (level-get-target-inside *level*)info index) -1))
  ;; (-> *custom-level-info* data (-> *level-task-data-remap* (+ (-> (level-get-target-inside *level*)info index) -1))total-chicks)
  (if (portal-mort-switch) (go-virtual-process (portal-mort-switch) basebutton-going-down))
  (case (-> *level-task-data-remap* (+ (-> (level-get-target-inside *level*) info index) -1))
    ((16) (when (< (get-unlock-level) 1) (unlock-level-func 1)))
    ((17) (when (< (get-unlock-level) 2) (unlock-level-func 2)))
    ((18) (when (< (get-unlock-level) 3) (unlock-level-func 3)))
    ((19) (when (< (get-unlock-level) 4) (unlock-level-func 4)))
    ((20) (when (< (get-unlock-level) 5) (unlock-level-func 5)))
    ((21) (when (< (get-unlock-level) 6) (unlock-level-func 6)))
    ((22) (when (< (get-unlock-level) 7) (unlock-level-func 7)))
    ((23) (when (< (get-unlock-level) 8) (unlock-level-func 8)))
    ((24) (when (< (get-unlock-level) 9) (unlock-level-func 9)))
    ((25) (when (< (get-unlock-level) 10) (unlock-level-func 10)))
    ((26) (when (< (get-unlock-level) 11) (unlock-level-func 11)))
    ((27) (when (< (get-unlock-level) 12) (unlock-level-func 12)))
    ((28) (when (< (get-unlock-level) 13) (unlock-level-func 13)))
    ((29) (when (< (get-unlock-level) 14) (unlock-level-func 14)))
    ((30) (when (< (get-unlock-level) 15) (unlock-level-func 15)))
    ((31) (when (< (get-unlock-level) 16) (unlock-level-func 16)))
    ((32) (when (< (get-unlock-level) 17) (unlock-level-func 17))))
  (none))

(defun mort-rewrite-text ()
  ;;mort debugging
  ;; this is a debug checking text to see certain values
  (when (and (portal-mort-switch) (!= (-> (level-get-target-inside *level*) name) 'mort-title))
    (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf))
                                 (bucket-id subtitle)
                                 (or *debug-segment* (and (not *debug-segment*) (= (the int (-> *setting-control* default sfx-volume) 1)))))
      (draw-string-xy (string-format "Will Remove soon!~%Mort Rewrite info ~%Chicks in memory card: ~D ~%Total Chicks is is ~D~%Current Chicks is is ~D~%saved Chicks is is ~D~%Chicken going to portal? ~A~%Unlock lvl is ~D~%"
                                     (get-saved-chicks-from-mem)
                                     (get-total-chicks)
                                     (get-current-chicks)
                                     (get-saved-chicks)
                                     (-> *target* next-state name)
                                     (get-unlock-level))
                      buf
                      (- 400 70)
                      (- 150 (* 8 16))
                      (font-color flat-yellow)
                      (font-flags shadow kerning))))
  (none))

(defun assign-remove-demon-chicken-target ()
  (dotimes (i NUM_FLOCKPOINTS)
    ;;(format #t "~D" i)
    (when (= (-> (get-chick-from-flock i) substate) 'following)
      (set! (-> (get-chick-from-flock i) target-pos quad) (-> *flock-points* points i quad))
      ;; Once we warp the chick out restore its "fast" speed
      (set! (-> (get-chick-from-flock i) to-point-speed) 6.0)
      (when (and *show-debug* *draw-chicken-information*)
        (add-debug-text-3d #t
                           (bucket-id debug-no-zbuf)
                           (string-format "~D" i)
                           (-> (get-chick-from-flock i) target-pos)
                           (font-color green)
                           (the-as vector2h #f))
        (add-debug-text-3d #t
                           (bucket-id debug-no-zbuf)
                           (string-format "~S" (-> (get-chick-from-flock i) parent-cell-name))
                           (-> (get-chick-from-flock i) target-pos)
                           (font-color green)
                           (the-as vector2h #f))))))

;;TWO FUNCTION??
(defun update-saved-chicks ((amount int))
  (set! (-> *custom-level-info*
            data
            (-> *level-task-data-remap* (+ (-> (level-get-target-inside *level*) info index) -1))
            saved-chicks)
        amount)
  (none))

(defun update-saved-chicks-in-mem ((arg1 int))
  "adds to the unlock level"
  (when (= (get-saved-chicks) (get-total-chicks))
    (reset-saved-chick-in-mem)
    (auto-save-command 'auto-save 0 0 *default-pool*)
    (return #f))
  (set! (-> *game-info* money-per-level 5) (+ (-> *game-info* money-per-level 5) (the-as uint arg1)))
  (when *debug-segment*
    (format #t "Adding saved chick vale to mem stored value is now  ~D~%" (-> *game-info* money-per-level 5)))
  (none))

(defun save-chicks-func ()
  (let* ((current-level-idx (-> *level-task-data-remap* (+ (-> (level-get-target-inside *level*) info index) -1)))
         (current-custom-info (-> *custom-level-info* data current-level-idx)))
    (label func-start)
    (when (and (< (vector-vector-distance (-> *target* root trans)
                                          (-> (the-as training-part (process-by-ename "project-training-part-1")) root trans))
                  (meters 12))
               (> (get-current-chicks) 0))
      ;;We add 1 here, because we removed it above. Will need to adjust when it goes down on warp
      (dotimes (i NUM_FLOCKPOINTS)
        (when (get-chick-with-state 'following)
          (when (-> *pc-settings* speedrunner-mode?)
            (vector-copy! (-> (get-chick-with-state 'following) root trans)
                          (-> *return-points* points (rand-vu-int-range 0 NUM_FLOCKPOINTS))))
          (vector-copy! (-> (get-chick-with-state 'following) target-pos)
                        (-> *return-points* points (rand-vu-int-range 0 NUM_FLOCKPOINTS)))
          (update-chicken-substate (get-chick-with-state 'following) 'waiting-to-return))
        (goto func-start)))
    ;;chicken in waiting-state update to walk to portal then walk to portal
    )
  (none))

(defun waiting-chicks-proc-func ()
  ;; If we are dying politly wait to not be dying
  (until (not (or (not *target*)
                  (= (-> *target* state name) 'target-warp-out)
                  (= (-> *target* state name) 'target-continue)
                  (= (-> *target* state name) 'target-warp-in)
                  (= (-> *target* state name) 'target-death)
                  (= (-> *target* state name) 'target-flut-death)
                  (= (-> *target* state name) 'target-tube-death)
                  (= (-> *target* state name) 'target-racer-death)))
    (suspend))
  (when (and (> (get-waiting-chicks) 0) (= (get-to-portal-chicks) 0))
    (suspend-for (seconds 0.117))
    (when (and (> (get-waiting-chicks) 0)
               (< (vector-vector-distance (-> (get-chick-with-state 'waiting-to-return) target-pos)
                                          (-> (get-chick-with-state 'waiting-to-return) root trans))
                  (meters 1.2)))
      (vector-copy! (-> (get-chick-with-state 'waiting-to-return) target-pos)
                    (-> (the-as process-drawable (process-by-ename "project-training-part-1")) root trans))
      (if (-> *pc-settings* speedrunner-mode?)
        (vector-copy! (-> (get-chick-with-state 'waiting-to-return) root trans) (get-chicken-initial-return-point)))
      (update-chicken-substate (get-chick-with-state 'waiting-to-return) 'moving-to-portal)))
  (none))

(defun warp-demon-chick ()
  (dotimes (i NUM_FLOCKPOINTS)
    (let* ((chick (get-chick-from-flock i))
           (warpgate-pos (-> (the-as process-drawable (process-by-ename "project-training-part-1")) root trans)))
      ;; If the chicken exists, is moving to the portal, and is close to the portal
      (when (and chick
                 (= (-> chick substate) 'moving-to-portal)
                 (not (-> chick locked?)) ;; Ensure the chicken is not locked
                 (< (vector-vector-distance warpgate-pos (-> chick root trans)) (meters 0.6)))
        ;; Lock the chicken to prevent further saves
        (set! (-> chick locked?) #t)
        ;; Play portal effect on the chicken
        (when (-> chick skel effect)
          (effect-control-method-10 (-> chick skel effect) 'death-warp-in -1.0 -1))
        ;; Set their state and position
        (update-chicken-substate chick 'uncollected)
        (sound-play "warpgate-tele")
        ;; Perform save logic
        (begin
          (update-saved-chicks (+ (get-saved-chicks) 1))
          (update-saved-chicks-in-mem 1)
          (vector-identity! (-> chick target-pos))
          (vector-identity! (-> chick root trans))
          ;; Check if all chicks are saved and unlock the level
          (if (>= (get-saved-chicks) (get-total-chicks)) (set-unlock-level))
          ;; Auto-save the game state
          (auto-save-command 'auto-save 0 0 *default-pool*)))
      (set! (-> chick locked?) #f)))
  (none))
