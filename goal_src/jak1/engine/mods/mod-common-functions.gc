;;-*-Lisp-*-
(in-package goal)

;; name: mod-common-functions.gc
;; name in dgo: mod-common-functions
;; dgos: TODO

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; What is this file for.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| This file is a place where you can define custom functions and GOAL code
 to call inside of mod-custom-code.gc for example I have defined a function that increases
 the powercell count by one when it is called
 |#


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Custom Variables to use in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; teamrun
(define *teamrun-info* (the-as teamrun-player-info #f))
(define *task-update-buffer* (new 'global 'boxed-array task-info MAX_TASK_BUFFER_COUNT))

(define *has-none-position-update?* #f)
(define *allow-cell-pickup?* #t)
(define *allow-zoomer-use?* #t)
(define *allow-final-boss?* #t)


;; multiplayer
(define *multiplayer-info* (new 'global 'multiplayer-info))
(define *remote-targets* (new 'global 'boxed-array handle MAX_MULTIPLAYER_COUNT))

(define *self-player-info* (the-as remote-player-info #f))


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Custom Functions to call in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun color-target-rgb ((tgt process-drawable) (r float) (g float) (b float))
  (set! (-> tgt draw color-mult r) r)
  (set! (-> tgt draw color-mult g) g)
  (set! (-> tgt draw color-mult b) b)
  (none)
  )

(defun color-target ((tgt process-drawable) (color tgt-color))
  (case color
    (((tgt-color normal))
      (color-target-rgb tgt 1.0 1.0 1.0)
      )
    (((tgt-color white))
      (color-target-rgb tgt 10.0 10.0 10.0)
      )
    (((tgt-color black))
      (color-target-rgb tgt 0.1 0.1 0.1)
      )
    (((tgt-color red))
      (color-target-rgb tgt 0.8 0.2 0.2)
      )
    (((tgt-color green))
      (color-target-rgb tgt 0.0 1.2 0.0)
      )
    (((tgt-color blue))
      (color-target-rgb tgt 0.0 0.5 2.0)
      )
    (((tgt-color yellow))
      (color-target-rgb tgt 1.5 1.5 0.0)
      )
    (((tgt-color purple))
      (color-target-rgb tgt 0.7 0.2 2.0)
      )
    (((tgt-color pink))
      (color-target-rgb tgt 1.0 0.0 1.0)
      )
    (((tgt-color light-blue))
      (color-target-rgb tgt 0.0 1.0 1.0)
      )
    ;; (((tgt-color holo))
    ;;   (color-target-rgb tgt 
    ;;     (rand-vu-float-range 0.0 5.0)
    ;;     (rand-vu-float-range 0.0 5.0)
    ;;     (rand-vu-float-range 0.0 5.0))
    ;;   )
    )
  )


(defun set-up-self-remote-if-null ()
  (when (not *self-player-info*)
    (set! *teamrun-info* (new 'global 'teamrun-player-info))
    (set! *self-player-info* (new 'global 'remote-player-info))
    (set! (-> *self-player-info* username) "local_player") 
    (set! (-> *self-player-info* color)  (tgt-color red))
    (set! (-> *self-player-info* mp_state)  (mp-tgt-state mp-tgt-connected))
    (set! (-> *multiplayer-info* player_num) 0)

    (dotimes (idx (-> *task-update-buffer* length))
      (set! (-> *task-update-buffer* idx) (new 'global 'task-info))
      )

    (pc-connect-mp-info *multiplayer-info* *self-player-info* *teamrun-info*)
    )
  (none)
)

(defun mark-repl-connected ()
    (send-event *target* 'loading)
    (set! (-> *self-player-info* color)  (tgt-color normal))
    (set! (-> *pc-settings* ps2-actor-vis?) #f)
    (pc-acknowledge-repl-connection)
  )

(defun update-self-multiplayer-info ()
  (set! (-> *self-player-info* trans_x)    (-> *target* root trans x))
  (set! (-> *self-player-info* trans_y)    (-> *target* root trans y))
  (set! (-> *self-player-info* trans_z)    (-> *target* root trans z))
  (set! (-> *self-player-info* quat_x)     (-> *target* root quat x))
  (set! (-> *self-player-info* quat_y)     (-> *target* root quat y))
  (set! (-> *self-player-info* quat_z)     (-> *target* root quat z))
  (set! (-> *self-player-info* quat_w)     (-> *target* root quat w))
  (set! (-> *self-player-info* tgt_state)  (-> *target* state name))

  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) username)   (-> *self-player-info* username))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) color)      (-> *self-player-info* color))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_x)    (-> *target* root trans x))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_y)    (-> *target* root trans y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_z)    (-> *target* root trans z))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_x)     (-> *target* root quat x))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_y)     (-> *target* root quat y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_z)     (-> *target* root quat z))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_w)     (-> *target* root quat w))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) tgt_state)  (-> *target* state name))
  (none)
  )

(defun update-debug-self-multiplayer-info ()
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) username)   "DEBUG")
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) color)      (tgt-color red))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_x)    (-> *target* root trans x))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_y)    (-> *target* root trans y))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_z)    (-> *target* root trans z))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_x)     (-> *target* root quat x))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_y)     (-> *target* root quat y))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_z)     (-> *target* root quat z))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_w)     (-> *target* root quat w))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) tgt_state)  (-> *target* state name))
  (none)
  )


(defun target-sync-state ((tgt-state symbol) (t target))
  (case tgt-state
    ; (('target-attack))
    ;; (('target-attack-air))
    ;; (('target-attack-uppercut))
    ;; (('target-attack-uppercut-jump))
    ;; (('target-billy-game))
    ;; (('target-clone-anim))
    ;; (('target-continue))
    ;; (('target-death))
    ;; (('target-demo))
    ;; (('target-double-jump))
    ;; (('target-duck-high-jump))
    ;; (('target-duck-high-jump-jump))
    ;; (('target-duck-stance))
    ;; (('target-duck-walk))
    ;; (('target-eco-powerup) (send-event t 'powerup))
    ;; (('target-edge-grab 'target-edge-grab-jump 'target-edge-grab-off)
    ;;   (send-event t 'edge-grab)
    ;;   )
    (('target-falling) (send-event t 'change-mode 'falling))
    ;; (('target-final-door))
    ;; (('target-fishing) (send-event t 'change-mode 'fishing #f))
    ;; (('target-flop))
    ;; (('target-flop-hit-ground))
    
    (('target-flut-get-off 'target-flut-get-off-hit-ground 'target-flut-get-off-jump)
      (case (-> t state name)
        (('target-flut-air-attack 'target-flut-air-attack-hit-ground 'target-flut-clone-anim 'target-flut-death 
        'target-flut-double-jump 'target-flut-falling 'target-flut-get-on 'target-flut-grab 'target-flut-hit 'target-flut-hit-ground 
        'target-flut-jump 'target-flut-running-attack 'target-flut-stance 'target-flut-start 'target-flut-walk)
          ;; on flutflut, get off
          (send-event t 'change-mode 'normal #f)
          )
        )
      )
    (('target-flut-air-attack 'target-flut-air-attack-hit-ground 'target-flut-clone-anim 'target-flut-death 
      'target-flut-double-jump 'target-flut-falling 'target-flut-get-on 'target-flut-grab 'target-flut-hit 'target-flut-hit-ground 
      'target-flut-jump 'target-flut-running-attack 'target-flut-stance 'target-flut-start 'target-flut-walk)
      (case (-> t state name)
        (('target-racing 'target-racing-bounce 'target-racing-clone-anim 'target-racing-death 'target-racing-falling 'target-racing-get-on 
        'target-racing-grab 'target-racing-hit 'target-racing-jump  'target-racing-smack 'target-racing-start)
          ;; on zoomer, get off 
          (send-event t 'change-mode 'normal #f)
          )
        (('target-flut-air-attack 'target-flut-air-attack-hit-ground 'target-flut-clone-anim 'target-flut-death 
          'target-flut-double-jump 'target-flut-falling 'target-flut-get-on 'target-flut-grab 'target-flut-hit 'target-flut-hit-ground 
          'target-flut-jump 'target-flut-running-attack 'target-flut-stance 'target-flut-start 'target-flut-walk)
          ;; already on flutflut, do nothing
          )
        (else
          (send-event t 'change-mode 'flut #f)
          )
        )
      )
    ;; (('target-grab))
    ;; (('target-high-jump ))
    ;; (('target-hit ))
    ;; (('target-hit-ground ))
    ;; (('target-hit-ground-hard))
    ;; (('target-ice-stance))
    ;; (('target-ice-walk))
    ;; (('target-jump ))
    ;; (('target-jump-forward ))
    ;; (('target-launch))
    ;; (('target-load-wait))
    ;; (('target-look-around))
    ;; (('target-periscope))
    ;; (('target-play-anim ))
    ;; (('target-pole-cycle) (send-event t 'pole-grab))
    ;; (('target-pole-flip-forward))
    ;; (('target-pole-flip-forward-jump))
    ;; (('target-pole-flip-up))
    ;; (('target-pole-flip-up-jump))
    (('target-racing-get-off 'target-racing-get-off-hit-ground 'target-racing-get-off-jump)
      (case (-> t state name)
        (('target-racing 'target-racing-bounce 'target-racing-clone-anim 'target-racing-death 'target-racing-falling 'target-racing-get-on 
        'target-racing-grab 'target-racing-hit 'target-racing-jump  'target-racing-smack 'target-racing-start)
          ;; on zoomer, get off 
          (send-event t 'change-mode 'normal #f)
          )
        )
      )
    (('target-racing 'target-racing-bounce 'target-racing-clone-anim 'target-racing-death 'target-racing-falling 'target-racing-get-on 
      'target-racing-grab 'target-racing-hit 'target-racing-jump  'target-racing-smack 'target-racing-start)
      (case (-> t state name)
        (('target-flut-air-attack 'target-flut-air-attack-hit-ground 'target-flut-clone-anim 'target-flut-death 
          'target-flut-double-jump 'target-flut-falling 'target-flut-get-on 'target-flut-grab 'target-flut-hit 'target-flut-hit-ground 
          'target-flut-jump 'target-flut-running-attack 'target-flut-stance 'target-flut-start 'target-flut-walk)
            ;; on flutflut, get off
            (send-event t 'change-mode 'normal #f)
            )
        (('target-racing 'target-racing-bounce 'target-racing-clone-anim 'target-racing-death 'target-racing-falling 'target-racing-get-on 
          'target-racing-grab 'target-racing-hit 'target-racing-jump  'target-racing-smack 'target-racing-start)
          ;; already on zoomer, do nothing
          )
        (else
          (send-event t 'change-mode 'racing #f)
          )
        )
      )
    ;; (('target-running-attack))
    ;; (('target-slide-down))
    ;; (('target-snowball))
    ;; (('target-snowball-start))
    ;; (('target-stance))
    ;; (('target-stance-ambient))
    ;; (('target-stance-look-around))
    ;; (('target-startup))
    (('target-swim-down 'target-swim-jump 'target-swim-jump-jump 'target-swim-stance 'target-swim-up 'target-swim-walk)
      (case (-> t state name)
        (('target-swim-down 'target-swim-jump 'target-swim-jump-jump 'target-swim-stance 'target-swim-up 'target-swim-walk)
          ;; do nothing
          )
        (else
          (send-event t 'swim)
          )
        )
      )
    ;; (('target-title))
    ;; (('target-title-play))
    ;; (('target-title-wait))
    (('target-tube 'target-tube-death 'target-tube-hit 'target-tube-jump 'target-tube-start)
      (case (-> t state name)
        (('target-tube 'target-tube-death 'target-tube-hit 'target-tube-jump 'target-tube-start)
          ;; do nothing
          )
        (else
          (send-event t 'change-mode 'tube #f)
          )
        )
      )
    ;; (('target-turn-around))
    (('target-wade-stance 'target-wade-walk)
      (send-event t 'wade)
      )
    ;; (('target-walk))
    ;; (('target-warp-in))
    ;; (('target-warp-out))
    ;; (('target-wheel))
    ;; (('target-wheel-flip))
    ;; (('target-yellow-blast))
    ;; (('target-yellow-jump-blast))
    )
  (none)
  )

(defun update-actor-position ((obj process-drawable) (p remote-player-info))
  ;; position
  (set! (-> obj root trans x) (-> p trans_x))
  (set! (-> obj root trans y) (-> p trans_y))
  (set! (-> obj root trans z) (-> p trans_z))
  ;; rotation
  (set! (-> obj root quat x)  (-> p quat_x))
  (set! (-> obj root quat y)  (-> p quat_y))
  (set! (-> obj root quat z)  (-> p quat_z))
  (set! (-> obj root quat w)  (-> p quat_w))

  (color-target obj (-> p color))

  ;; additional steps for rotation, state, etc
  (case (-> obj type)
    ((target)
      (let* ((t (the target obj)) ;;!TODO: removed local-seeker? and remote-seeker? status check here, check if this is still needed
             )
        ;; draw usernames for all players
        (add-debug-text-3d
                      #t
                      (bucket-id subtitle)
                      (-> p username)
                      (-> t root trans)
                      (font-color white)
                      (new 'static 'vector2h :y 16)
                      )

        ;; activate nuka glitch for other targets
        (logior! (-> t state-flags) (state-flags dying))

        ;; finalize rotation
        (quaternion-copy! (-> t control dir-targ) (-> t root quat))
          
        ;; sync target state
        (target-sync-state (-> p tgt_state) t)
        )
      )
    ((money)
      (let ((m (the money obj)))
        (vector-copy! (-> m base) (-> m root trans))
        (vector-copy! (-> m root-override root-prim world-sphere) (-> m root trans))
        )
      )
    )
    (none)
  )

(defun start-extra-target ()
  (ppointer->handle (process-spawn
                target
                :init init-target
                  (-> *game-info* current-continue)
                :from *target-dead-pool*
                :to *target-pool*
                :stack *kernel-dram-stack*
                ))
  )

(defun render-targets ()
 (dotimes (idx MAX_MULTIPLAYER_COUNT)
    (when (!= (-> *multiplayer-info* player_num) idx)
      (when (!= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-disconnected))
        ;; see if we need to spawn any remote targets
        (when (or (zero? (-> *remote-targets* idx)) (not (handle->process (-> *remote-targets* idx))))
          (set! (-> *remote-targets* idx) (start-extra-target))
          )
        ;; assume target spawned at this point 

        ;; position/color remote targets
        (let ((p (-> *multiplayer-info* players idx))
              (obj (the process-drawable (handle->process (-> *remote-targets* idx)))))
          (when obj
            (update-actor-position obj p)
            )
          )
        )
      )
    ) 
  )


(defun get-target ((idx int))
  (if (= (-> *multiplayer-info* player_num) -1)
    (if (= idx 0)
      *target*
      (the-as target #f)
      )
    (if (= (-> *multiplayer-info* player_num) idx)
      *target*
      (if (and (-> *remote-targets* idx) (nonzero? (-> *remote-targets* idx)) (handle->process (-> *remote-targets* idx)))
        (the target (handle->process (-> *remote-targets* idx)))
        (the-as target #f)
        )
      )
    )
  )


;; Macros can be used more-or-less just like functions
(defmacro current-cell-count ()
  `(-> *game-info* fuel)
  )

(defmacro set-current-cell-count (count)
  `(set! (-> *game-info* fuel) ,count)
  )
  
(defun increase-power-cell-by-one ()
  (set-current-cell-count (+ (current-cell-count) 1))
  ;; with the two macros defined above, this is equivalent to
  ;; (set! (-> *game-info* fuel) (+ (-> *game-info* fuel) 1))
  (none)
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Approved Custom Functions/Macros to call in all mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; These are included with the mod base and you are welcome to use them in your mods!

(defmacro current-checkpoint-name ()
  `(-> *game-info* current-continue name)
  )

(defun set-current-checkpoint-by-name ((name string))
  (set-continue! *game-info* name)
  )

(defmacro current-level-name ()
  `(-> (level-get-target-inside *level*) name)
  )
  
(defmacro current-orb-count ()
  `(-> *game-info* money)
  )

(defmacro current-cutscene ()
  `(-> *art-control* active-stream)
  )

;;This function moves an actor to the given coordinates
;;example: (move-actor "farmer-3" 3.0 74.0 -120.0)
(defun move-actor ((actor-name string) (x float) (y float) (z float))
  (when (entity-by-name actor-name)
    (let* ((entity-actor (entity-by-name actor-name))
           (actor (-> entity-actor extra process))
           )
      (when actor
        (case (-> actor type)
          ((fuel-cell)
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the fuel-cell actor) base) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the fuel-cell actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
            (when (name= (-> (the fuel-cell actor) state name) 'wait)
              ;; only move collision when idle (messes up glowing in cutscene)
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((orb-cache-top)
            ;; don't move while its activated (let it go up/down)
            (when (not (name= (-> (the orb-cache-top actor) state name) 'orb-cache-top-activate))
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the orb-cache-top actor) basetrans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the orb-cache-top actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere z) (meters z))
              (set-vector! (-> (the orb-cache-top actor) draw origin) (meters x) (meters y) (meters z) 1.0)
              (let ((radius (-> (the process-drawable actor) draw radius))
                    (bounds (res-lump-data entity-actor 'visvol (inline-array vector)))
                    )
                (set-vector! (-> bounds 0) (- (meters x) radius) (meters y) (- (meters z) radius) 1.0)
                (set-vector! (-> bounds 1) (+ (meters x) radius) (meters y) (+ (meters z) radius) 1.0)
                )
              )
            )
          ((money)
            ;; don't move orbs if being blue-eco-sucked
            (when (not (logtest? (-> (the money actor) flags) (collectable-flags suck)))
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the money actor) base) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the money actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              (set! (-> (the money actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the money actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the money actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((crate crate-buzzer)
            ;; only move crates if they're not jumping
            (when (= (-> (the crate actor) smush amp) 0.0)
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the crate actor) base) (meters x) (meters y) (meters z) 1.0)
              ;; (set-vector! (-> (the crate actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere x) (meters x))
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere y) (meters y))
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((darkvine)
            (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
          )
          (else
            (format 0 "unexpected actor type ~S ~S ~S~%" actor-name (-> entity-actor type) (-> actor type))
            (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
            )
          )
        )
      )
    )
  (none)
  )

(defun spawn-actor-by-name ((name string))
  ;; Takes in the string of name of a actor, and spawns a new process based on the entity.
    (let* ((entity-actor (the entity-actor (entity-by-name name)))
          (type (-> entity-actor etype))
          (e-info (entity-info-lookup type))
      )
      (when (entity-by-name name)
        (init-entity 
          (get-process *default-dead-pool* type (if e-info (-> e-info heap-size) #x4000)) 
          entity-actor)
          (sound-play "buzzer-pickup")
      )
      (if (not (entity-by-name name))
          (sound-play "oof")
      )
    )
    (none)
)

;;Draws a debug sphere on the actor, takes in a string actor name and a radius for the sphere in meters
(defun draw-debug-sphere-on-actor ((actorName string)(radius float))
  (when *debug-segment*
    (when (process-by-ename actorName)
      (add-debug-sphere #t (bucket-id debug)  (-> (the-as process-drawable (process-by-ename actorName)) root trans) (meters radius) (static-rgba 0 #xff 0 #x40))
    )
  )
  (none)
)


;;This function moves a given actor to jaks current position, then prints a (move-actors) call in gk.exe
(defun move-to-jak ((arg0 string))
(format #t "move-actor code:  (move-actor ~a ~m ~m ~m)~%" arg0(-> (target-pos 0) x) (-> (target-pos 0) y) (-> (target-pos 0) z))
  (when (process-by-ename arg0)
    (set-vector!  (-> (-> (the process-drawable (process-by-ename arg0))root)trans) (-> (target-pos 0) x) (-> (target-pos 0) y) (-> (target-pos 0) z) 1.0)
    (if (type-type? (-> (process-by-ename arg0) type) crate)
    (begin
        (set! (-> (the crate (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )

     (if (type-type? (-> (process-by-ename arg0) type) money)
    (begin
        (set! (-> (the money (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )

     (if (type-type? (-> (process-by-ename arg0) type) fuel-cell)
    (begin
        (set! (-> (the fuel-cell (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )
  )
)

;; quick macro for setting vector xyz in meters, leaving w alone
(defmacro set-vector-meters! (dst x y z)
  `(set-vector! ,dst (meters ,x) (meters ,y) (meters ,z) (-> ,dst w))
  )

;; quick macro for constructing static vector with w=1
(defmacro static-vector-meters (x y z)
  `(new 'static 'vector :x (meters ,x) :y (meters ,y) :z (meters ,z) :w 1.0)
  )

;; prints vector xyz in meters
(defmacro print-vector-meters (vec &key (dst #t))
  `(format ,dst "~m ~m ~m~%" (-> ,vec x) (-> ,vec y) (-> ,vec z))
  )

;; takes a path-control and xyz values to offsets every node in the path by
(defmacro shift-path! (path x y z)
  `(let ((voff (static-vector-meters ,x ,y ,z)))
    (dotimes (idx (-> ,path num-cverts))
      (vector+! (-> ,path cverts idx) (-> ,path cverts idx) voff)
      )
    )
  )

;; prints all the nodes in a path in meters
(defmacro path-print-meters (path)
  `(dotimes (idx (-> ,path num-cverts))
    (print-vector-meters (-> ,path cverts idx))
    )
  )

;; prints the position (root trans) of a process-drawable
(defmacro pd-pos-m (procname)
  `(let* ((obj (the process-drawable (process-by-ename ,procname)))
          (vec (-> obj root trans)))
    (format 0 "~m ~m ~m~%" (-> vec x) (-> vec y) (-> vec z) 4096.0)
    (none)
    )
  )

;;This function moves an actor based on jaks position + an offset
(defun move-to-behind-jak ((arg0 string) (arg1 meters) (arg2 meters))
 (when (process-by-ename arg0)
    (set-vector!  (-> (-> (the process-drawable (process-by-ename arg0))root)trans) (-(-> (target-pos 0) x) (meters arg1)) (+ (-> (target-pos 0) y) (meters arg2)) (-(-> (target-pos 0) z)(meters arg1)) 1.0)
    (if (type-type? (-> (process-by-ename arg0) type) money)
    (begin
        (set! (-> (the money (process-by-ename arg0)) base y) (->  (target-pos 0) y) )
    )
    (none)
    )
    (if (type-type? (-> (process-by-ename arg0) type) fuel-cell)
    (begin
        (set! (-> (the fuel-cell (process-by-ename arg0)) base y) (->  (target-pos 0) y) )
    )
    (none)
    )
  )
)

;;This turns on play hints
(defun turnonplayhints ()
(set! (-> *setting-control* default play-hints) #t)
)

;;This turns off playhints
(defun turnoffplayhints()
(set! (-> *setting-control* default play-hints) #f)
)

;;This turns on collision render when called
(defun turnonCollisionmode()
  (set! *collision-renderer* #t)
  (logclear! *vu1-enable-user-menu* (vu1-renderer-mask tfrag trans-tfrag tie tie-near))
)

;;This turns off collision render when called
(defun turnoffCollisionmode()
  (set! *collision-renderer* #f)
  (logior! *vu1-enable-user-menu* (vu1-renderer-mask tfrag trans-tfrag tie tie-near))
)

;;This makes it thunder in the current level
(defun thunderTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-village2)
  (set! (-> (level-get-target-inside *level*) mood) *village2-mood*)
)

;;This makes the current level dark when called
(defun DarkesetGlitchTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-finalboss )
  (set! (-> (level-get-target-inside *level*) mood) *finalboss-mood*)
)

;;This needs fixed
(defun rainyTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-swamp)
  (set! (-> (level-get-target-inside *level*) mood) *swamp-mood*)
)

;;This needs fixed
(defun snowingTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-snow)
  (set! (-> (level-get-target-inside *level*) mood) *snow-mood*)
)

;;This makes the current levels weather the same as village1
(defun defaultWeatherTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-village1)
  (set! (-> (level-get-target-inside *level*) mood) *village1-mood*)
)

;;This moves jak to a provided coordinate example call
;;(tp-jak 0.0 12.0 32.32)
(defun tp-jak ((arg0 float)(arg1 float)(arg2 float))
  (set! (-> (target-pos 0) x) (meters arg0))
  (set! (-> (target-pos 0) y) (meters arg1))
  (set! (-> (target-pos 0) z) (meters arg2))
)

;;This returns true or false depending on if jak is within a provided distance from an actor
(defun close? ((actor-ename string) (dist float))
  (and 
    (process-by-ename actor-ename)
    (<= 
      (vector-vector-distance 
        (target-pos 0) 
        (-> (the process-drawable (process-by-ename actor-ename)) root trans)
        )
      dist
      )
    )
  )


;;This returns true or false if jak is within a bubble defined by coordiantes and width
(defun in-bubble? ((x float) (y float) (z float) (w float))
  (<= 
    (vector-vector-distance 
      (target-pos 0) 
      (set-vector! (new-stack-vector0) x y z 1.0)
      )
    (/ w 2.0)
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Jak Color functions
;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun draw-xyz ((jak target) (x float) (y float) (z float))
  (set! (-> jak draw color-mult x) x)
  (set! (-> jak draw color-mult y) y)
  (set! (-> jak draw color-mult z) z)
)
(defun draw-normal ((jak target))
  (draw-xyz jak 1.0 1.0 1.0)
)
(defun draw-white ((jak target))
  (draw-xyz jak 3.5 3.5 3.5)
)
(defun draw-black ((jak target))
  (draw-xyz jak 0.1 0.1 0.1)
)
(defun draw-red ((jak target))
  (draw-xyz jak 0.8 0.2 0.2)
)
(defun draw-green ((jak target))
  (draw-xyz jak 0.0 1.2 0.0)
)
(defun draw-blue ((jak target))
  (draw-xyz jak 0.0 0.5 2.0)
)
(defun draw-yellow ((jak target))
  (draw-xyz jak 1.5 1.5 0.0)
)
(defun draw-pink ((jak target))
  (draw-xyz jak 1.0 0.0 1.0)
)
(defun draw-light-blue ((jak target))
  (draw-xyz jak 0.0 1.0 1.0)
)



