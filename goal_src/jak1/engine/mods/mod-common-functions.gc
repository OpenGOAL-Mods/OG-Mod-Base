;;-*-Lisp-*-
(in-package goal)

;; name: mod-common-functions.gc
;; name in dgo: mod-common-functions
;; dgos: TODO

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; What is this file for.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| This file is a place where you can define custom functions and GOAL code
 to call inside of mod-custom-code.gc for example I have defined a function that increases
 the powercell count by one when it is called
 |#


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Custom Variables to use in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Custom Functions to call in mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun clean-up-interaction-data ((target remote-player-info)) ;; needs to be done in game in case we skip frames when transfering position data
  (set! (-> target inter_type) (interaction-type none))
  (set! (-> target inter_amount) 0.0)
  (set! (-> target inter_status) 0.0)
  (set! (-> target inter_name) (new 'global 'string INTERACTION_STRING_LEN (the-as string #f)))
  (set! (-> target inter_parent) (new 'global 'string INTERACTION_STRING_LEN (the-as string #f)))
  (set! (-> target inter_level) (new 'global 'string INTERACTION_STRING_LEN (the-as string #f)))
  (set! (-> target inter_cleanup) 0)
  
  (none)
  )

(defun color-target-rgb ((tgt process-drawable) (r float) (g float) (b float))
  (set! (-> tgt draw color-mult r) r)
  (set! (-> tgt draw color-mult g) g)
  (set! (-> tgt draw color-mult b) b)
  (none)
  )


(defun set-zoomer-wait-mode ()
  (set! (-> *racer-mods* target-speed) 13840.0)
  (set! (-> *racer-air-mods* target-speed) 13840.0)
  (none)
  )
(defun set-zoomer-full-mode ()
  (set! (-> *racer-mods* target-speed) 163840.0)
  (set! (-> *racer-air-mods* target-speed) 163840.0)
  (none)
  )

(defun runs-on-zoomer-entry ()
  ;; handle zoomer unlock
  (let ((level-name (symbol->string (-> (level-get-target-inside *level*) name))))
    (if (or (all-teammates-on-level-racer?)
          (and (string= level-name "firecanyon") (task-closed? (game-task firecanyon-end) (task-status need-resolution)))
          (and (string= level-name "ogre") (task-closed? (game-task ogre-end) (task-status need-resolution)))
          (and (string= level-name "lavatube") (task-closed? (game-task lavatube-balls) (task-status need-resolution)))
        )
      (unlock-zoomer-in-current-level)
      )
    )


  (if (or (= (-> *multiplayer-info* game allow_solo_hub_zoomers) 1) (= (-> *multiplayer-info* game free_for_all) 1) (not (current-level-is-zoomer-restricted?)))
    (set-zoomer-full-mode)
    (set-zoomer-wait-mode)
    )

  (none)
  )

(defun runs-on-zoomer-exit ()
  (none)
  )

(defun safe-deactivate-remote-target ((idx int))
  (let ((remote-target (-> *remote-targets* idx)))
    (when (and (-> *remote-targets* idx) (nonzero? (-> *remote-targets* idx)) (handle->process (-> *remote-targets* idx)))
      (set! (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-disconnected))
      (deactivate (handle->process remote-target))
      )
    )
  )

  (defun safe-deactivate-remote-cell ()
    (let* ((remote-cell (process-by-name "remote-cell" *active-pool*)))
      (when remote-cell
        (deactivate remote-cell)
      )
    )
  )

  (defun run-target-fuel-cell-pickup ((remote-target target))
    (when (process-close? remote-target 500000.0) ;; only run if *target* is close enough as pickup sound is global
      (let* ((remote-cell (birth-pickup-at-point (-> remote-target control trans) (pickup-type fuel-cell) 1.0 #f remote-target (the-as fact-info #f))))
        (safe-deactivate-remote-cell)
        (set! (-> (the-as fuel-cell (ppointer->process remote-cell)) name) "remote-cell")
        (go-virtual-process (the-as fuel-cell (ppointer->process remote-cell)) pickup #f (process->handle remote-target))
      )
    )
    (none)
    )

(defun color-target ((tgt process-drawable) (color tgt-color))
  (case color
    (((tgt-color normal))
      (color-target-rgb tgt 1.0 1.0 1.0)
      )
    (((tgt-color white))
      (color-target-rgb tgt 10.0 10.0 10.0)
      )
    (((tgt-color black))
      (color-target-rgb tgt 0.1 0.1 0.1)
      )
    (((tgt-color red))
      (color-target-rgb tgt 0.8 0.2 0.2)
      )
    (((tgt-color green))
      (color-target-rgb tgt 0.0 1.2 0.0)
      )
    (((tgt-color blue))
      (color-target-rgb tgt 0.0 0.5 2.0)
      )
    (((tgt-color yellow))
      (color-target-rgb tgt 1.5 1.5 0.0)
      )
    (((tgt-color purple))
      (color-target-rgb tgt 0.7 0.2 2.0)
      )
    (((tgt-color pink))
      (color-target-rgb tgt 1.0 0.0 1.0)
      )
    (((tgt-color light-blue))
      (color-target-rgb tgt 0.0 1.0 1.0)
      )
    ;; (((tgt-color holo))
    ;;   (color-target-rgb tgt 
    ;;     (rand-vu-float-range 0.0 5.0)
    ;;     (rand-vu-float-range 0.0 5.0)
    ;;     (rand-vu-float-range 0.0 5.0))
    ;;   )
    )
  )


(defun set-up-self-remote-if-null ()
  (when (not *self-player-info*)
    (set! *self-player-info* (new 'global 'remote-player-info))
    (set! (-> *self-player-info* username) (new 'global 'string MAX_USERNAME_LEN "local_player")) 
    (set! (-> *self-player-info* color)  (tgt-color red))
    (set! (-> *self-player-info* mp_state)  (mp-tgt-state mp-tgt-interactive))
    (set! (-> *multiplayer-info* client_version) (new 'global 'string INTERACTION_STRING_LEN "Not Connected"))
    (set! (-> *multiplayer-info* player_num) 0)

    (dotimes (idx (-> *interaction-update-buffer* length))
      (set! (-> *interaction-update-buffer* idx) (new 'global 'interaction-info))
      )

    (pc-connect-mp-info *multiplayer-info* *self-player-info* *teamrun-info* *teamrun-levels-info*)
    )
  (none)
)

(defun update-self-multiplayer-info ()
  (set! (-> *self-player-info* trans_x)    (-> *target* root trans x))
  (set! (-> *self-player-info* trans_y)    (-> *target* root trans y))
  (set! (-> *self-player-info* trans_z)    (-> *target* root trans z))
  (set! (-> *self-player-info* quat_x)     (-> *target* root quat x))
  (set! (-> *self-player-info* quat_y)     (-> *target* root quat y))
  (set! (-> *self-player-info* quat_z)     (-> *target* root quat z))
  (set! (-> *self-player-info* quat_w)     (-> *target* root quat w))

  (if (target-on-racer? *target*)
    (set! (-> *self-player-info* zoomer_rot_y)     (-> *target* racer rot y))
    (set! (-> *self-player-info* zoomer_rot_y)     0.0)
    )

  (set! (-> *self-player-info* tgt_state)  (-> *target* state name))

  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) username)       (-> *self-player-info* username))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) color)          (-> *self-player-info* color))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_x)        (-> *target* root trans x))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_y)        (-> *target* root trans y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) trans_z)        (-> *target* root trans z))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_x)         (-> *target* root quat x))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_y)         (-> *target* root quat y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_z)         (-> *target* root quat z))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) quat_w)         (-> *target* root quat w))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) zoomer_rot_y)   (-> *self-player-info* zoomer_rot_y))
  (set! (-> *multiplayer-info* players (-> *multiplayer-info* player_num) tgt_state)      (-> *target* state name))
  (none)
  )

(defun update-debug-self-multiplayer-info ()
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) username)   "DEBUG")
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) color)      (tgt-color red))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_x)    (-> *target* root trans x))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_y)    (-> *target* root trans y))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) trans_z)    (-> *target* root trans z))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_x)     (-> *target* root quat x))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_y)     (-> *target* root quat y))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_z)     (-> *target* root quat z))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) quat_w)     (-> *target* root quat w))
  (set! (-> *multiplayer-info* players (+ (-> *multiplayer-info* player_num) 1) tgt_state)  (-> *target* state name))
  (if (target-on-racer? *target*)
    (set! (-> *self-player-info* zoomer_rot_y)     (-> *target* racer rot y))
    )
  (none)
  )


(defun target-sync-state ((tgt-state symbol) (t target) (inter-name string))
  (case tgt-state
    ;; normal attacks (and relevant jumps) !DONE!
    (('target-running-attack) (go-process t target-running-attack))
    (('target-attack) (go-process t target-attack))
    (('target-attack-air) (go-process t target-attack-air #f))
    (('target-attack-uppercut) (go-process t target-attack-uppercut (-> *TARGET-bank* attack-jump-height-min) (-> *TARGET-bank* attack-jump-height-max)))
    (('target-attack-uppercut-jump) (go-process t target-attack-uppercut-jump (-> *TARGET-bank* attack-jump-height-min) (-> *TARGET-bank* attack-jump-height-max)))
    (('target-flop) (go-process t target-flop (the-as float 33775.48) (the-as float -122880.0)  (the-as float 0.0))) ;;ground pound
    (('target-flop-hit-ground) (go-process t target-flop-hit-ground #f))
    (('target-wheel) (go-process t target-wheel))
    (('target-wheel-flip) (go-process t target-wheel-flip (-> *TARGET-bank* wheel-flip-height) (-> *TARGET-bank* wheel-flip-dist)))
    
    ;; jumps !DONE!
    (('target-jump) (go-process t target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f)))
    (('target-double-jump) (go-process t target-double-jump (-> *TARGET-bank* double-jump-height-min) (-> *TARGET-bank* double-jump-height-max)))
    (('target-high-jump) (go-process t target-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'flip))
    (('target-duck-high-jump) (go-process t target-duck-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck))
    (('target-duck-high-jump-jump) (go-process t target-duck-high-jump-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck))

    ;; eco !DONE!
    (('target-eco-powerup) (send-event t 'powerup))
    (('target-yellow-blast) (go-process t target-yellow-blast))
    (('target-yellow-jump-blast) (go-process t target-yellow-jump-blast))
    (('target-launch) (go-process t target-launch (the-as float (-> t control unknown-dword60)) (the-as symbol (-> t control unknown-dword61)) (-> t control unknown-vector102) (-> t control unknown-dword63)))

    ;; edge grabs !DONE!
    (('target-edge-grab) (go-process t target-edge-grab))
    (('target-edge-grab-off) (go-process t target-edge-grab-off))
    (('target-edge-grab-jump) (go-process t target-edge-grab-jump (-> *TARGET-bank* edge-grab-jump-height-min) (-> *TARGET-bank* edge-grab-jump-height-max)))
    (('target-jump-forward) (go-process t target-jump-forward (-> *TARGET-bank* edge-grab-jump-height-min) (-> *TARGET-bank* edge-grab-jump-height-max)))

    ;; normal movement !DONE!
    (('target-stance) (go-process t target-stance))
    (('target-stance-ambient) (go-process t target-stance-ambient))
    (('target-walk) (go-process t target-walk))
    (('target-wade-stance) (go-process t target-wade-stance))
    (('target-wade-walk) (go-process t target-wade-walk))
    (('target-ice-stance) (go-process t target-ice-stance))
    (('target-ice-walk) (go-process t target-ice-walk))
    (('target-load-wait) (go-process t target-load-wait)) ;; trip
    (('target-slide-down) (go-process t target-slide-down)) ;; slippery surface
    (('target-turn-around) (go-process t target-turn-around))
    (('target-falling) (go-process t target-falling #f))

    ;; hit !DONE!
    (('target-hit) (go-process t target-hit 'shove (-> t attack-info-rec)))
    (('target-hit-ground) (go-process t target-hit-ground #f))
    (('target-hit-ground-hard) (go-process t target-hit-ground-hard 0.0)) ;;toggle to 1.0 to flash invuln frames)

    ;; swiming & water !TODO: swiming underwater has incorrect rotation on body
    (('target-swim-stance) (send-event t 'change-mode 'swim) (go-process t target-swim-stance))
    (('target-swim-walk) (send-event t 'change-mode 'swim) (go-process t target-swim-walk))
    (('target-swim-down) (go-process t target-swim-down))
    (('target-swim-up) (go-process t target-swim-up))
    (('target-swim-jump) (go-process t target-swim-jump (-> *TARGET-bank* swim-jump-height-min) (-> *TARGET-bank* swim-jump-height-max)))
    (('target-swim-jump-jump) (go-process t target-swim-jump-jump (-> *TARGET-bank* swim-jump-height-min) (-> *TARGET-bank* swim-jump-height-max) (the-as surface #f)))
   
    ;; duck !DONE!
    (('target-duck-stance) (go-process t target-duck-stance))
    (('target-duck-walk) (go-process t target-duck-walk))

    ;; warp gates !DONE!
    (('target-warp-out) (if (and (-> t state name) (!= (-> t state name) 'target-duck-high-jump) (!= (-> t state name) 'target-duck-high-jump-jump)) (go-process t target-duck-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck)))
    (('target-warp-in) (if (and (-> t state name) (!= (-> t state name) 'target-duck-high-jump) (!= (-> t state name) 'target-duck-high-jump-jump)) (go-process t target-duck-high-jump (-> *TARGET-bank* flip-jump-height-min) (-> *TARGET-bank* flip-jump-height-max) 'duck)))


    ;; other !DONE!
    (('target-clone-anim) (run-target-fuel-cell-pickup t))
    (('target-fishing) (send-event t 'change-mode 'fishing #f))
    (('target-periscope) (send-event t 'change-mode 'periscope #f))
    (('target-grab) (go-process t target-grab)) ;; process-grab animation while in cutscenes

    ;; redundant for multiplayer
    ;; (('target-death) (go-process t target-hit-ground-hard 0.0))
    ;; (('target-look-around) (go-process t target-look-around)) ;; first person enter
    ;; (('target-stance-look-around) (go-process t target-stance-look-around)) ;; first person exit
    ;; (('target-billy-game)) ;; will only put you in first person
    ;; (('target-play-anim))
    ;; (('target-snowball))
    ;; (('target-snowball-start))
    ;; (('target-title))
    ;; (('target-title-play))
    ;; (('target-title-wait))
    ;; (('target-continue))
    ;; (('target-demo))
    ;; (('target-startup))
    ;; (('target-final-door))

    ;; poles !DONE!
    (('target-pole-cycle) 
      (let* ((swingpole_proc (process-by-ename inter-name))
            (swingpole (process->handle swingpole_proc))
          ) 
        (when (or swingpole_proc (and (-> t state name) (!= (-> t state name) 'target-pole-flip-up-jump)))
          (if swingpole_proc
            (go-process t target-pole-cycle swingpole)
            (go-process t target-pole-flip-up-jump 28672.0 28672.0)
            )
          )
        )
      )
    (('target-pole-flip-forward) (if (and (-> t state name) (!= (-> t state name) 'target-pole-flip-up-jump)) (go-process t target-pole-flip-up-jump 28672.0 28672.0)))
    (('target-pole-flip-forward-jump) (go-process t target-pole-flip-forward-jump (the-as float 14336.0) (the-as float 14336.0)))
    (('target-pole-flip-up) (if (and (-> t state name) (!= (-> t state name) 'target-pole-flip-up-jump)) (go-process t target-pole-flip-up-jump 28672.0 28672.0)))
    (('target-pole-flip-up-jump) (go-process t target-pole-flip-up-jump 28672.0 28672.0))


    ;; tube slide !DONE!
    (('target-tube-start 'target-tube 'target-tube-jump 'target-tube-hit)

      (if (not (target-on-tube? t)) (send-event t 'change-mode 'tube #f)) ;; ensure on tube state

      (when (target-on-tube? t) 
        (case tgt-state
          (('target-tube) (go-process t target-tube))
          (('target-tube-jump) (go-process t target-tube-jump (-> *TARGET-bank* tube-jump-height-min) (-> *TARGET-bank* tube-jump-height-max)))
          ;; (('target-tube-start) (send-event t 'change-mode 'tube #f))
          ;; (('target-tube-hit) (go-process t target-hit-ground #f)
          ;; (('target-tube-death))
          )
        )
      )


    ;; zoomer !DONE!
    (('target-racing 'target-racing-start 'target-racing-get-on 'target-racing-bounce 'target-racing-clone-anim 
      'target-racing-falling 'target-racing-grab 'target-racing-hit 'target-racing-jump  'target-racing-smack)

      (if (not (target-on-racer? t)) (send-event t 'change-mode 'racing #f)) ;; ensure on racer state
      
      (when (target-on-racer? t) 
        (case tgt-state
          (('target-racing) (go-process t target-racing))
          (('target-racing-bounce) (go-process t target-racing-bounce 2048.0 2048.0 #f))
          (('target-racing-jump) (go-process t target-racing-jump 2048.0 5324.8 #t))
          (('target-racing-smack) (go-process t target-racing-smack (-> t control unknown-float01) #t))
          (('target-racing-grab) (go-process t target-racing-grab))
          (('target-racing-falling) (go-process t target-racing-falling))
          (('target-racing-clone-anim) (run-target-fuel-cell-pickup t))
          ;; (('target-racing-hit))
          )
        )
      )
    (('target-racing-get-off 'target-racing-get-off-hit-ground 'target-racing-get-off-jump 'target-racing-death)
      (if (target-on-racer? t) (send-event t 'end-mode))
      )


    ;; flut flut !DONE!
    (('target-flut-air-attack 'target-flut-air-attack-hit-ground 'target-flut-clone-anim 'target-flut-death 
      'target-flut-double-jump 'target-flut-falling 'target-flut-get-on 'target-flut-grab 'target-flut-hit 'target-flut-hit-ground 
      'target-flut-jump 'target-flut-running-attack 'target-flut-stance 'target-flut-start 'target-flut-walk)
      
      (if (not (target-on-flut? t)) (send-event t 'change-mode 'flut #f)) ;; ensure on flut state

      (when (target-on-flut? t) 
        (case tgt-state
          (('target-flut-stance) (go-process t target-flut-stance))
          (('target-flut-walk) (go-process t target-flut-walk))
          (('target-flut-falling) (go-process t target-flut-falling #f))
          (('target-flut-running-attack) (go-process t target-flut-running-attack))
          (('target-flut-jump) (go-process t target-flut-jump (-> *FLUT-bank* jump-height-min) (-> *FLUT-bank* jump-height-max)))
          (('target-flut-double-jump) (go-process t target-flut-double-jump (-> *FLUT-bank* double-jump-height-min) (-> *FLUT-bank* double-jump-height-max)))
          (('target-flut-air-attack) (go-process t target-flut-air-attack (-> *FLUT-bank* air-attack-speed)))
          (('target-flut-air-attack-hit-ground) (go-process t target-flut-air-attack-hit-ground))
          (('target-flut-grab) (go-process t target-flut-grab))
          (('target-flut-hit) (go-process t target-flut-hit 'shove (-> t attack-info-rec)))
          (('target-flut-hit-ground) (go-process t target-flut-hit-ground ))
          (('target-flut-clone-anim) (run-target-fuel-cell-pickup t))
          )
      )
      )
    (('target-flut-get-off 'target-flut-get-off-hit-ground 'target-flut-get-off-jump 'target-flut-death)
      (if (target-on-flut? t) (send-event t 'end-mode))
      )

    )
  (none)
  )

(defun update-actor-position ((obj process-drawable) (p remote-player-info))
  ;; position
  (set! (-> obj root trans x) (-> p trans_x))
  (set! (-> obj root trans y) (-> p trans_y))
  (set! (-> obj root trans z) (-> p trans_z))
  ;; rotation
  (set! (-> obj root quat x)  (-> p quat_x))
  (set! (-> obj root quat y)  (-> p quat_y))
  (set! (-> obj root quat z)  (-> p quat_z))
  (set! (-> obj root quat w)  (-> p quat_w))

  (color-target obj (-> p color))

  ;; additional steps for rotation, state, etc
  (case (-> obj type)
    ((target)
      (let* ((t (the target obj)))

        ;; zoomer rotation
        (if (target-on-racer? t)
          (set! (-> t racer rot y) (-> p zoomer_rot_y))
          )

        ;; draw usernames for all players
        (add-text-3d
                      #t
                      (bucket-id subtitle)
                      (-> p username)
                      (-> t root trans)
                      (font-color white)
                      (new 'static 'vector2h :y 16)
                      )

        ;; activate invuln for interactive and nuka glitch for ghost targets
        (if (= (-> p mp_state) (mp-tgt-state mp-tgt-interactive))
          (logior! (-> t state-flags) (state-flags invulnerable))
          (logior! (-> t state-flags) (state-flags dying))
        )

        ;; finalize rotation
        (quaternion-copy! (-> t control dir-targ) (-> t root quat))

        ;; sync target state
        (when (and (-> t state name) (!= (-> t state name) (-> p tgt_state)) 
                (or 
                  (and (!= (-> p tgt_state) 'target-clone-anim) (!= (-> p tgt_state) 'target-racing-clone-anim) (!= (-> p tgt_state) 'target-flut-clone-anim)) 
                  (and (= (-> p inter_type) (interaction-type game-task)) (= (-> p inter_status) 7)) ;; only allow fuel cells from 'target-clone-anim
                )
              )
          (target-sync-state (-> p tgt_state) t (-> p inter_name))
          )
        )
        (when (!= (-> p inter_type) (interaction-type none))
          (clean-up-interaction-data p)
          )
      )
    ((money)
      (let ((m (the money obj)))
        (vector-copy! (-> m base) (-> m root trans))
        (vector-copy! (-> m root-override root-prim world-sphere) (-> m root trans))
        )
      )
    )
    (none)
  )

(defun start-extra-target ()
  (ppointer->handle (process-spawn
                target
                :init init-target
                  (-> *game-info* current-continue)
                :from *target-dead-pool*
                :to *target-pool*
                :stack *kernel-dram-stack*
                ))
  )

(defun render-targets ()
 (let ((target-count 0))
    (dotimes (idx MAX_MULTIPLAYER_COUNT)
      (cond
        ((!= (-> *multiplayer-info* player_num) idx)
          (when (!= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-disconnected))
            ;; see if we need to spawn any remote targets
            (when (or (zero? (-> *remote-targets* idx)) (not (handle->process (-> *remote-targets* idx))))
              (set! (-> *remote-targets* idx) (start-extra-target))
              (set! (-> (the-as target (handle->process (-> *remote-targets* idx))) saved-owner) idx) ;; used to identify remote index from target
              )
            ;; assume target spawned at this point 

            ;; position/color remote targets
            (let ((p (-> *multiplayer-info* players idx))
                  (obj (the process-drawable (handle->process (-> *remote-targets* idx)))))
              (when obj
                (if (is-interactive? idx)
                  (handle-remote-interaction p idx)
                  )
                (update-actor-position obj p)
                )
              )
              (set! target-count (+ target-count 1))
            )
          )
        ((and (is-interactive? idx) (!= (-> *multiplayer-info* players idx inter_type) (interaction-type none)))
          (handle-remote-interaction (-> *multiplayer-info* players idx) idx)
          (clean-up-interaction-data (-> *multiplayer-info* players idx))
          )
        )
      )
    ;; despawn newly disconnected targets
    (when (!= target-count *remote-target-active-count*)
      (dotimes (idx MAX_MULTIPLAYER_COUNT)
        (when (!= (-> *multiplayer-info* player_num) idx)
          (when (= (-> *multiplayer-info* players idx mp_state) (mp-tgt-state mp-tgt-disconnected))
            (safe-deactivate-remote-target idx)
            )
          )
        )
      (set! *remote-target-active-count* target-count)
      )
    )
  )


(defun get-target ((idx int))
  (if (= (-> *multiplayer-info* player_num) -1)
    (if (= idx 0)
      *target*
      (the-as target #f)
      )
    (if (= (-> *multiplayer-info* player_num) idx)
      *target*
      (if (and (-> *remote-targets* idx) (nonzero? (-> *remote-targets* idx)) (handle->process (-> *remote-targets* idx)))
        (the target (handle->process (-> *remote-targets* idx)))
        (the-as target #f)
        )
      )
    )
  )


(defun get-interactive-target ((idx int))
  (if (= (-> *multiplayer-info* player_num) -1)
    (if (= idx 0)
      *target*
      (the-as target #f)
      )
    (if (= (-> *multiplayer-info* player_num) idx)
      *target*
      (if (and (-> *remote-targets* idx) (nonzero? (-> *remote-targets* idx)) (is-interactive? idx) (handle->process (-> *remote-targets* idx)))
        (the target (handle->process (-> *remote-targets* idx)))
        (the-as target #f)
        )
      )
    )
  )


;; Macros can be used more-or-less just like functions
(defmacro current-cell-count ()
  `(-> *game-info* fuel)
  )

(defmacro set-current-cell-count (count)
  `(set! (-> *game-info* fuel) ,count)
  )
  
(defun increase-power-cell-by-one ()
  (set-current-cell-count (+ (current-cell-count) 1))
  ;; with the two macros defined above, this is equivalent to
  ;; (set! (-> *game-info* fuel) (+ (-> *game-info* fuel) 1))
  (none)
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define Approved Custom Functions/Macros to call in all mods
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; These are included with the mod base and you are welcome to use them in your mods!

(defmacro current-checkpoint-name ()
  `(-> *game-info* current-continue name)
  )

(defun set-current-checkpoint-by-name ((name string))
  (set-continue! *game-info* name)
  )

(defmacro current-level-name ()
  `(-> (level-get-target-inside *level*) name)
  )
  
(defmacro current-orb-count ()
  `(-> *game-info* money)
  )

(defmacro current-cutscene ()
  `(-> *art-control* active-stream)
  )

;;This function moves an actor to the given coordinates
;;example: (move-actor "farmer-3" 3.0 74.0 -120.0)
(defun move-actor ((actor-name string) (x float) (y float) (z float))
  (when (entity-by-name actor-name)
    (let* ((entity-actor (entity-by-name actor-name))
           (actor (-> entity-actor extra process))
           )
      (when actor
        (case (-> actor type)
          ((fuel-cell)
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the fuel-cell actor) base) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the fuel-cell actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
            (when (name= (-> (the fuel-cell actor) state name) 'wait)
              ;; only move collision when idle (messes up glowing in cutscene)
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the fuel-cell actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((orb-cache-top)
            ;; don't move while its activated (let it go up/down)
            (when (not (name= (-> (the orb-cache-top actor) state name) 'orb-cache-top-activate))
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the orb-cache-top actor) basetrans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the orb-cache-top actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the orb-cache-top actor) root-override root-prim world-sphere z) (meters z))
              (set-vector! (-> (the orb-cache-top actor) draw origin) (meters x) (meters y) (meters z) 1.0)
              (let ((radius (-> (the process-drawable actor) draw radius))
                    (bounds (res-lump-data entity-actor 'visvol (inline-array vector)))
                    )
                (set-vector! (-> bounds 0) (- (meters x) radius) (meters y) (- (meters z) radius) 1.0)
                (set-vector! (-> bounds 1) (+ (meters x) radius) (meters y) (+ (meters z) radius) 1.0)
                )
              )
            )
          ((money)
            ;; don't move orbs if being blue-eco-sucked
            (when (not (logtest? (-> (the money actor) flags) (collectable-flags suck)))
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the money actor) base) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the money actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              (set! (-> (the money actor) root-override root-prim world-sphere x) (meters x))
              (set! (-> (the money actor) root-override root-prim world-sphere y) (meters y))
              (set! (-> (the money actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((crate crate-buzzer)
            ;; only move crates if they're not jumping
            (when (= (-> (the crate actor) smush amp) 0.0)
              (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
              (set-vector! (-> (the crate actor) base) (meters x) (meters y) (meters z) 1.0)
              ;; (set-vector! (-> (the crate actor) root-override trans) (meters x) (meters y) (meters z) 1.0)
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere x) (meters x))
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere y) (meters y))
              ;; (set! (-> (the crate actor) root-override root-prim world-sphere z) (meters z))
              )
            )
          ((darkvine)
            (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
          )
          (else
            (format 0 "unexpected actor type ~S ~S ~S~%" actor-name (-> entity-actor type) (-> actor type))
            (set-vector! (-> entity-actor trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> entity-actor extra trans) (meters x) (meters y) (meters z) 1.0)
            (set-vector! (-> (the process-drawable actor) root trans) (meters x) (meters y) (meters z) 1.0)
            )
          )
        )
      )
    )
  (none)
  )

(defun spawn-actor-by-name ((name string))
  ;; Takes in the string of name of a actor, and spawns a new process based on the entity.
    (let* ((entity-actor (the entity-actor (entity-by-name name)))
          (type (-> entity-actor etype))
          (e-info (entity-info-lookup type))
      )
      (when (entity-by-name name)
        (init-entity 
          (get-process *default-dead-pool* type (if e-info (-> e-info heap-size) #x4000)) 
          entity-actor)
          (sound-play "buzzer-pickup")
      )
      (if (not (entity-by-name name))
          (sound-play "oof")
      )
    )
    (none)
)

;;Draws a debug sphere on the actor, takes in a string actor name and a radius for the sphere in meters
(defun draw-debug-sphere-on-actor ((actorName string)(radius float))
  (when *debug-segment*
    (when (process-by-ename actorName)
      (add-debug-sphere #t (bucket-id debug)  (-> (the-as process-drawable (process-by-ename actorName)) root trans) (meters radius) (static-rgba 0 #xff 0 #x40))
    )
  )
  (none)
)


;;This function moves a given actor to jaks current position, then prints a (move-actors) call in gk.exe
(defun move-to-jak ((arg0 string))
(format #t "move-actor code:  (move-actor ~a ~m ~m ~m)~%" arg0(-> (target-pos 0) x) (-> (target-pos 0) y) (-> (target-pos 0) z))
  (when (process-by-ename arg0)
    (set-vector!  (-> (-> (the process-drawable (process-by-ename arg0))root)trans) (-> (target-pos 0) x) (-> (target-pos 0) y) (-> (target-pos 0) z) 1.0)
    (if (type-type? (-> (process-by-ename arg0) type) crate)
    (begin
        (set! (-> (the crate (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )

     (if (type-type? (-> (process-by-ename arg0) type) money)
    (begin
        (set! (-> (the money (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )

     (if (type-type? (-> (process-by-ename arg0) type) fuel-cell)
    (begin
        (set! (-> (the fuel-cell (process-by-ename arg0)) base y) (-> (target-pos 0) y))
    )
    (none)
    )
  )
)

;; quick macro for setting vector xyz in meters, leaving w alone
(defmacro set-vector-meters! (dst x y z)
  `(set-vector! ,dst (meters ,x) (meters ,y) (meters ,z) (-> ,dst w))
  )

;; quick macro for constructing static vector with w=1
(defmacro static-vector-meters (x y z)
  `(new 'static 'vector :x (meters ,x) :y (meters ,y) :z (meters ,z) :w 1.0)
  )

;; prints vector xyz in meters
(defmacro print-vector-meters (vec &key (dst #t))
  `(format ,dst "~m ~m ~m~%" (-> ,vec x) (-> ,vec y) (-> ,vec z))
  )

;; takes a path-control and xyz values to offsets every node in the path by
(defmacro shift-path! (path x y z)
  `(let ((voff (static-vector-meters ,x ,y ,z)))
    (dotimes (idx (-> ,path num-cverts))
      (vector+! (-> ,path cverts idx) (-> ,path cverts idx) voff)
      )
    )
  )

;; prints all the nodes in a path in meters
(defmacro path-print-meters (path)
  `(dotimes (idx (-> ,path num-cverts))
    (print-vector-meters (-> ,path cverts idx))
    )
  )

;; prints the position (root trans) of a process-drawable
(defmacro pd-pos-m (procname)
  `(let* ((obj (the process-drawable (process-by-ename ,procname)))
          (vec (-> obj root trans)))
    (format 0 "~m ~m ~m~%" (-> vec x) (-> vec y) (-> vec z) 4096.0)
    (none)
    )
  )

;;This function moves an actor based on jaks position + an offset
(defun move-to-behind-jak ((arg0 string) (arg1 meters) (arg2 meters))
 (when (process-by-ename arg0)
    (set-vector!  (-> (-> (the process-drawable (process-by-ename arg0))root)trans) (-(-> (target-pos 0) x) (meters arg1)) (+ (-> (target-pos 0) y) (meters arg2)) (-(-> (target-pos 0) z)(meters arg1)) 1.0)
    (if (type-type? (-> (process-by-ename arg0) type) money)
    (begin
        (set! (-> (the money (process-by-ename arg0)) base y) (->  (target-pos 0) y) )
    )
    (none)
    )
    (if (type-type? (-> (process-by-ename arg0) type) fuel-cell)
    (begin
        (set! (-> (the fuel-cell (process-by-ename arg0)) base y) (->  (target-pos 0) y) )
    )
    (none)
    )
  )
)

;;This turns on play hints
(defun turnonplayhints ()
(set! (-> *setting-control* default play-hints) #t)
)

;;This turns off playhints
(defun turnoffplayhints()
(set! (-> *setting-control* default play-hints) #f)
)

;;This turns on collision render when called
(defun turnonCollisionmode()
  (set! *collision-renderer* #t)
  (logclear! *vu1-enable-user-menu* (vu1-renderer-mask tfrag trans-tfrag tie tie-near))
)

;;This turns off collision render when called
(defun turnoffCollisionmode()
  (set! *collision-renderer* #f)
  (logior! *vu1-enable-user-menu* (vu1-renderer-mask tfrag trans-tfrag tie tie-near))
)

;;This makes it thunder in the current level
(defun thunderTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-village2)
  (set! (-> (level-get-target-inside *level*) mood) *village2-mood*)
)

;;This makes the current level dark when called
(defun DarkesetGlitchTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-finalboss )
  (set! (-> (level-get-target-inside *level*) mood) *finalboss-mood*)
)

;;This needs fixed
(defun rainyTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-swamp)
  (set! (-> (level-get-target-inside *level*) mood) *swamp-mood*)
)

;;This needs fixed
(defun snowingTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-snow)
  (set! (-> (level-get-target-inside *level*) mood) *snow-mood*)
)

;;This makes the current levels weather the same as village1
(defun defaultWeatherTime()
  (set! (-> (level-get-target-inside *level*) mood-func)update-mood-village1)
  (set! (-> (level-get-target-inside *level*) mood) *village1-mood*)
)

;;This moves jak to a provided coordinate example call
;;(tp-jak 0.0 12.0 32.32)
(defun tp-jak ((arg0 float)(arg1 float)(arg2 float))
  (set! (-> (target-pos 0) x) (meters arg0))
  (set! (-> (target-pos 0) y) (meters arg1))
  (set! (-> (target-pos 0) z) (meters arg2))
)

;;This returns true or false depending on if jak is within a provided distance from an actor
(defun close? ((actor-ename string) (dist float))
  (and 
    (process-by-ename actor-ename)
    (<= 
      (vector-vector-distance 
        (target-pos 0) 
        (-> (the process-drawable (process-by-ename actor-ename)) root trans)
        )
      dist
      )
    )
  )
(defun process-close? ((proc process-drawable) (dist float))
  (and 
    proc
    (<= 
      (vector-vector-distance 
        (target-pos 0) 
        (-> proc root trans)
        )
      dist
      )
    )
  )

(defun remote-target-process-close? ((remote-target target) (proc process-drawable) (dist float))
  (and 
    proc
    (<= 
      (vector-vector-distance 
        (remote-target-pos 0 remote-target) 
        (-> proc root trans)
        )
      dist
      )
    )
  )

(defun get-closest-interactive-target ((proc process-drawable))
  (let ((closest-target *target*))
    (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
      (let ((target (get-interactive-target tgt-idx)))
        (if (and target proc (<= (vector-vector-distance (remote-target-pos 0 target) (-> proc root trans)) (vector-vector-distance (remote-target-pos 0 closest-target) (-> proc root trans))))
            (set! closest-target target)
          )
        )
      )
      closest-target
    )
  )

(defun get-closest-interactive-target-to-vector ((vect vector))
  (let ((closest-target *target*))
    (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
      (let ((target (get-interactive-target tgt-idx)))
        (if (and target vect (<= (vector-vector-distance (remote-target-pos 0 target) vect) (vector-vector-distance (remote-target-pos 0 closest-target) vect)))
            (set! closest-target target)
          )
        )
      )
      closest-target
    )
  )

(defun remote-target-fake-cpad-circle-pressed? ((remote-target target))
    (and (target-is-interactive? remote-target) (= (-> remote-target state name) 'target-attack))
  )

;;This returns true or false depending on if all jaks are within a provided distance from an actor
(defun any-interactive-targets-close? ((proc process-drawable) (dist float))
  (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
    (let ((target (get-interactive-target tgt-idx)))
      (if (and target proc (<= (vector-vector-distance (remote-target-pos 0 target) (-> proc root trans)) dist))
          (return #t)
        )
      )
    )
    #f
  )

(defun any-interactive-targets-close-to-vector? ((vect vector) (dist float))
  (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
    (let ((target (get-interactive-target tgt-idx)))
      (if (and target vect (<= (vector-vector-distance (remote-target-pos 0 target) vect) dist))
          (return #t)
        )
      )
    )
    #f
  )

(defun any-remote-interactive-targets-close? ((proc process-drawable) (dist float))
  (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
    (let ((target (get-interactive-target tgt-idx)))
      (if (and target (!= target *target*) proc (<= (vector-vector-distance (remote-target-pos 0 target) (-> proc root trans)) dist))
          (return #t)
        )
      )
    )
    #f
  )

(defun target-in-level-sphere? ((level-name string))
  (if (and (-> *level* level0) (name= (-> *level* level0 name) level-name) (-> *level* level0 inside-sphere?))
    (return #t)
    )
  (if (and (-> *level* level1) (name= (-> *level* level1 name) level-name) (-> *level* level1 inside-sphere?))
    (return #t)
    )
  #f
  )

(defun has-camera-type? ((camera-type string))
  (-> *camera* child 0) (name= (-> (the-as camera-slave (-> *camera* child 0)) state name) camera-type)
  )


;;This returns true or false if jak is within a bubble defined by coordiantes and width
(defun in-bubble? ((x float) (y float) (z float) (w float))
  (<= 
    (vector-vector-distance 
      (target-pos 0) 
      (set-vector! (new-stack-vector0) x y z 1.0)
      )
    (/ w 2.0)
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Jak Color functions
;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun draw-xyz ((jak target) (x float) (y float) (z float))
  (set! (-> jak draw color-mult x) x)
  (set! (-> jak draw color-mult y) y)
  (set! (-> jak draw color-mult z) z)
)
(defun draw-normal ((jak target))
  (draw-xyz jak 1.0 1.0 1.0)
)
(defun draw-white ((jak target))
  (draw-xyz jak 3.5 3.5 3.5)
)
(defun draw-black ((jak target))
  (draw-xyz jak 0.1 0.1 0.1)
)
(defun draw-red ((jak target))
  (draw-xyz jak 0.8 0.2 0.2)
)
(defun draw-green ((jak target))
  (draw-xyz jak 0.0 1.2 0.0)
)
(defun draw-blue ((jak target))
  (draw-xyz jak 0.0 0.5 2.0)
)
(defun draw-yellow ((jak target))
  (draw-xyz jak 1.5 1.5 0.0)
)
(defun draw-pink ((jak target))
  (draw-xyz jak 1.0 0.0 1.0)
)
(defun draw-light-blue ((jak target))
  (draw-xyz jak 0.0 1.0 1.0)
)



