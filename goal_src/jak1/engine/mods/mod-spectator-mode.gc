    ;;-*-Lisp-*-
    (in-package goal)

    ;; name: mod-spectator-mode.gc
    ;; name in dgo: mod-spectator-mode
    ;; dgos: TODO

(define *spectator-handler* (new 'global 'spectator-handler))

(defun select-new-spectator ((search-forward symbol))
  (let ((selected-target (get-target (-> *spectator-handler* spectator_idx)))
        (original-index (-> *spectator-handler* spectator_idx)))
    (if (not selected-target)
      (set! selected-target *target*)
      )

    (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
      (let ((target (get-target tgt-idx)))
        (when (and target (not (is-inactive? tgt-idx)))
          (if (= selected-target *target*)
            (set! selected-target target)
            )
          (cond 
            ((= search-forward #t)
              (when (> tgt-idx original-index)
                (set! (-> *spectator-handler* spectator_idx) tgt-idx)
                (return target)
                )
              )
            (else
              (cond 
                ((and (< tgt-idx original-index) (!= target *target*))
                  (set! (-> *spectator-handler* spectator_idx) tgt-idx)
                  (set! selected-target target)
                  )
                ((!= (-> *spectator-handler* spectator_idx) original-index)
                  (return selected-target)
                  )
                )
              )
            )
          )
        )
      )
      (cond
        ;;pick first target found if move forwards and none found
        ((and (= search-forward #t) (= (-> *spectator-handler* spectator_idx) original-index))
          (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
            (let ((target (get-target tgt-idx)))
              (when (and target (!= target *target*) (not (is-inactive? tgt-idx)))
                (set! selected-target target)
                (set! (-> *spectator-handler* spectator_idx) tgt-idx)
                (return selected-target)
                )
              )
            )
          )
        ;;pick last target found if move backwards and none found
        ((and (= search-forward #f) (= (-> *spectator-handler* spectator_idx) original-index))
          (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
            (let ((target (get-target tgt-idx)))
              (when (and target (!= target *target*) (not (is-inactive? tgt-idx)))
                (set! selected-target target)
                (set! (-> *spectator-handler* spectator_idx) tgt-idx)
                )
              )
            )
          (return selected-target)
          )
        )
      selected-target
    )
  )

(defun change-spectator ((search-forward symbol) (force-refocus symbol))
  (let ((spec-target (select-new-spectator search-forward)))
    (when (and spec-target (!= spec-target *target*))
      (send-event *camera* 'change-target spec-target)
      (when force-refocus
        (send-event *camera* 'change-state cam-free-floating 0)
        (camera-change-to (the-as string 'base) 300 #f)
        (set! (-> *spectator-handler* is_refocusing?) #t)
        )
      )
    (!= spec-target *target*)
    )
  )

(defun force-stance-all ()
  (dotimes (tgt-idx MAX_MULTIPLAYER_COUNT)
    (let ((tgt (get-target tgt-idx)))
      (when (and tgt (!= tgt *target*) (target-on-foot? tgt))
        (go-process tgt target-stance)
        )
      )
    )
  )

(defun spectator-mode-main ()
  ;;ensure grabbed
  (if (not (is-grabbed?))
    (process-grab? *target*)
    )
  
  ;; is for some reason applied at the start of the run after teleport to hut
  (if (has-camera-type? 'cam-circular)
    (camera-change-to (the-as string 'base) 10 #f)
    )
    
  (if (has-camera-type? 'cam-circular)
    (camera-change-to (the-as string 'base) 10 #f)
    )

  ;; find initial target logic
  (if (and (not (-> *spectator-handler* has_found_initial_target?)) (game-has-other-targets?) (or (has-camera-type? 'cam-free-floating) (change-spectator #t #f)))
    (set! (-> *spectator-handler* has_found_initial_target?) #t)
    )

  (if (not (-> *camera* drawable-target))
    (set! (-> *spectator-handler* has_found_initial_target?) #f)
    )
  
  (when (>= (-> *display* base-frame-counter) (-> *spectator-handler* next_logic_check))
    (set! (-> *spectator-handler* next_logic_check) (+ (current-time) (seconds 0.5)))

    ;;check refocus need
    (when (has-camera-type? 'cam-string)
      (let ((spec-target (get-spectator-target)))
        (when spec-target
          (if (-> *spectator-handler* is_refocusing?)
            (when (is-camera-within-target-dist? spec-target (-> *spectator-handler* refocus_dist))
              (set! (-> *spectator-handler* is_refocusing?) #f)
            )

            (when (not (is-camera-within-target-dist? spec-target (-> *spectator-handler* refocus_dist)))
              (set! (-> *spectator-handler* is_refocusing?) #t)
              (send-event *camera* 'change-state cam-free-floating 0)
              (camera-change-to (the-as string 'base) 400 #f)
              )
            )
          )
        )
      )

    ;;ensure level is loaded
    (cond
      ((-> *spectator-handler* in_level_check_wait?)
        (when (>= (-> *display* base-frame-counter) (-> *spectator-handler* next_level_check))
          (set! (-> *spectator-handler* in_level_check_wait?) #f)
          (let ((level-name (-> *multiplayer-info* players (-> *spectator-handler* spectator_idx) current_level)))
            (when (not (is-level-alive? level-name))
              (set! (-> *spectator-handler* check_vis_nick?) #t)
              (set! (-> *spectator-handler* next_vis_nick_check) (+ (current-time) (seconds 4.0)))
              (cond
                ((-> *spectator-handler* full_new_level?)
                  (format #t "full loading level ~s in slot ~d ~%" level-name 1)
                  (set! (-> *setting-control* default border-mode) #t)
                  (load-state-want-levels (-> *multiplayer-info* players (-> *multiplayer-info* player_num) current_level) level-name)
                  (load-state-want-display-level level-name 'display)
                  (set! (-> *spectator-handler* last_level_slot_used) 1)
                  (set! (-> *spectator-handler* full_new_level?) #f)
                  )
                (else
                  (let ((level-slot (get-preferable-level-slot)))
                    (set! (-> *spectator-handler* last_level_slot_used) level-slot)
                    (format #t "force loading level ~s in slot ~d ~%" level-name level-slot)
                    (if (= level-slot 0)
                      (load-state-want-levels level-name (-> *load-state* want 1 name))
                      (load-state-want-levels (-> *load-state* want 0 name) level-name)
                      )
                    (load-state-want-display-level level-name 'display)
                    )
                  )
                )
              )
            )
          )
        )
      ((not (is-target-current-level-alive? (-> *spectator-handler* spectator_idx)))
        (let ((level-name (-> *multiplayer-info* players (-> *spectator-handler* spectator_idx) current_level)))
          (when (is-valid-level? level-name)
            (set! (-> *spectator-handler* in_level_check_wait?) #t)
            (cond
              ((-> *spectator-handler* is_refocusing?)
                (format #t "full level load ~%")
                (set! (-> *setting-control* default border-mode) #f)
                (set! (-> *spectator-handler* render_animations?) #f)
                (force-stance-all)
                (set! (-> *spectator-handler* full_new_level?) #t)
                (cond
                  ((not (is-level-alive? (-> *multiplayer-info* players (-> *multiplayer-info* player_num) current_level)))
                    (load-state-want-levels (-> *multiplayer-info* players (-> *multiplayer-info* player_num) current_level) (-> *load-state* want 1 name))
                    (load-state-want-display-level (-> *multiplayer-info* players (-> *multiplayer-info* player_num) current_level) 'display)
                    (set! (-> *spectator-handler* next_level_check) (+ (current-time) (seconds 3.0)))
                    )
                  (else
                    (set! (-> *spectator-handler* next_level_check) (current-time))
                    )
                  )
                )
              (else
                (format #t "force level load ~%")
                (set! (-> *spectator-handler* full_new_level?) #f)
                (set! (-> *spectator-handler* next_level_check) (+ (current-time) (seconds 3.0)))
                )
              )
            )
          )
        )
      )
    )

  ;;post vis check
  (when (and (-> *spectator-handler* check_vis_nick?) (is-target-current-level-alive? (-> *spectator-handler* spectator_idx)) (not (-> *spectator-handler* is_refocusing?)) (>= (-> *display* base-frame-counter) (-> *spectator-handler* next_vis_nick_check)))
    (set! (-> *spectator-handler* check_vis_nick?) #f)
    (set! (-> *spectator-handler* render_animations?) #t)
    (if (!= (-> *load-state* vis-nick) (-> *multiplayer-info* players (-> *spectator-handler* spectator_idx) current_level))
      (load-state-want-vis (-> *multiplayer-info* players (-> *spectator-handler* spectator_idx) current_level))
      )
    )
    
  ;;spectator toggles
  (when (not (and (cpad-hold? 0 l2) (cpad-hold? 0 r2)))
    (cond
      ((cpad-pressed? 0 r3)
        (if (has-camera-type? 'cam-free-floating)
          (camera-change-to (the-as string 'base) 400 #f)
          (send-event *camera* 'change-state cam-free-floating 300)
          )
        )
      ((cpad-pressed? 0 up)
        (if (has-camera-type? 'cam-lookat)
          (camera-change-to (the-as string 'base) 400 #f)
          (send-event *camera* 'change-state cam-lookat 200)
          )
        )
      ((cpad-pressed? 0 down)
        (send-event *camera* 'change-state cam-free-floating 0)
        (camera-change-to (the-as string 'base) 400 #f)
        )
      ((cpad-pressed? 0 right)
        (change-spectator #t #t)
        )
      ((cpad-pressed? 0 left)
        (change-spectator #f #t)
        )
      )
    )
  )
  
